% !iTexMac(input): thesis.tex

% Information about the thesis
\newcommand{\myTitle}{Compiling Imperative and Functional Languages\xspace}
%\newcommand{\mySubtitle}{}
\newcommand{\myDisplayTitle}{{\color{Maroon}\spacedallcaps{\myTitle}\ifx\mySubtitle\\\mySubtitle\fi}}
\newcommand{\myFullTitle}{\ifx\mySubtitle\myTitle \mySubtitle\else\myTitle\fi}
\newcommand{\myDegree}{Bachelor of Arts\xspace}
\newcommand{\myName}{Jeremy W. Sherman\xspace}
\newcommand{\myAdvisor}{Dr. Karsten Henckell\xspace}
\newcommand{\myCommittee}%
    {Dr. Karsten Henckell, Dr. Patrick McDonald, Dr. David Mullins\xspace}
\newcommand{\myDivision}{Division of Natural Sciences\xspace}
\newcommand{\myUni}{\protect{New College of Florida}\xspace}
\newcommand{\myLocation}{Sarasota, Fla.\xspace}
\newcommand{\myTime}{May 2008\xspace}

% Tricky TOC/display stuff
\newcommand{\forcemark}[1]{\manualmark\markboth{\spacedlowsmallcaps{#1}}{\spacedlowsmallcaps{#1}}}
\newcommand{\anchorme}{\refstepcounter{dummy}}%\typeout{dummy = \thedummy}}
% If we could precede all paragraph and subsubsection calls with \anchorme, they might actually go to the proper page instead of that of the closest preceding figure, table, or (sub)section. Or does just labeling them work? We'll have to check later.
\newcommand{\partlevelChapter}[1]{\forcemark{#1}\anchorme%
\addcontentsline{toc}{part}{\texorpdfstring{\color{Black}\spacedlowsmallcaps{#1}}{#1}}%
\chapter*{#1}}

% Semantic markup
\newcommand{\code}[1]{\text{\small\ttfamily #1}} %the variable \code{x}
\newcommand{\foreign}[1]{\textit{#1}} %the \foreign{Entscheidungsproblem}
\newcommand{\asword}[1]{\textit{#1}} %such a strange word, \asword{word.}
\newcommand{\vocab}[2][]{\spacedlowsmallcaps{#2}} %the \vocab{lambda terms} are...
%\newcommand{\abbrev}[1]{\spacedallcaps{#1}} % too spaced out, interrupts reading
\newcommand{\abbrev}[1]{#1} % \abbrev{IBM}
\newcommand{\Deutsch}[1]{\foreign{\begin{otherlanguage}{ngerman}#1\end{otherlanguage}}}
% Expressing substitution: replace:#1 with:#2 in:#3
\newcommand{\replace}[3]{\ensuremath{#3\left[#1 := #2\right]}} %M[x := N]
%\newcommand{\replace}[3]{\ensuremath{#3\left[#2 / #1\right]}} %M[N/x]
\newcommand{\empause}{ -- }%{---}; using spaced en-dash per Bringhurst
\newcommand{\redex}[1]{{\color{Maroon}#1}}%formerly Red

% Simple abbreviations
\newcommand{\lambdacalc}{lambda calculus\xspace} %We discuss the \lambdacalc...
\newcommand{\Lambdacalc}{Lambda calculus\xspace} %\Lambdacalc is really cool.
\newcommand{\LambdaCalc}{Lambda Calculus\xspace}%\section{\LambdaCalc}
\newcommand{\lambdacalcs}{lambda calculi\xspace}
\newcommand{\TM}{Turing machine\xspace}
\newcommand{\TMs}{Turing machines\xspace}
\newcommand{\ISL}{instruction-set language\xspace}
\newcommand{\ISA}{instruction-set architecture\xspace}
\newcommand{\CISC}{\abbrev{CISC}\xspace}
\newcommand{\CISCs}{\abbrev{CISC}s\xspace}
\newcommand{\RISC}{\abbrev{RISC}\xspace}
\newcommand{\RISCs}{\abbrev{RISC}s\xspace}
\newcommand{\FA}{finite automaton\xspace}
\newcommand{\FAs}[1][f]{#1inite automata\xspace} %\FAs[F] -> Finite...; \FAs -> finite...
\newcommand{\regex}{regular expression\xspace}
\newcommand{\regexes}{regular expressions\xspace}
\newcommand{\CFG}{context-free grammar\xspace}
\newcommand{\CFGs}[1][c]{#1ontext-free grammars\xspace}
\newcommand{\PDA}{pushdown automaton\xspace}
\newcommand{\PDAs}{pushdown automata\xspace}
\newcommand{\IR}{intermediate representation\xspace}
\newcommand{\IRs}{intermediate representations\xspace}
\newcommand{\AST}{abstract syntax tree\xspace}
\newcommand{\ASTs}{abstract syntax trees\xspace}
\newcommand{\SSA}[1][short]{\ifthenelse{\equal {#1}{short}}{%then is short - the default
         \spacedlowsmallcaps{SSA}\xspace%this suggests all \abbrev should be in small caps...
     }{%else is long
         static single assignment\xspace%
     }%end-if
}%end-def

%\BURS[Long]{pl} -> Bottom-up...
%\BURS[long]{pl} (default) -> bottom-up...
%\BURS[short]{pl} -> \abbrev{BURS}
%all are followed by \xspace; pl can also be sg, and represents whether the result is plural or singular. This doesn't matter for the short form.
\newcommand{\BURS}[2][long]{\ifthenelse{%
\equal{#1}{long}}{%
bottom-up rewrite system\ifthenelse{\equal{#2}{pl}}{s}{}}{%
\ifthenelse{\equal{#1}{Long}}{%
Bottom-up rewrite system\ifthenelse{\equal{#2}{pl}}{s}{}}{%
\abbrev{BURS}%
}%close inner if-then-else
}%close outer if-then-else
\xspace}%tack on tailing \xspace and close newcommand

\newcommand{\Fortran}[1][]{\spacedlowsmallcaps{FORTRAN#1}\xspace}
\newcommand{\Algol}[1][]{\spacedlowsmallcaps{ALGOL#1}\xspace}
\newcommand{\Unix}{\spacedlowsmallcaps{UNIX}\xspace}

\newcommand{\CPS}[1][short]{\ifthenelse{\equal {#1}{short}}{%then is short - the default
         \spacedlowsmallcaps{CPS}\xspace%this suggests all \abbrev should be in small caps...
     }{%else is long
         continuation passing style\xspace%
     }%end-if
}%end-def

\newcommand{\ML}{\abbrev{ML}\xspace}

% More complex macros
% Two options for part-and-namerefs. First has problems if hyphenation interferes with the hyperref'd part and also creates too much emphasized text. Second emphasizes (via a link) only the part name.
%\newcommand{\partandnameref}[2]{\hyperref[#2]{#1}~\ref{#2}, \nameref{#2}}
\newcommand{\partandnameref}[2]{#1~\ref*{#2}, \nameref{#2}} % \partandnameref{Chapter}{label} -> Chapter 9, NAME

% Math: Semantic markup
\newcommand{\set}[1]{\ensuremath{\left\{ #1 \right\}}} % X = {1, 2, 3}
\newcommand{\union}{\ensuremath{\cup}}
\newcommand{\from}{\colon} % f: X -> Y
\newcommand{\emptyword}{\ensuremath{\epsilon}}
\newcommand{\kstar}{\ensuremath{^{\star}}{}}
\newcommand{\posclos}{\ensuremath{^{+}}{}}
\newcommand{\alt}{\ensuremath{\mid}}%{\ensuremath{\,\vert\,}}

\newcommand{\produces}{\ensuremath{\rightarrow}}
\newcommand{\altproduces}{\ensuremath{::=}}
\newcommand{\derivesrelay}[1][]{\ensuremath{\xRightarrow[#1]{\DArgTop}}}
\newcommand{\derives}[1][]{\def\DArgTop{{#1}}\derivesrelay} % S \derives[*][lm] foo
\newcommand{\token}[1]{\ensuremath{\langle\text{\textit{#1}}\rangle}}
\newcommand{\where}{\mid}
\newcommand{\pair}[2]{\ensuremath{\left(#1,\,#2\right)}}

\newcommand{\reducesinto}[2][]{\ifthenelse{\equal{#1}{}}{\ensuremath{\rightarrow_{#2}}}{\ensuremath{\twoheadrightarrow_{#2}}}}% reducesInSteps:ToTerm:
\newcommand{\betared}[1][]{\reducesinto[#1]{\beta}}
\newcommand{\alphared}[1][]{\reducesinto[#1]{\alpha}}
\newcommand{\etared}[1][]{\reducesinto[#1]{\eta}}
\newcommand{\betacon}{\ensuremath{=_{\beta}}}
\newcommand{\etacon}{\ensuremath{=_{\eta}}}
\newcommand{\FV}[1]{\ensuremath{\mathcal{FV}(#1)}}
\newcommand{\etify}[2]{\ensuremath{\lambda #1 . (#2) #1}}
\newcommand{\dred}[1][]{\reducesinto[#1]{\delta}}

\newcommand{\type}[1]{\text{\code{#1}}}
\newcommand{\typecon}[1]{\text{\textsf{#1}}}
\newcommand{\const}[1]{\text{\textit{#1}}}
\newcommand{\stmt}[3][math]{\ifthenelse{\equal{#1}{math}}%
{\ensuremath{#2 : #3}}% \stmt{term}{\sigma}; this is the default behavior
{\ensuremath{#2 : \type{#3}}}}% \stmt[text]{term}{int}; should we use \colon instead of :?
\newcommand{\basis}{\ensuremath{\mathcal{B}}}
\newcommand{\turnstile}{\ensuremath{\vdash}}


% Math: Simple abbreviations
\let\oldprime=\prime
\renewcommand{\prime}{\ensuremath{^{\oldprime}}{}} % automatic superscript; random {} at the end is necessary to avoid complaints from LaTeX about double superscripts when one \prime directly follows another, e.g. v\prime\prime.

% Tokenization
\newcommand{\mtt}[1]{\ensuremath{\text{\ttfamily#1}}}
\newcommand{\mt}[1]{\ensuremath{\text{\ttfamily\small#1}}}
\newcommand{\mk}[1]{\mt{\color{RoyalBlue}#1}}
\newcommand{\crsymb}{\rotatebox[origin=c]{180}{\ensuremath{\Rsh}}}
\newcommand{\spacedtab}{\textvisiblespace\textvisiblespace\textvisiblespace\textvisiblespace}
% Blocking Tokens
% I've been forced to hardcode angle brackets to handle multiline tokens. Only underlining would also work with multiline tokens without a ton more work to have open-ended boxes or part of a brace on one line that continues on the next.
\newcommand{\block}[2]{\langle#1\rangle_{\mtt{#2}}}%put each token in angle brackets
%\newcommand{\block}[2]{\underset{\mtt{\hspace{0.5em}#2\hspace{0.5em}}}{\underline{\vphantom{\mt{\textvisiblespace}}#1}}}%underline each token
%\newcommand{\block}[2]{\underset{\mtt{#2}}{\fbox{\mt{\vphantom{\crsymb\textvisiblespace}}#1\hspace{1pt}}}}%box each token
%\newcommand{\block}[2]{\underbrace{\vphantom{\mt{\textvisiblespace}}#1}_{\mtt{#2}}}%brace beneath each token