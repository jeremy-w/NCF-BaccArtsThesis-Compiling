\section{Bootstrapping, Self-Hosting, and Cross-Compiling}
Compilers have their own chicken-and-egg problem: Compilers are programs written in some language that compile programs written in a language, potentially programs written in the same language in which they themselves are written. Compilers written in their own source language are known as \vocab{self-hosting compilers} and are a particularly puzzling instance of this problem. Further, compilers run on a variety of machines: where did the first compiler for a new machine come from? These problems have several solutions. One can go about growing a compiler incrementally, by way of another compiler, by way of an interpreter, or by cross-compiling.\footnote{\vocab{T-diagrams} are frequently employed to explain these methods, but I have always found them more confusing than helpful and omit them here. The \spacedlowsmallcaps{T} encodes the three relevant issues of a compiler: the source language to the left, the target language to the right, and the machine the compiler runs on at the base.}

To grow a compiler incrementally, one implements a compiler for a subset of the source language in a language understood by an existing compiler (or even in machine language) and then uses this core language to write a compiler that can translate a greater subset of the source language; this can be repeated as many times as necessary to encompass the entire language.

One can implement a compiler for the desired source language in a language already understood by a running compiler. Once that compiler has been used to generate a compiler for the new source language, a compiler for that language can be written using the language and compiled with this compiler to obtain a self-hosting compiler.

If an interpreter for the language exists, a self-hosting compiler can be written immediately and run in the interpreter on its own source code to create a compiled version of itself. Due to the comparative slowness of interpreted code next to compiled code, it may be necessary to interpret only a skeleton of the compiler and use that to compile only the same skeleton. This skeleton, for example, might omit all optimization and use only the simplest of algorithms for code generation. Once a skeleton compiler exists, it can be run on code for the full compiler, producing a compiler capable of optimization and clever code generation. This compiler, however, will not be as efficient as possible, since it was compiled with the skeleton compiler: this can be resolved by having the slow-running, full compiler compile its own source code, at which point the desired faster, full compiler will be obtained.

\vocab{Cross-compilation} is a quick way to produce compilers for new machines.\footnote{Cross-compilers are also essential in embedded situations, where the target does not have the resources to run a compiler and it is impossible to develop an application for the machine using the machine itself.} A cross-compiler is a compiler that compiles across target machines, for example a C compiler running on a \abbrev{SPARC} machine but generating code runnable by a PowerPC. By cross-compiling the compiler itself, a compiler for the new machine is readily obtained. This allows one to leverage all the work put into creating the compiler for the original machine.

Clearly, a variety of solutions to this problem exist, but I hope the central idea of \vocab{bootstrapping} has come through, that of using what you have now to pull yourself up to where you would like to be. The particular approach employed depends very much on the circumstances and on the preferences of the compiler writers.
%TODO: If you're not going to use T-diagrams, at least use some diagrams! Even quasi-flowcharts would help here.