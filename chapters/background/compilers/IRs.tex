\section{Intermediate Representations}
Translation begins with a source language and ends with a target, but those are rarely the only representations of the program used during compilation. Between the initial representation of the source code input to the compiler and the final representation of the target code output from the compiler, the compiler will use various \vocab{intermediate representations (\abbrev{IR}s)}. These need not resemble either the initial or final representation in the least, and the compiler is not restricted to use only one intermediate representation. Intermediate representations are, in a sense, common, private languages used within and between different parts of a compiler that support the operation of those parts.

The \IRs chosen affect all parts of the compiler, both on the superficial level of simple representation of the code and on the deeper level of how the compiler carries out its translation and even how much the compiler can prove about the runtime behavior of the code to exploit in optimizing it.

For all its importance, \IRs remain more a matter of craft than science. Many \abbrev{IR}s have been used\empause estimates of two for every compiler ever created are likely conservative\empause , but this myriad of \abbrev{IR}s nevertheless is susceptible to categorization along various axes. Two such axes are the form of the \IR and its level of abstraction.

\subsection{Form}
Intermediate representations divide broadly into classes based on their structure: those whose structure is linear, and those whose structure is graphical.

\subsubsection{Linear}
Linear \abbrev{IR}s resemble the structure of most programming languages, in that they have an implicit sequencing: begin at the beginning and process each instruction in turn till the last instruction is processed. Jump instructions of some form or another\empause either as higher-level, structured control flow constructs such as \code{while} and \code{for}, or as lower-level jumps and branches to labeled statements (or, at an even lower level, to statements a certain offset away)\empause can be used to explicitly alter this implicit order.

Linear \abbrev{IR}s have the advantage of being easy to represent for debugging or otherwise observing the actions of the compiler. They can also be easily written out to a text file. They simply become lines of text. Their flat, linear structure can also be a disadvantage. They have no easy way to share identical lines between sections beyond threading through them again via jumping. This can inflate the size of the \abbrev{IR} code and hide redundant computations. At the same time, because of their similarity to most target languages, a linear \abbrev{IR} can be a very good choice for when a compiler must finally perform target code generation.

\subsubsection{Graphical}
Graphical \abbrev{IR}s are so-called because they represent the program as a graph with arcs and nodes rather than as a large, linear sequence. Depending on the graphical \abbrev{IR} used, this can obscure control flow, but it can also represent higher-level structure than is possible in a linear \abbrev{IR}. Tree-based \abbrev{IR}s suffer from the same issues of size and repetition of common substructure as textual \abbrev{IR}s. Graphical \abbrev{IR}s based on \vocab{directed acyclic graphs}, which can be thought of as trees that admit merging of branches,\footnote{Or, if you are more mathematically inclined, can be thought of as directed graphs restricted not to have cycles, that is, a sequence of arcs leaving one node that can be traversed obeying their direction in order to return to the initial node. It is clear which viewpoint prevailed in the name of the structure.} can avoid both of these faults, though since, in imperative programming languages, \code{x} at one point in the program need not be the same as \code{x} at another, the textual identity of two repetitions of \code{compute(x)} may not actually be a sign of redundant computation. Graphical \abbrev{IR}s always introduce a question of representation: many data structures can be used to represent graphs and many algorithms can be used to carry out the same operation, and each choice of data structure and algorithm has its own tradeoffs.

It is also not convenient to represent a graphical \abbrev{IR} as some form of output for human consumption; the \abbrev{IR} must either be sequenced and encoded into a linear form, or more complex and time-consuming techniques must be employed to create a pictorial representation. This latter is not an option for storing information for the compiler's consumption: the \abbrev{IR} must then be encoded into a linear representation, though the compiler does not require a textual representation\empause a novel binary representation developed to suit the compiler's needs might in this case be the better choice. Regardless of problems of representation, many operations performed by the compiler are best expressed as operations on a graph, and a graph is often the most natural form to view the code from, as in the \vocab{control flow graph} that graphically depicts blocks of sequentially executed code (so-called \vocab{basic blocks}) connected by directed arcs to blocks that control might transfer to.

\subsection{Level of Abstraction}
\IRs can also be classified by their level of abstraction. Some levels of abstraction are more appropriate for the application of some optimizations than others. Some optimizations can usefully be used at many levels of abstraction, while others can only be used at a certain level of abstraction: for example, optimizations dealing with register usage require that register usage be exposed by, expressed in, and directly manipulable through the \IR{}. In this case, only a low-level \IR will do.

High-level \IRs are frequently very close to the source language. They often include direct representations of structured control flow and indexed array accesses. However, much like the source language itself, they are not very suitable for the application of many optimizations, so they see only limited use within a compiler. An example of a high-level linear \IR would basically be a simple high-level programming language. A common high-level graphical \IR is the \vocab{abstract syntax tree (AST)}. An \AST is something of an abbreviated parse tree; it omits ``uninteresting nodes'' and eliminates the lower-level information of the parse tree in favor of a more semantically relevant and concise form.%
%FIXME: Give an example of an AST, or even of all these levels of abstraction!

Mid-level \IRs are much like high-level \IRs{}, except that they will generally require explicit computation of array accesses and eliminate structured control flow in favor of labels, jumps, and branches. It is very possible to blend high- and mid-level \IRs{}.

Low-level \IRs expose many more details about the target language and target machine. While this strongly suggests use of what is virtually the assembly language of the target machine, it is still possible to employ a graphical \IR{}. Such an \IR will have to provide a way to indicate indirection through memory addresses (in the jargon of C and its relatives, this would be called ``pointer dereferences'').

\subsection{Static Single Assignment Form}
%CRIT-FIXME: Need to discuss SSA form. Should I present it as something of a hybrid between linear and graphical? And then, where should I put this discussion of IRs? Is it okay here, then forward reference if I mention SSA in the middle end section...?

\subsection{Symbol Tables}
We include along with the \IR{} the tables of information maintained by the compiler. The most prominent of these is the \vocab{symbol table}, which records information on all symbols\empause variables, function names, and the like\empause in use in the program. The type of information in the symbol table reflects where in the compilation process the compiler is and partially determines the level of the current \IR. Basic information is usually gathered through cooperation between the scanner and parser and is often necessary for and augmented during static semantic analysis. Other parts of the compiler will introduce further annotations to the symbols. The information stored for a symbol might include details such as the name, storage class (statically allocated, dynamically allocated, or created and destroyed along with a procedure), type, size, and much more. Use of a symbol table is in some senses analogous to allowing all semantic rules access to the attributes of the goal symbol: the table provides a way to readily aggregate information collected from a variety of places, in a variety of ways, at a variety of times.