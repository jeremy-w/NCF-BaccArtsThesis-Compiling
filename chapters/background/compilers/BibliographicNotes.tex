\section{Bibliographic Notes}\label{background:compilers:bibliographicnotes}
\Citet{Hopcroft:Introduction:2007} is a standard textbook covering languages and \TMs and touching on computational complexity. Its emphasis is on the abstract machines and the languages themselves as opposed to scanning and parsing. The classic reference for compiler design is \citet{Aho:Compilers:2006}, known affectionately as ``the dragon book'' for its cover art. (The color of the dragon is sometimes used to give the edition.) Many more recent texts still refer the reader to it for its detailed information on scanning and parsing, which is dealt with more cursorily in more modern texts to allow more discussion of optimization. A new edition was released in 2006 with some new content, but it is unclear to me at this time to what extent some of the older content has been updated. For example, by the time the previous, 1986 edition \citep{Aho:Compilers:1986} was released, the exponential space-time problem of the original LR algorithm had already been addressed in \citet{Pager:The-lane:1973}, but that edition retained the earlier, 1977 edition's \citep{Aho:Principles:1977} presentation of LALR parsers as the ultimate LR parser because of this problem. (\Citeauthor{Pager:The-lane:1973}'s method was later illustrated and explained more clearly and briefly, though less formally, in \citet{Spector:Efficient:1988}.)
%FIXME: This is a pathetic excuse. You need to get your hands on a copy of the new dragon.

A good, modern, introductory textbook on compiler design is \citet{Cooper:Engineering:2004}. \Citet{Muchnick:Advanced:1997} picks up where a course using that book would leave off by giving more advanced information on the basic content and covering optimization and analysis in great detail. As one implements more optimizations in a compiler, the problem of optimization phase ordering, mentioned in~\ref{background:compilers:middle-end:phase-ordering} on page~\pageref{background:compilers:middle-end:phase-ordering}, grows in importance. One cannot escape the problem even by forgoing compilers to code directly in assembly, as it affects even even hand-optimized code \citep{Hines:Using:2005}. \Citet{Kulkarni:Fast:2005} describes an interesting attack on the problem by way of genetic algorithms.

Textbooks on compilers often seem to give the impression that scanning and parsing are solved problems and the world has moved on. While that might be the case for scanning, parsing is still an active area of research. The Purdue Compiler Collection Tool Set bucked the trend of providing LR-style parser generators in favor of developing an LL parser generator. This parser generator is now a project in itself, ANTLR (ANother Tool for Language Recognition) \citep{Parr:ANTLR:1995}. Other areas of research are implementing practical full LR parsers (see Menhir \citep{Pottier:Menhir:2007} for an example) and GLR parsers (for example, Elkhound \cite{McPeak:Elkhound:2002}), as well as addressing problems of development of domain-specific languages and composable grammars; see, for example, \citet{Wyk:Context-aware:2007} and \citet{Bravenboer:Concrete:2004} and other work by those authors.\nocite{Bravenboer:Preventing:2007} A more thorough and up to date reference than \citet{Aho:Compilers:2006} for parsing is \citet{Grune:Parsing:2007}.

Another research direction in parsing theory is that of scannerless parsers. We have presented the lexer and parser as distinct but interacting modules of a compiler with their own theoretical bases. This division is standard in compiler design: from a software engineering perspective, it allows for the two to be tested and debugged independently; from a theoretical perspective, it allows research into the twin topics of regular and context-free languages to be utilized each to its utmost. Merging the two into a single, scannerless parser brings advantages, but it also presents problems. These are described in \citet{Visser:Scannerless:1997}. A specific aspect of the solution to some of these problems is the subject of \citet{Brand:Disambiguation:2002}. \citet{Bravenboer:Declarative:2006} presents an example of a successful, practical application of scannerless parsers.

Attribute grammars augment context-free grammars with attributes and semantic rules in order to describe the program's semantic meaning. We developed attributed trees from parse trees; we next described how semantic rules are used to perform attribute evaluation in the context of an attributed tree; finally, we discussed the problems inherent in this theoretical framework, such as the difficulty it has handling non-local information such as that often stored in a symbol table in \foreign{ad hoc} methods of semantic analysis. There's more to be said about attribute grammars than this, though, and their uses extend beyond compilers. They can be put to good use in the generation of debuggers, syntax-aware editors, and entire interactive development environments. They are also useful in language design, while the semantics of the language are still changing rapidly. A good survey of attribute grammars as they are actually used is \citet{Paakki:Attribute:1995}, which, in addition to explaining attribute grammars and giving examples of their use, introduces a taxonomy classifying the various attribute grammar paradigms that have developed.