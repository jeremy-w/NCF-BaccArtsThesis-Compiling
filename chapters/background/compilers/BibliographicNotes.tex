\section{Bibliographic Notes}\label{background:compilers:bibliographicnotes}
\Citet{Hopcroft:Introduction:2007} is a standard textbook covering languages and \TMs and touching on computational complexity. Its emphasis is on the abstract machines and the languages themselves as opposed to scanning and parsing. The classic reference for compiler design is \citet{Aho:Compilers:2006}, known affectionately as ``the dragon book'' for its cover art. (The color of the dragon is sometimes used to give the edition.) Many more recent texts still refer the reader to it for its detailed information on scanning and parsing, which is dealt with more cursorily in more modern texts to allow more discussion of optimization. A new edition was released in 2006 with some new content, but it is unclear to me at this time to what extent some of the older content has been updated. For example, by the time the previous, 1986 edition \citep{Aho:Compilers:1986} was released, the exponential space-time problem of the original LR algorithm had already been addressed in \citet{Pager:The-lane:1973}, but that edition retained the earlier, 1977 edition's \citep{Aho:Principles:1977} presentation of LALR parsers as the ultimate LR parser because of this problem. (\Citeauthor{Pager:The-lane:1973}'s method was later illustrated and explained more clearly and briefly, though less formally, in \citet{Spector:Efficient:1988}.)
%FIXME: This is a pathetic excuse. You need to get your hands on a copy of the new dragon.

A good, modern, introductory textbook on compiler design is \citet{Cooper:Engineering:2004}. \Citet{Muchnick:Advanced:1997} picks up where a course using that book would leave off by giving more advanced information on the basic content and covering optimization and analysis in great detail. As one implements more optimizations in a compiler, the problem of optimization phase ordering, mentioned in~\ref{background:compilers:middle-end:phase-ordering} on page~\pageref{background:compilers:middle-end:phase-ordering}, grows in importance. One cannot escape the problem even by forgoing compilers to code directly in assembly, as it affects even even hand-optimized code \citep{Hines:Using:2005}. \Citet{Kulkarni:Fast:2005} describes an interesting attack on the problem by way of genetic algorithms.

Textbooks on compilers often seem to give the impression that scanning and parsing are solved problems and the world has moved on. While that might be the case for scanning, parsing is still an active area of research. The Purdue Compiler Collection Tool Set bucked the trend of providing LR-style parser generators in favor of developing an LL parser generator. This parser generator is now a project in itself, ANTLR (ANother Tool for Language Recognition) \citep{Parr:ANTLR:1995}. Other areas of research are implementing practical full LR parsers (see Menhir \citep{Pottier:Menhir:2007} for an example) and GLR parsers (for example, Elkhound \cite{McPeak:Elkhound:2002}), as well as addressing problems of development of domain-specific languages and composable grammars; see, for example, \citet{Wyk:Context-aware:2007} and \citet{Bravenboer:Concrete:2004} and other work by those authors.\nocite{Bravenboer:Declarative:2006}\nocite{Bravenboer:Preventing:2007} A better reference than \citet{Aho:Compilers:2006} for parsing is \citet{Grune:Parsing:2007}.