\myChapter{History}\label{functional:history}
\input{chapters/functional/history/Predecessors}
\input{chapters/functional/history/Modern}

%TODO: Stick in conclusion.
%\section{Criticisms}
%\subsection{Trivial Update Problem}
%\subsection{Explicit versus Implicit Parameters}
%\subsection{Input--Output}
%\subsection{Lack of Familiarity}

\section{Bibliographic Notes}
\citet{Hudak:Conception:1989} surveys the history of functional programming languages through the 1980s. It develops the concepts of the \lambdacalc and its extensions in parallel to the history. This survey particularly influenced the overall shape of our history.

Lisp made its debut in McCarthy's seminal paper ``Recursive Functions of Symbolic Expressions and their Computation by Machine, Part~I''~\citep{McCarthy:Recursive:1960}.\footnote{If you read this paper, you will find that we have fudged some of the technical details of Lisp's description and omitted recounting some significant innovations that were not relevant to the body of functional programming. This was intentional.} There is a good body of literature on the history of Lisp. McCarthy gives a recounting of its early history~\citep{McCarthy:History:1978}. \Citet{Stoyan:Early:1984} covers much the same time period, concluding their history a bit before McCarthy, but where McCarthy's history was based primarily on his recollection, theirs is based on written records. It is very interesting to watch the elements of Lisp gradually fall into place here and there throughout various documents. McCarthy's Lisp retrospective~\citep{McCarthy:LISP:1980} provides a very concise recounting of the most significant innovations and characteristic elements of Lisp. \Citet{Steele-Jr.:The-evolution:1993} gives a fascinating recounting of the tumultuous history of the Lisp family that transpired between the early history as described by McCarthy and Stoyan and the standardization of Common Lisp. \Citet{Layer:Lisp:1991} describes the novel elements of the Lisp programming environment, including some information on Lisp machines, computers that were specially developed to support Lisp and its environment. As for Scheme, its community recently (2008) ratified \textit{The Revised$^{6}$ Report on the Algorithmic Language Scheme}.\footnote{Affectionately known as the \abbrev{R$^{6}$RS}; the \abbrev{R$^{6}$R} part stands for the \textit{Revised Revised \dots Revised Report.} For the report itself as well as details on the process that led to its ratification, see \url{http://www.r6rs.org/}.}

Iswim was introduced by Landin~\citep{Landin:The-next:1966} as language framework meant to support creation of full-featured domain-specific languages. FP was first described in Backus's Turing award lecture~\citep{Backus:Can-programming:1978}. APL is described in a book~\citep{Iverson:A-programming:1962} by its creator, Iverson.

Gordon gives a brief history~\citep{Gordon:From:2000} of the LCF theorem prover project that led to ML and of LCF's successors. The type system and inference algorithm described by Milner~\citep{Milner:A-theory:1978} was also independently developed by Curry~\citep{Curry:Modified:1969} and Hindley~\citep{Hindley:The-principal:1969}. Milner's work was subsequently extended by Damas~\citep{Damas:Principal:1982}. The type inference algorithm is known as both the Hindley--Milner algorithm and the Damas--Milner algorithm and centers around the unification of type variables. The algorithms can also be expressed in terms of generating and subsequently solving a system of constraints~\citep{Pottier:A-modern:2005}. Kuan and MacQueen have described~\citep{Kuan:Efficient:2007} how two compilers, one for Standard ML and one the Objective Caml compiler, have improved the efficiency of the algorithm by ranking type variables.

Standard ML~\citep{Milner:The-Definition:1990,Milner:Commentary:1990,Milner:The-Definition:1997} incorporated a module system developed by MacQueen~\citep{MacQueen:Structure:1981,MacQueen:Modules:1984,MacQueen:Using:1986,MacQueen:A-semantics:1994}. Unlike the language definition itself, part of the documentation of the Standard Basis is available online~(\url{http://sml.sourceforge.net/Basis}) as well as in a book~\citep{Gansner:The-Standard:2002}. The website provides only the formal specification; the book includes tutorials and idioms, as well. An initiative~(\url{http://sml.sourceforge.net/}) is under way to support the development of common tools and test suites and more coordination overall between Standard ML implementors and implementations.

The recollections of a member of the team that developed Caml~\citep{Cousineau:A-brief:1996} provided much of the material for our description of the Caml language family. Information on the current status of the various Caml languages can be found online~(\url{http://caml.inria.fr/}).

Documentation of \abbrev{SASL} and \abbrev{KRC} is sparse. Very little on \abbrev{SASL} was published outside technical reports and user manuals. A later version of the user manual~\citep{Turner:SASL:1976} indicates that \abbrev{SASL} was extended with \abbrev{KRC}'s list comprehensions and support for floating point numbers. Another paper~\citep{Richards:An-overview:1984} introduces the implementation of \abbrev{SASL} at the Austin Research Center, which went by the name \abbrev{ARC SASL}. \abbrev{ARC SASL} also included list comprehensions, though there is no indication of floating point support. \abbrev{KRC}~\citep{Turner:The-semantic:1981} was introduced as part of a paper explaining why functional programming languages are superior to others, where it is described succinctly as ``(non-strict, higher order) recursion equations + set abstraction.''

Miranda was created by Turner in the 1980s~\citep{Turner:Miranda:1985} and heavily influenced the design of Haskell. Miranda can now be freely downloaded for personal or educational use from~\url{http://www.miranda.org.uk}. The history of Haskell, including its use of type classes and monads, is thoroughly described~\citep{Hudak:A-history:2007} by several members of the committee that developed the language. Current information, including an up-to-date version of the published Haskell Report~\citep{Peyton-Jones:Haskell:2003} defining the language, is available online~(\url{http://haskell.org/definition}).

%TODO: Stick in conclusion.
%Monads, which we introduced in the context of input--output, are used extensively in Haskell but the concept and its uses continue to prove difficult to grasp. Most texts discussing Haskell take a stab at explaining monads along the way, but \citet{Wadler:Monads:1995} focuses exclusively on the use of monads in functional programming. \Citet{Peyton-Jones:Tackling:2000} focuses on how Haskell handles the ``awkward squad'' of input--output, concurrency, exceptions, and interfacing with other languages. These topics provide many examples of monads and their uses in Haskell, as well as being of interest for functional languages in general as an record of one set of solutions to some thorny issues for functional programming.
%
%\citet{Scott:Programming:2006} discusses the trivial update problem after introducing functional programming using Scheme (an influential Lisp) and Haskell.