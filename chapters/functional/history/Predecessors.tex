\section{Predecessors}
There does not appear to be a consensus on which language was the first, truly functional language. This is because the argument inevitably ends up being about how the terms of the argument should be defined. What is a functional language? Are there elements it must have? Elements it must not? Do research languages count, or does a language have to have seen significant ``real world'' use? Is a given ``language'' really a language, or is it simply a dialect?

You will have to make up your own mind about these matters, possibly on a case-to-case basis. Regardless of your decisions, there \emph{is} a good consensus on which languages contributed to the development of the functional family, regardless of whether or not they truly belong to it. To dodge the whole issue, we will simply characerize them as the predecessors of modern functional languages.

\subsection{Lisp}
The earliest predecessor is the list processing language. Known as LISP when it first appeared in the late 1950s (it was all the rage then to capitalize the names of programming languages), and since grown into a diverse family of Lisps, it appeared shortly after Fortran. It originated with McCarthy, and, in fact, elements of its list processing facilities were first implemented as extensions of Fortran \citep{Stoyan:Early:1984}.

Lisp grew out of artificial intelligence, particularly the expert systems and their need to perform list processing and limited theorem proving. In fact, the list is its primary and most characteristic data type. Lisp programs themselves can be characterized and represented as lists, and this lends Lisp its most distinctive feature: its heavy use of parenthesization. The ability of Lisp to represent itself in itself\empause Lisp lists are Lisp programs are Lisp lists\empause is known as \vocab{homoiconicity}, and this lends Lisp much of its power and extensibility.

This focus on lists is unlike the \lambdacalc{}, which features functions as its sole data type, and even in its extensions remains solidly anchored by its focus on the function. McCarthy draws on the \lambdacalc solely to provide a notation for ``functional forms'' as opposed to functions\empause basically, to indicate which positional argument should be bound to which variable name in a function's definition. In introducing Lisp, he in fact states that the ``$\lambda$-notation is inadequate for naming functions defined recursively'' and introduces an alternate notation \citep{McCarthy:Recursive:1960}. Many languages today get by using the lambda term $Y$ that we introduced earlier for this purpose; the impact of the \lambdacalc on Lisp was superficial, and this is in good part why one might want to exclude Lisp from a list of functional languages.

Much of the spirit of functional languages, however, first appeared in Lisp: functions as ``first-class citizens'' and the use of recursive functions as opposed to step-variable--based loops, as well as an elegant, remarkably simple definition characterize both Lisp and the modern functional languages. As far as elegance goes, it is possible to write a Lisp interpreter in not very many lines of Lisp.

Lisp flourished as artificial intelligence flourished, and it weathered the cold \abbrev{AI} winter, perhaps even better than \abbrev{AI} did itself. It was readily implemented by many groups and extended in many different directions, so Lisp soon became more a family of languages than a single language. From the 1960s on, there were two major Lisps (Interlisp and MacLisp) and many other significant Lisps. Today, the two primary Lisps are Common Lisp, the result of a standardization effort in the 1980s, and Scheme, which in the mid-1970s sprang out of ongoing research in programming language theory and so was inspired more immediately by the \lambdacalc{}.

\subsection{Iswim}
Iswim (for ``if you see what I mean'') is a family of programming languages developed in the mid-1960s by Peter Landin. It is the first language that really looks like modern functional languages. In stark contrast to Lisp, it is not all about lists, it uses infix notation, and it is thoroughly based on the \lambdacalc{}. It also features \code{let} and \code{where} clauses for creating definitions local to a given scope. This is one of the most immediately visually distinctive elements of modern functional languages. Iswim also allowed the use of indentation (significant whitespace) for scoping alongside the more common punctuation-based delimiters.

\subsection{APL and FP}
APL (``a programming language''), developed in the early 1960s by Kenneth Iverson, was never intended to be a functional programming language, but rather an array programming language. Thus, it provided built-in support for operating on arrays in terms of themselves rather than in terms of their elements, as well as ways of composing these array operations. It is also notable for its concision: it was intended to be programmed in using a specialized alphabet. This, coupled with its approach to handling arrays, led to very compact programs.

It appears to have influenced John Backus in his development of FP. FP itself never saw much, if any, use. It was advocated in Backus' 1978 Turing award lecture in which he warned of the ``von Neumann bottleneck'' that ultimately constrains imperative programming languages to ``word-at-a-time programming.'' FP intended to do for functional programming what structured programming did for imperative programming with its standard control flow constructs by providing a few higher-order functions (``functional forms'') that he considered essential and sufficient for whatever one might want to do.

FP is most notable in the history of functional languages for the credibility it lent to the field\empause Backus received the Turing award in good part because of his fundamental role in the development of Fortran\empause and the interest it generated in functional programming. While the development of modern functional programming languages took a different road than that defined by FP, FP's emphasis on algebraic reasoning and programming using higher-order functions is very much of the same spirit.