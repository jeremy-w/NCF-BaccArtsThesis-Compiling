\subsection{Eager Languages}
The most influential eager languages have fallen under the umbrella of the ML family. ML originally began as the metalanguage (hence the name) for the LCF theorem prover project under way at the University of Edinburgh in the early 1970s. It bears a resemblance to Landin's proposal for Iswim. It is a modern functional language, and as such supports the features discussed earlier. Its strong emphasis on type inference was groundbreaking. Type inference was made possible by Milner's rediscovery of a type system earlier described by Damas and Hindley that walked the fine line between a too powerful type system in which type inference is infeasible and an overly restrictive type system.

In the late 1980s, ML was standardized under the name Standard ML. Standard ML is unusual among programming languages in that the entire language has a formal definition, first published in 1990. Standard ML's support for modules (called structures in Standard ML) is unusually extensive and complex; module signatures (interfaces) can be specified separate from the modules themselves, and it is possible to define functions over modules (such functions are known in ML as functors). A revised edition of the definition was published in 1997. Along with some slight changes to the language, the revision introduced the Standard Basis Library in order to specify a common set of functionality that all conforming Standard ML implementations should provide.

ML's background as a metalanguage for a theorem prover is reflected in its continuing use in programming language research and theorem proving. This research is greatly aided by the published standard: extensions of the language have a solid basis on which to build. But SML was not the only outgrowth of ML.

The Caml languages are another branch of the ML family. This branch has arguably eclipsed Standard ML, particularly in the number of non-research uses to which its languages have been put. Caml was originally an acronym for ``Categorical Abstract Machine Language''; the name has been retained, though the abstract machine has long been abandoned in its implementation. The language began development in 1987 for use in projects of the \foreign{Formel} project at \abbrev{INRIA}; the primary outgrowth of this has been the Coq proof assistant. Because the language was meant for internal use, it was not synchronized with Standard ML, since adhering to a standard would make it difficult to adapt the language as needed to suit the problems faced in the group's work.

The start of the 1990s saw the reimplementation of the Caml language. This version of Caml was called Caml Light and featured a bytecode compiler. The interpreter for this bytecode was written in C so as to be easily portable. A bytecode-compiled program can run without changes on any platform to which the interpeter has been ported. Caml Light was promoted as a language for education.

In 1996, Objective Caml made its debut. Objective Caml adds support for object-oriented programming to Caml Light, strong module support, an extensive standard library, and compilation to native code in addition to continuing support for bytecode compilation. In the mid-2000s, Objective Caml became the inspiration for Microsoft's F\# programming language meant to be used with their .NET framework.

The Caml family of languages provides a marked contrast to the Standard ML family. While Standard ML was published as a formal document with clear roots in programming language research, the development of the Caml languages is driven by their continued use for day-to-day programming to support other interests. Standard ML is a single language with many independent implementations. The Caml family, on the other hand, is defined by its provided compiler: whatever the compiler will accept is what the language is at any given time. Thus, a Caml language is defined more by its \vocab{reference implementation} than by any formal document. Objective Caml is not just a language, but a compiler and a host of other tools (such as a preprocessor, profiler and debugger, and tools for performing lexing and parsing) that come together to make up the current version of Objective Caml.