\myChapter{Conclusion}\label{imperative:conclusion}
Imperative languages developed to replace assembly languages for general programming purposes. They have dominated the programming language landscape, and their long history and wide use have made them the target of much research. They provide the conventional backdrop against which other programming language families, such as the functional languages discussed next, play their part. Unconventional ideas are often explained in terms of concepts familiar from the imperative paradigm. Alternative paradigms are judged in light of the successes and failures of the imperative. Thus, in addition to technical background, this part serves to communicate something of a common cultural background, as well.
\begin{itemize}
\item In \partandnameref{Chapter}{imperative:defining}, we quickly surveyed the development of the imperative programming paradigm through the growth of the imperative language family, focusing on \Fortran, \Algol, C, and Java as examples of goto-based, procedural, structured, and object-oriented programming. We concluded by giving several drawbacks of the imperative paradigm.

\item In \partandnameref{Chapter}{imperative:compiling}, we introduced common issues encountered in developing a compiler for imperative programming languages, in particular:
\begin{itemize}
\item scope
\item data storage
\item array layout.
\end{itemize}

\item In \partandnameref{Chapter}{imperative:optimizing}, we described the process of optimization in terms of a variety of analyses and transformations and gave examples of several common optimizations applied to imperative programs.
\end{itemize}

%\section{Bibliographic Notes}\label{imperative:conclusion:notes}
% Is this necessary any more, or do the chapter-ending notes suffice?