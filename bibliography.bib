
%% Created for jeremy at 2008-05-02 08:12:40 -0400 


%% Saved with string encoding Western (ASCII) 



@article{Nilsson:How-to-look:2001,
	Address = {New York, NY, USA},
	Author = {Henrik Nilsson},
	Date-Added = {2008-05-02 04:31:21 -0400},
	Date-Modified = {2008-05-02 04:31:23 -0400},
	Doi = {http://dx.doi.org/10.1017/S095679680100418X},
	Issn = {0956-7968},
	Journal = {J. Funct. Program.},
	Number = {6},
	Pages = {629--671},
	Publisher = {Cambridge University Press},
	Title = {How to look busy while being as lazy as ever: the Implementation of a lazy functional debugger},
	Volume = {11},
	Year = {2001},
	Abstract = {This article describes the implementation of a debugger for lazy functional languages like Haskell. The key idea is to construct a declarative trace which hides the operational details of lazy evaluation. However, to avoid excessive memory consumption, the trace is constructed one piece at a time, as needed during a debugging session, by automatic re-execution of the program being debugged. The article gives a fairly detailed account of both the underlying ideas and of our implementation, and also presents performance figures which demonstrate the feasibility of the approach.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE4uLi8uLi9QYXBlcnMvTmlsc3Nvbi9OaWxzc29uIC0gSG93IHRvIGxvb2sgYnVzeSB3aGlsZSBiZWluZyBhcyBsYXp5ICgyMDAxKS5wZGbSGw8cHVdOUy5kYXRhTxECAgAAAAACAgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOJUtH05pbHNzb24gLSBIb3cgdG8gbG9vIzM4OTUxOS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4lRnEQEj2UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdOaWxzc29uAAAQAAgAAME0fl0AAAARAAgAAMRAgTYAAAABABAAOJUtAC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpOaWxzc29uOk5pbHNzb24gLSBIb3cgdG8gbG9vIzM4OTUxOS5wZGYADgB0ADkATgBpAGwAcwBzAG8AbgAgAC0AIABIAG8AdwAgAHQAbwAgAGwAbwBvAGsAIABiAHUAcwB5ACAAdwBoAGkAbABlACAAYgBlAGkAbgBnACAAYQBzACAAbABhAHoAeQAgACgAMgAwADAAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFVVc2Vycy9qZXJlbXkvUGFwZXJzL05pbHNzb24vTmlsc3NvbiAtIEhvdyB0byBsb29rIGJ1c3kgd2hpbGUgYmVpbmcgYXMgbGF6eSAoMjAwMSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD7AQABCAMOAxADFQMeAykDLQM7A0IDSwNQA1MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADYA==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1017/S095679680100418X}}

@inproceedings{Peyton-Jones:C--:1999,
	Address = {London, UK},
	Author = {Peyton Jones, Simon L. and Norman Ramsey and Fermin Reig},
	Booktitle = {PPDP '99: Proceedings of the International Conference PPDP'99 on Principles and Practice of Declarative Programming},
	Date-Added = {2008-05-02 04:31:21 -0400},
	Date-Modified = {2008-05-02 05:07:40 -0400},
	Isbn = {3-540-66540-4},
	Pages = {1--28},
	Publisher = {Springer-Verlag},
	Title = {C--: A Portable Assembly Language that Supports Garbage Collection},
	Url = {http://www.cminusminus.org/},
	Year = {1999},
	Abstract = {For a compiler writer, generating good machine code for a variety of platforms is hard work. One might try to reuse a retargetable code generator, but code generators are complex and difficult to use, and they limit one's choice of implementation language. One might try to use C as a portable assembly language, but C limits the compiler writer's flexibility and the performance of the resulting code. The wide use of C, despite these drawbacks, argues for a portable assembly language. C-- is a new language designed expressly for this purpose. The use of a portable assembly language introduces new problems in the support of such high-level run-time services as garbage collection, exception handling, concurrency, profiling, and debugging. We address these problems by combining the C-- language with a C-- run-time interface. The combination is designed to allow the compiler writer a choice of source language semantics and implementation techniques, while still providing good performance.},
	Annote = {Cmm, Cminusminus},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFguLi8uLi9QYXBlcnMvSm9uZXMvSm9uZXMtUmFtc2V5LVJlaWcgLSBDLS06IEEgUG9ydGFibGUgQXNzZW1ibHkgTGFuZ3VhZ2UgdGhhdCAoMTk5OSkucGRm0hsPHB1XTlMuZGF0YU8RAiAAAAAAAiAAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADgoBB9Kb25lcy1SYW1zZXktUmVpZyAtICMzODk1MjcucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOJUnxEBJhQAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAFSm9uZXMAABAACAAAwTR+XQAAABEACAAAxECBxQAAAAEAEAA4KAQALZE/AANHrAAAa9gAAgA+T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkpvbmVzOkpvbmVzLVJhbXNleS1SZWlnIC0gIzM4OTUyNy5wZGYADgCMAEUASgBvAG4AZQBzAC0AUgBhAG0AcwBlAHkALQBSAGUAaQBnACAALQAgAEMALQAtAC8AIABBACAAUABvAHIAdABhAGIAbABlACAAQQBzAHMAZQBtAGIAbAB5ACAATABhAG4AZwB1AGEAZwBlACAAdABoAGEAdAAgACgAMQA5ADkAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF9Vc2Vycy9qZXJlbXkvUGFwZXJzL0pvbmVzL0pvbmVzLVJhbXNleS1SZWlnIC0gQy0tOiBBIFBvcnRhYmxlIEFzc2VtYmx5IExhbmd1YWdlIHRoYXQgKDE5OTkpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBBQEKARIDNgM4Az0DRgNRA1UDYwNqA3MDeAN7AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA4g=},
	Bdsk-Url-1 = {http://www.cminusminus.org/}}

@inproceedings{Peyton-Jones:Measuring:1993,
	Author = {Simon L. {Peyton Jones} and W. Partain},
	Booktitle = {Glasgow Workshop on Functional Programming 1993},
	Date-Added = {2008-05-02 03:29:21 -0400},
	Date-Modified = {2008-05-02 03:29:23 -0400},
	Editor = {J. T. O'Donnell},
	Month = {5--7 July},
	Publisher = {Springer-Verlag},
	Title = {Measuring the effectiveness of a simple strictness analyser},
	Url = {citeseer.ist.psu.edu/jones93measuring.html},
	Year = {1993},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHcuLi8uLi9QYXBlcnMvUGV5dG9uIEpvbmVzL1BleXRvbiBKb25lcy1QYXJ0YWluIC0gTWVhc3VyaW5nIHRoZSBlZmZlY3RpdmVuZXNzIG9mIGEgc2ltcGxlIHN0cmljdG5lc3MgYW5hbHlzZXIgKDE5OTMpLnBkZtIbDxwdV05TLmRhdGFPEQJ8AAAAAAJ8AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtkXofUGV5dG9uIEpvbmVzLVBhcnRhaW4jMzg5NDM5LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADiUOcRAOypQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAADFBleXRvbiBKb25lcwAQAAgAAME0fl0AAAARAAgAAMRAc2oAAAABABAALZF6AC2RPwADR6wAAGvYAAIARU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpQZXl0b24gSm9uZXM6UGV5dG9uIEpvbmVzLVBhcnRhaW4jMzg5NDM5LnBkZgAADgC8AF0AUABlAHkAdABvAG4AIABKAG8AbgBlAHMALQBQAGEAcgB0AGEAaQBuACAALQAgAE0AZQBhAHMAdQByAGkAbgBnACAAdABoAGUAIABlAGYAZgBlAGMAdABpAHYAZQBuAGUAcwBzACAAbwBmACAAYQAgAHMAaQBtAHAAbABlACAAcwB0AHIAaQBjAHQAbgBlAHMAcwAgAGEAbgBhAGwAeQBzAGUAcgAgACgAMQA5ADkAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAH5Vc2Vycy9qZXJlbXkvUGFwZXJzL1BleXRvbiBKb25lcy9QZXl0b24gSm9uZXMtUGFydGFpbiAtIE1lYXN1cmluZyB0aGUgZWZmZWN0aXZlbmVzcyBvZiBhIHNpbXBsZSBzdHJpY3RuZXNzIGFuYWx5c2VyICgxOTkzKS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBJAEpATEDsQOzA7gDwQPMA9AD3gPlA+4D8wP2AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAABAM=},
	Bdsk-Url-1 = {citeseer.ist.psu.edu/jones93measuring.html}}

@article{Girard:The-System:1986,
	Author = {Jean-Yves Girard},
	Bibsource = {DBLP, http://dblp.uni-trier.de},
	Date-Added = {2008-05-02 01:29:40 -0400},
	Date-Modified = {2008-05-02 01:29:41 -0400},
	Journal = {Theor. Comput. Sci.},
	Number = {2},
	Pages = {159-192},
	Title = {The System F of Variable Types, Fifteen Years Later},
	Volume = {45},
	Year = {1986}}

@inproceedings{Swierstra:Beauty:2007,
	Address = {New York, NY, USA},
	Author = {Wouter Swierstra and Thorsten Altenkirch},
	Booktitle = {Haskell '07: Proceedings of the ACM SIGPLAN workshop on Haskell workshop},
	Date-Added = {2008-05-01 22:06:01 -0400},
	Date-Modified = {2008-05-01 22:06:20 -0400},
	Doi = {http://doi.acm.org/10.1145/1291201.1291206},
	Isbn = {978-1-59593-674-5},
	Location = {Freiburg, Germany},
	Pages = {25--36},
	Publisher = {ACM},
	Title = {Beauty in the beast},
	Year = {2007},
	Abstract = {It can be very difficult to debug impure code, let alone prove its correctness. To address these problems, we provide a functional specification of three central components of Peyton Jones's awkward squad: teletype IO, mutable state, and concurrency. By constructing an internal model of such concepts within our programming language, we can test, debug, and reason about programs that perform IO as if they were pure. In particular, we demonstrate how our specifications may be used in tandem with QuickCheck to automatically test complex pointer algorithms and concurrent programs.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEwuLi8uLi9QYXBlcnMvU3dpZXJzdHJhL1N3aWVyc3RyYS1BbHRlbmtpcmNoIC0gQmVhdXR5IGluIHRoZSBiZWFzdCAoMjAwNykucGRm0hsPHB1XTlMuZGF0YU8RAfwAAAAAAfwAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADiPRx9Td2llcnN0cmEtQWx0ZW5raXJjaCMzODhGNDQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOI9ExD/vbFBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAJU3dpZXJzdHJhAAAQAAgAAME0fl0AAAARAAgAAMRAJ6wAAAABABAAOI9HAC2RPwADR6wAAGvYAAIAQk9kaW46VXNlcnM6amVyZW15OlBhcGVyczpTd2llcnN0cmE6U3dpZXJzdHJhLUFsdGVua2lyY2gjMzg4RjQ0LnBkZgAOAGwANQBTAHcAaQBlAHIAcwB0AHIAYQAtAEEAbAB0AGUAbgBrAGkAcgBjAGgAIAAtACAAQgBlAGEAdQB0AHkAIABpAG4AIAB0AGgAZQAgAGIAZQBhAHMAdAAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFNVc2Vycy9qZXJlbXkvUGFwZXJzL1N3aWVyc3RyYS9Td2llcnN0cmEtQWx0ZW5raXJjaCAtIEJlYXV0eSBpbiB0aGUgYmVhc3QgKDIwMDcpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA+QD+AQYDBgMIAw0DFgMhAyUDMwM6A0MDSANLAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA1g=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1291201.1291206}}

@article{Peyton-Jones:Secrets:2002,
	Address = {New York, NY, USA},
	Author = {Peyton Jones, Simon and Simon Marlow},
	Date-Added = {2008-05-01 22:05:17 -0400},
	Date-Modified = {2008-05-02 02:59:57 -0400},
	Doi = {http://dx.doi.org/10.1017/S0956796802004331},
	Issn = {0956-7968},
	Journal = {J. Funct. Program.},
	Keywords = {optimization},
	Number = {5},
	Pages = {393--434},
	Publisher = {Cambridge University Press},
	Title = {Secrets of the Glasgow Haskell Compiler inliner},
	Volume = {12},
	Year = {2002},
	Abstract = {Higher-order languages such as Haskell encourage the programmer to build abstractions by composing functions. A good compiler must inline many of these calls to recover an efficiently executable program. In principle, inlining is dead simple: just replace the call of a function by an instance of its body. But any compiler-writer will tell you that inlining is a black art, full of delicate compromises that work together to give good performance without unnecessary code bloat. The purpose of this paper is, therefore, to articulate the key lessons we learned from a full-scale ``production'' inliner, the one used in the Glasgow Haskell compiler. We focus mainly on the algorithmic aspects, but we also provide some indicative measurements to substantiate the importance of various aspects of the inliner.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFwuLi8uLi9QYXBlcnMvSm9uZXMvSm9uZXMtTWFybG93IC0gU2VjcmV0cyBvZiB0aGUgR2xhc2dvdyBIYXNrZWxsIENvbXBpbGVyIGlubGluZXIgKDIwMDIpLnBkZtIbDxwdV05TLmRhdGFPEQIsAAAAAAIsAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4KAQfSm9uZXMtTWFybG93IC0gU2VjcmUjMzg4RjEyLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADiPEsQ/7bVQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABUpvbmVzAAAQAAgAAME0fl0AAAARAAgAAMRAJfUAAAABABAAOCgEAC2RPwADR6wAAGvYAAIAPk9kaW46VXNlcnM6amVyZW15OlBhcGVyczpKb25lczpKb25lcy1NYXJsb3cgLSBTZWNyZSMzODhGMTIucGRmAA4AlABJAEoAbwBuAGUAcwAtAE0AYQByAGwAbwB3ACAALQAgAFMAZQBjAHIAZQB0AHMAIABvAGYAIAB0AGgAZQAgAEcAbABhAHMAZwBvAHcAIABIAGEAcwBrAGUAbABsACAAQwBvAG0AcABpAGwAZQByACAAaQBuAGwAaQBuAGUAcgAgACgAMgAwADAAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGNVc2Vycy9qZXJlbXkvUGFwZXJzL0pvbmVzL0pvbmVzLU1hcmxvdyAtIFNlY3JldHMgb2YgdGhlIEdsYXNnb3cgSGFza2VsbCBDb21waWxlciBpbmxpbmVyICgyMDAyKS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQkBDgEWA0YDSANNA1YDYQNlA3MDegODA4gDiwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOY},
	Bdsk-Url-1 = {http://dx.doi.org/10.1017/S0956796802004331}}

@article{Johann:The-Impact:2006,
	Address = {Amsterdam, The Netherlands, The Netherlands},
	Author = {Patricia Johann and Janis Voigtl\"{a}nder},
	Date-Added = {2008-05-01 22:05:17 -0400},
	Date-Modified = {2008-05-01 22:05:18 -0400},
	Issn = {0169-2968},
	Journal = {Fundam. Inf.},
	Number = {1-2},
	Pages = {63--102},
	Publisher = {IOS Press},
	Title = {The Impact of seq on Free Theorems-Based Program Transformations},
	Volume = {69},
	Year = {2006},
	Abstract = {Parametric polymorphism constrains the behavior of pure functional programs in a way that allows the derivation of interesting theorems about them solely from their types, i.e., virtually for free. Unfortunately, standard parametricity results -- including so-called free theorems -- fail for nonstrict languages supporting a polymorphic strict evaluation primitive such as Haskell's seq. A folk theorem maintains that such results hold for a subset of Haskell corresponding to a Girard-Reynolds calculus with fixpoints and algebraic datatypes even when seq is present provided the relations which appear in their derivations are required to be bottom-reflecting and admissible. In this paper we show that this folklore is incorrect, but that parametricity results can be recovered in the presence of seq by restricting attention to left-closed, total, and admissible relations instead. The key novelty of our approach is the asymmetry introduced by left-closedness, which leads to "inequational" versions of standard parametricity results together with preconditions guaranteeing their validity even when seq is present. We use these results to derive criteria ensuring that both equational and inequational versions of short cut fusion and related program transformations based on free theorems hold in the presence of seq.}}

@inproceedings{Peyton-Jones:Playing:2001,
	Author = {Peyton Jones, Simon and Andrew Tolmach and Tony Hoare},
	Booktitle = {Haskell '01: Proceedings of the ACM SIGPLAN workshop on Haskell},
	Date-Added = {2008-05-01 22:05:17 -0400},
	Date-Modified = {2008-05-02 02:57:55 -0400},
	Keywords = {optimization},
	Title = {Playing by the rules: {R}ewriting as a practical optimisation technique in {GHC}},
	Url = {http://haskell.org/haskell-workshop/2001/},
	Year = {2001},
	Abstract = {We describe a facility for improving optimization of Haskell programs using rewrite rules. Library authors can use rules to express domain-specific optimizations that the compiler cannot discover for itself. The compiler can also generate rules internally to propagate information obtained from automated analyses. The rewrite mechanism is fully implemented in the released Glasgow Haskell Compiler. Our system is very simple, but can be effective in optimizing real programs. We describe two practical applications involving short-cut deforestation, for lists and for rose trees, and document substantial performance improvements on a range of programs.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEH0uLi8uLi9QYXBlcnMvUGV5dG9uIEpvbmVzL1BleXRvbiBKb25lcy1Ub2xtYWNoLUhvYXJlIC0gUGxheWluZyBieSB0aGUgcnVsZXM6IFJld3JpdGluZyBhcyBhIHByYWN0aWNhbCBvcHRpbWlzYXRpb24gKDIwMDEpLnBkZtIbDxwdV05TLmRhdGFPEQKOAAAAAAKOAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtkXofUGV5dG9uIEpvbmVzLVRvbG1hY2gjMzg4RjA5LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADiPCcQ/7OZQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAADFBleXRvbiBKb25lcwAQAAgAAME0fl0AAAARAAgAAMRAJSYAAAABABAALZF6AC2RPwADR6wAAGvYAAIARU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpQZXl0b24gSm9uZXM6UGV5dG9uIEpvbmVzLVRvbG1hY2gjMzg4RjA5LnBkZgAADgDIAGMAUABlAHkAdABvAG4AIABKAG8AbgBlAHMALQBUAG8AbABtAGEAYwBoAC0ASABvAGEAcgBlACAALQAgAFAAbABhAHkAaQBuAGcAIABiAHkAIAB0AGgAZQAgAHIAdQBsAGUAcwAvACAAUgBlAHcAcgBpAHQAaQBuAGcAIABhAHMAIABhACAAcAByAGEAYwB0AGkAYwBhAGwAIABvAHAAdABpAG0AaQBzAGEAdABpAG8AbgAgACgAMgAwADAAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAIRVc2Vycy9qZXJlbXkvUGFwZXJzL1BleXRvbiBKb25lcy9QZXl0b24gSm9uZXMtVG9sbWFjaC1Ib2FyZSAtIFBsYXlpbmcgYnkgdGhlIHJ1bGVzOiBSZXdyaXRpbmcgYXMgYSBwcmFjdGljYWwgb3B0aW1pc2F0aW9uICgyMDAxKS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBKgEvATcDyQPLA9AD2QPkA+gD9gP9BAYECwQOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAABBs=},
	Bdsk-Url-1 = {http://haskell.org/haskell-workshop/2001/}}

@inproceedings{Sulzmann:System:2007,
	Address = {New York, NY, USA},
	Author = {Martin Sulzmann and Manuel M. T. Chakravarty and Simon Peyton Jones and Kevin Donnelly},
	Booktitle = {TLDI '07: Proceedings of the 2007 ACM SIGPLAN international workshop on Types in languages design and implementation},
	Date-Added = {2008-05-01 20:51:31 -0400},
	Date-Modified = {2008-05-01 20:52:08 -0400},
	Doi = {http://doi.acm.org/10.1145/1190315.1190324},
	Isbn = {1-59593-393-X},
	Location = {Nice, Nice, France},
	Pages = {53--66},
	Publisher = {ACM},
	Title = {System {F} with type equality coercions},
	Year = {2007},
	Abstract = {We introduce System FC, which extends System F with support for non-syntactic type equality. There are two main extensions: (i) explicit witnesses for type equalities, and (ii) open, non-parametric type functions, given meaning by top-level equality axioms. Unlike System F, FC is expressive enough to serve as a target for several different source-language features, including Haskell's newtype, generalised algebraic data types, associated types, functional dependencies, and perhaps more besides.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGMuLi8uLi9QYXBlcnMvU3Vsem1hbm4vU3Vsem1hbm4tQ2hha3JhdmFydHktSm9uZXMgLSBTeXN0ZW0gRiB3aXRoIHR5cGUgZXF1YWxpdHkgY29lcmNpb25zICgyMDA3KS5wZGbSGw8cHVdOUy5kYXRhTxECQAAAAAACQAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOI4aH1N1bHptYW5uLUNoYWtyYXZhcnR5IzM4OEUxNC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4jhTEP94VUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAhTdWx6bWFubgAQAAgAAME0fl0AAAARAAgAAMRAFlUAAAABABAAOI4aAC2RPwADR6wAAGvYAAIAQU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpTdWx6bWFubjpTdWx6bWFubi1DaGFrcmF2YXJ0eSMzODhFMTQucGRmAAAOAJwATQBTAHUAbAB6AG0AYQBuAG4ALQBDAGgAYQBrAHIAYQB2AGEAcgB0AHkALQBKAG8AbgBlAHMAIAAtACAAUwB5AHMAdABlAG0AIABGACAAdwBpAHQAaAAgAHQAeQBwAGUAIABlAHEAdQBhAGwAaQB0AHkAIABjAG8AZQByAGMAaQBvAG4AcwAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGpVc2Vycy9qZXJlbXkvUGFwZXJzL1N1bHptYW5uL1N1bHptYW5uLUNoYWtyYXZhcnR5LUpvbmVzIC0gU3lzdGVtIEYgd2l0aCB0eXBlIGVxdWFsaXR5IGNvZXJjaW9ucyAoMjAwNykucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARABFQEdA2EDYwNoA3EDfAOAA44DlQOeA6MDpgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOz},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1190315.1190324}}

@inproceedings{Peyton-Jones:Henk::1997,
	Author = {Peyton Jones, Simon L. and Erik Meijer},
	Booktitle = {Proceedings of the Types in Compilation Workshop},
	Date-Added = {2008-05-01 17:52:03 -0400},
	Date-Modified = {2008-05-01 17:52:05 -0400},
	Month = {June},
	Title = {Henk: a typed intermediate language},
	Url = {http://research.microsoft.com/Users/simonpj/Papers/henk.ps.gz},
	Year = {1997},
	Abstract = {There is growing interest in the use of richly-typed intermediate languages in sophisticated compilers for higher-order, typed source languages. These intermediate languages are typically stratified, involving terms, types, and kinds. As the sophistication of the type system increases, these three levels begin to look more and more similar, so an attractive approach is to use a single syntax, and a single data type in the compiler, to represent all three.

The theory of so-called \textit{pure type systems} makes precisely such an identification. This paper describes \textsf{Henk}, a new typed intermediate language based closely on a particular pure type system, the \textit{lambda cube.} On the way we give a tutorial introduction to the lambda cube.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEF4uLi8uLi9QYXBlcnMvUGV5dG9uIEpvbmVzL1BleXRvbiBKb25lcy1NZWlqZXIgLSBIZW5rOiBhIHR5cGVkIGludGVybWVkaWF0ZSBsYW5ndWFnZSAoMTk5NykucGRm0hsPHB1XTlMuZGF0YU8RAjIAAAAAAjIAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2Reh9QZXl0b24gSm9uZXMtTWVpamVyICMyOUY4NDAucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKfhAAAAAAAAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAMUGV5dG9uIEpvbmVzABAACAAAwTR+XQAAABEACAAAAAAAAAAAAAEAEAAtkXoALZE/AANHrAAAa9gAAgBFT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlBleXRvbiBKb25lczpQZXl0b24gSm9uZXMtTWVpamVyICMyOUY4NDAucGRmAAAOAIoARABQAGUAeQB0AG8AbgAgAEoAbwBuAGUAcwAtAE0AZQBpAGoAZQByACAALQAgAEgAZQBuAGsALwAgAGEAIAB0AHkAcABlAGQAIABpAG4AdABlAHIAbQBlAGQAaQBhAHQAZQAgAGwAYQBuAGcAdQBhAGcAZQAgACgAMQA5ADkANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGVVc2Vycy9qZXJlbXkvUGFwZXJzL1BleXRvbiBKb25lcy9QZXl0b24gSm9uZXMtTWVpamVyIC0gSGVuazogYSB0eXBlZCBpbnRlcm1lZGlhdGUgbGFuZ3VhZ2UgKDE5OTcpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBCwEQARgDTgNQA1UDXgNpA20DewOCA4sDkAOTAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA6A=},
	Bdsk-Url-1 = {http://research.microsoft.com/Users/simonpj/Papers/henk.ps.gz}}

@inproceedings{Bussche:A-crash:2007,
	Address = {New York, NY, USA},
	Author = {Jan van den Bussche and Dirk van Gucht and Stijn Vansummeren},
	Booktitle = {PODS '07: Proceedings of the twenty-sixth ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems},
	Date-Added = {2008-05-01 17:52:03 -0400},
	Date-Modified = {2008-05-01 17:52:05 -0400},
	Doi = {http://doi.acm.org/10.1145/1265530.1265551},
	Isbn = {978-1-59593-685-1},
	Location = {Beijing, China},
	Pages = {143--154},
	Publisher = {ACM},
	Title = {A crash course on database queries},
	Year = {2007},
	Abstract = {Complex database queries, like programs in general, can "crash", i.e., can raise runtime errors. We want to avoid crashes without losing expressive power, or we want to correctly predict the absence of crashes. We show how concepts and techniques from programming language theory, notably type systems and reflection, can be adaptedto this end. Of course, the specific nature of database queries (as opposed to general programs), also requires some new methods, andraises new questions.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEF4uLi8uLi9QYXBlcnMvQnVzc2NoZS9CdXNzY2hlLUd1Y2h0LVZhbnN1bW1lcmVuIC0gQSBjcmFzaCBjb3Vyc2Ugb24gZGF0YWJhc2UgcXVlcmllcyAoMjAwNykucGRm0hsPHB1XTlMuZGF0YU8RAjIAAAAAAjIAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADiLNR9CdXNzY2hlLUd1Y2h0LVZhbnN1bSMzODhCMDEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOIsBxD+wpVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAHQnVzc2NoZQAAEAAIAADBNH5dAAAAEQAIAADEP+jlAAAAAQAQADiLNQAtkT8AA0esAABr2AACAEBPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QnVzc2NoZTpCdXNzY2hlLUd1Y2h0LVZhbnN1bSMzODhCMDEucGRmAA4AlABJAEIAdQBzAHMAYwBoAGUALQBHAHUAYwBoAHQALQBWAGEAbgBzAHUAbQBtAGUAcgBlAG4AIAAtACAAQQAgAGMAcgBhAHMAaAAgAGMAbwB1AHIAcwBlACAAbwBuACAAZABhAHQAYQBiAGEAcwBlACAAcQB1AGUAcgBpAGUAcwAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGVVc2Vycy9qZXJlbXkvUGFwZXJzL0J1c3NjaGUvQnVzc2NoZS1HdWNodC1WYW5zdW1tZXJlbiAtIEEgY3Jhc2ggY291cnNlIG9uIGRhdGFiYXNlIHF1ZXJpZXMgKDIwMDcpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBCwEQARgDTgNQA1UDXgNpA20DewOCA4sDkAOTAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA6A=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1265530.1265551}}

@article{McBride:Faking:2002,
	Address = {New York, NY, USA},
	Author = {Conor McBride},
	Date-Added = {2008-05-01 17:52:03 -0400},
	Date-Modified = {2008-05-01 17:52:05 -0400},
	Doi = {http://dx.doi.org/10.1017/S0956796802004355},
	Issn = {0956-7968},
	Journal = {J. Funct. Program.},
	Number = {5},
	Pages = {375--392},
	Publisher = {Cambridge University Press},
	Title = {Faking it: {S}imulating dependent types in {H}askell},
	Volume = {12},
	Year = {2002},
	Abstract = {Dependent types reflect the fact that validity of data is often a \textit{relative} notion by allowing prior data to affect the types of subsequent data. Not only does this make for a \textit{precise} type system, but also a highly \textit{generic} one: both the type and the program for each instance of a family of operations can be computed from the data which \textit{codes} for that instance. Recent experimental extensions to the Haskell \textit{type class} mechanism give us strong tools to relativize types to other \textit{types.} We may simulate some aspects of dependent typing by making counterfeit type-level copies of data, with type constructors simulating data constructors and type classes simulating datatypes. This paper gives examples of the technique and discusses its potential.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFouLi8uLi9QYXBlcnMvTWNCcmlkZS9NY0JyaWRlIC0gRmFraW5nIGl0OiBTaW11bGF0aW5nIGRlcGVuZGVudCB0eXBlcyBpbiBIYXNrZWxsICgyMDAyKS5wZGbSGw8cHVdOUy5kYXRhTxECJgAAAAACJgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAMfWOH01jQnJpZGUgLSBGYWtpbmcgaXQvIzM4OEIxNC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ixTEP7GuUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdNY0JyaWRlAAAQAAgAAME0fl0AAAARAAgAAMQ/6e4AAAABABAAMfWOAC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpNY0JyaWRlOk1jQnJpZGUgLSBGYWtpbmcgaXQvIzM4OEIxNC5wZGYADgCMAEUATQBjAEIAcgBpAGQAZQAgAC0AIABGAGEAawBpAG4AZwAgAGkAdAAvACAAUwBpAG0AdQBsAGEAdABpAG4AZwAgAGQAZQBwAGUAbgBkAGUAbgB0ACAAdAB5AHAAZQBzACAAaQBuACAASABhAHMAawBlAGwAbAAgACgAMgAwADAAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGFVc2Vycy9qZXJlbXkvUGFwZXJzL01jQnJpZGUvTWNCcmlkZSAtIEZha2luZyBpdDogU2ltdWxhdGluZyBkZXBlbmRlbnQgdHlwZXMgaW4gSGFza2VsbCAoMjAwMikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEHAQwBFAM+A0ADRQNOA1kDXQNrA3IDewOAA4MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkA==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1017/S0956796802004355}}

@article{Barthe:CPS-Translations:1999,
	Address = {Hingham, MA, USA},
	Author = {Gilles Barthe and John Hatcliff and S{\o}renson, Morten Heine B.},
	Date-Added = {2008-05-01 17:52:03 -0400},
	Date-Modified = {2008-05-01 17:54:02 -0400},
	Doi = {http://dx.doi.org/10.1023/A:1010000206149},
	Issn = {1388-3690},
	Journal = {Higher Order Symbol. Comput.},
	Number = {2},
	Pages = {125--170},
	Publisher = {Kluwer Academic Publishers},
	Title = {CPS Translations and Applications: The Cube and Beyond},
	Volume = {12},
	Year = {1999},
	Abstract = {Continuation passing style (CPS) translations of typed $\lambda$-calculi have numerous applications. However, the range of these applications has been confined by the fact that CPS translations are known for non-dependent type systems only, thus excluding well-known systems like the calculus of constructions (CC) and the logical frameworks (LF). This paper presents techniques for CPS translating systems with dependent types, with an emphasis on pure type-theoretical applications.

In the first part of the paper we review several lines of work in which the need for CPS translations of dependent type systems has arisen, and discuss the difficulties involved with CPS translating such systems. One way of overcoming these difficulties is to work with so-called domain-free type systems. Thus, instead of Barendregt's $\lambda$-cube we shall consider the domain-free $\lambda$-cube, and instead of traditional pure type systems, we shall consider domain-free pure type systems.

We therefore begin the second part by reviewing the domain-free $\lambda$-cube, which includes domain-free versions of CC and LF, and then present CPS translations for all the systems of the domain-free $\lambda$-cube. We also introduce Direct Style (DS) (i.e., inverse CPS) translations for all the systems of the domain-free $\lambda$-cube; such DS translations, which have been used in a number of applications, were previously formulated for untyped and simply-typed languages only.

In the third part we review domain-free pure type systems and generalize the CPS translations of the domain-free $\lambda$-cube to a large class of domain-free pure type systems which includes most of the systems that appear in the literature, including those of the domain-free $\lambda$-cube. Many translations that appear in the literature arise as special cases of ours.

In the fourth part of the paper we present two approaches to CPS translations of traditional pure type systems. The first, indirect, technique lifts the CPS translation of domain-free pure type systems to the analogous class of traditional pure type systems by using results that relate derivations in domain-free and traditional pure type systems. The second, direct, approach translates derivations, requiring a certain order on derivations to be well-founded. Both techniques yield translations for most of the systems that appear in the literature, including those of Barendregt's $\lambda$-cube.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFvEHAALgAuAC8ALgAuAC8AUABhAHAAZQByAHMALwBCAGEAcgB0AGgAZQAvAEIAYQByAHQAaABlAC0ASABhAHQAYwBsAGkAZgBmAC0AUwD4AHIAZQBuAHMAbwBuACAALQAgAEMAUABTACAAVAByAGEAbgBzAGwAYQB0AGkAbwBuAHMAIABhAG4AZAAgAEEAcABwAGwAaQBjAGEAdABpAG8AbgBzADoAIABUAGgAZQAgAEMAdQBiAGUAIABhAG4AZAAgAEIAZQB5AG8AbgBkACAAKAAxADkAOQA5ACkALgBwAGQAZtIbDxwdV05TLmRhdGFPEQJoAAAAAAJoAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4izQfQmFydGhlLUhhdGNsaWZmLVO/cmUjMzg4QjE4LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADiLGMQ/sb9QREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABkJhcnRoZQAQAAgAAME0fl0AAAARAAgAAMQ/6f8AAAABABAAOIs0AC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpCYXJ0aGU6QmFydGhlLUhhdGNsaWZmLVO/cmUjMzg4QjE4LnBkZgAADgC6AFwAQgBhAHIAdABoAGUALQBIAGEAdABjAGwAaQBmAGYALQBTAPgAcgBlAG4AcwBvAG4AIAAtACAAQwBQAFMAIABUAHIAYQBuAHMAbABhAHQAaQBvAG4AcwAgAGEAbgBkACAAQQBwAHAAbABpAGMAYQB0AGkAbwBuAHMALwAgAFQAaABlACAAQwB1AGIAZQAgAGEAbgBkACAAQgBlAHkAbwBuAGQAIAAoADEAOQA5ADkAKQAuAHAAZABmAA8ACgAEAE8AZABpAG4AEgB4VXNlcnMvamVyZW15L1BhcGVycy9CYXJ0aGUvQmFydGhlLUhhdGNsaWZmLVPDuHJlbnNvbiAtIENQUyBUcmFuc2xhdGlvbnMgYW5kIEFwcGxpY2F0aW9uczogVGhlIEN1YmUgYW5kIEJleW9uZCAoMTk5OSkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAY0BkgGaBAYECAQNBBYEIQQlBDMEOgRDBEgESwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAARY},
	Bdsk-Url-1 = {http://dx.doi.org/10.1023/A:1010000206149}}

@article{Edwards:Subtext::2005,
	Address = {New York, NY, USA},
	Author = {Jonathan Edwards},
	Date-Added = {2008-05-01 17:52:03 -0400},
	Date-Modified = {2008-05-01 17:52:05 -0400},
	Doi = {http://doi.acm.org/10.1145/1103845.1094851},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {10},
	Pages = {505--518},
	Publisher = {ACM},
	Title = {Subtext: {U}ncovering the simplicity of programming},
	Volume = {40},
	Year = {2005},
	Abstract = {Representing programs as text strings makes programming harder then it has to be. The source text of a program is far removed from its behavior. Bridging this conceptual gulf is what makes programming so inhumanly difficult -- we are not compilers. \textit{Subtext} is a new medium in which the representation of a program is the same thing as its execution. Like a spreadsheet, a program is visible and alive, constantly executing even as it is edited. Program edits are coherent semantic transformations.

The essence of this new medium is copying. Programs are constructed by copying and executed by \textit{copy flow}: the projection of changes through copies. The simple idea of copying develops into a rich theory of \textit{higher-order continual copying of trees.} Notably absent are symbolic names, the workhorse of textual notation, replaced by immediately-bound explicit relationships. Subtext unifies traditionally distinct programming tools and concepts, and enables some novel ones. \textit{Ancestral structures} are a new primitive data type that combines the features of lists and records, along with unproblematic multiple inheritance. \textit{Adaptive conditionals} use first-class program edits to dynamically adapt behavior.

A prototype implementation shows promise, but calls for much further research. Subtext suggests that we can make programming radically easier, if we are willing to be radical.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFsuLi8uLi9QYXBlcnMvRWR3YXJkcy9FZHdhcmRzIC0gU3VidGV4dDogVW5jb3ZlcmluZyB0aGUgc2ltcGxpY2l0eSBvZiBwcm9ncmFtbWluZyAoMjAwNSkucGRm0hsPHB1XTlMuZGF0YU8RAigAAAAAAigAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC+yVx9FZHdhcmRzIC0gU3VidGV4dC8gVSMzODhCMjgucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOIsoxD+yfFBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAHRWR3YXJkcwAAEAAIAADBNH5dAAAAEQAIAADEP+q8AAAAAQAQAC+yVwAtkT8AA0esAABr2AACAEBPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6RWR3YXJkczpFZHdhcmRzIC0gU3VidGV4dC8gVSMzODhCMjgucGRmAA4AjgBGAEUAZAB3AGEAcgBkAHMAIAAtACAAUwB1AGIAdABlAHgAdAAvACAAVQBuAGMAbwB2AGUAcgBpAG4AZwAgAHQAaABlACAAcwBpAG0AcABsAGkAYwBpAHQAeQAgAG8AZgAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGJVc2Vycy9qZXJlbXkvUGFwZXJzL0Vkd2FyZHMvRWR3YXJkcyAtIFN1YnRleHQ6IFVuY292ZXJpbmcgdGhlIHNpbXBsaWNpdHkgb2YgcHJvZ3JhbW1pbmcgKDIwMDUpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEIAQ0BFQNBA0MDSANRA1wDYANuA3UDfgODA4YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1103845.1094851}}

@inproceedings{Peyton-Jones:Bridging:1998,
	Address = {New York, NY, USA},
	Author = {Peyton Jones, Simon and Mark Shields and John Launchbury and Andrew Tolmach},
	Booktitle = {POPL '98: Proceedings of the 25th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
	Date-Added = {2008-05-01 17:52:03 -0400},
	Date-Modified = {2008-05-01 17:52:05 -0400},
	Doi = {http://doi.acm.org/10.1145/268946.268951},
	Isbn = {0-89791-979-3},
	Location = {San Diego, California, United States},
	Pages = {49--61},
	Publisher = {ACM},
	Title = {Bridging the gulf: {A} common intermediate language for {ML} and {H}askell},
	Year = {1998},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHguLi8uLi9QYXBlcnMvUGV5dG9uIEpvbmVzL1BleXRvbiBKb25lcy1TaGllbGRzLUxhdW5jaGJ1cnkgLSBCcmlkZ2luZyB0aGUgZ3VsZjogQSBjb21tb24gaW50ZXJtZWRpYXRlIGxhbmd1YWdlICgxOTk4KS5wZGbSGw8cHVdOUy5kYXRhTxECgAAAAAACgAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZF6H1BleXRvbiBKb25lcy1TaGllbGRzIzM4OEIyQy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4iyzEP7KXUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAxQZXl0b24gSm9uZXMAEAAIAADBNH5dAAAAEQAIAADEP+rXAAAAAQAQAC2RegAtkT8AA0esAABr2AACAEVPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6UGV5dG9uIEpvbmVzOlBleXRvbiBKb25lcy1TaGllbGRzIzM4OEIyQy5wZGYAAA4AvgBeAFAAZQB5AHQAbwBuACAASgBvAG4AZQBzAC0AUwBoAGkAZQBsAGQAcwAtAEwAYQB1AG4AYwBoAGIAdQByAHkAIAAtACAAQgByAGkAZABnAGkAbgBnACAAdABoAGUAIABnAHUAbABmAC8AIABBACAAYwBvAG0AbQBvAG4AIABpAG4AdABlAHIAbQBlAGQAaQBhAHQAZQAgAGwAYQBuAGcAdQBhAGcAZQAgACgAMQA5ADkAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAH9Vc2Vycy9qZXJlbXkvUGFwZXJzL1BleXRvbiBKb25lcy9QZXl0b24gSm9uZXMtU2hpZWxkcy1MYXVuY2hidXJ5IC0gQnJpZGdpbmcgdGhlIGd1bGY6IEEgY29tbW9uIGludGVybWVkaWF0ZSBsYW5ndWFnZSAoMTk5OCkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgElASoBMgO2A7gDvQPGA9ED1QPjA+oD8wP4A/sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAECA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/268946.268951}}

@inproceedings{George:A-Portable:1994,
	Address = {London, UK},
	Author = {Lal George and Florent Guillame and John H. Reppy},
	Booktitle = {CC '94: Proceedings of the 5th International Conference on Compiler Construction},
	Date-Added = {2008-05-01 04:56:45 -0400},
	Date-Modified = {2008-05-01 04:56:46 -0400},
	Isbn = {3-540-57877-3},
	Pages = {83--97},
	Publisher = {Springer-Verlag},
	Title = {A Portable and Optimizing Back End for the SML/NJ Compiler},
	Year = {1994},
	Abstract = {There are two major goals that must be addressed in a portable back end: a good sequence of instructions must be selected making full use of the capabilities of the machine, and it must be possible to orchestrate target-specific optimizations. A key to the first problem is the language MLRISC, intended in part, to represent the simplest and most basic operations implementable in hardware. The importance of MLRISC is that it provides a common representation for expressing the instruction set of any hardware platform. Bottom-up tree pattern matching with dynamic programming, expressed using succinct and clear specifications of the target instruction set, is used to generate target machine code from an MLRISC program. Target-specific optimizations are performed by parameterizing off-the-shelf optimization modules with concepts common across architectures. The specification of a variety of architectures, and the ability to mix and match sophisticated optimization algorithms are shown. The resulting back end is independent of the intermediate language used in SML/NJ, and could in principle be used in a compiler for a source language quite different from SML. We argue that porting the compiler to a new architecture requires substantially less effort than the existing abstract machine approach, and report significant gains from preliminary architecture description driven optimizations.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHEuLi8uLi9QYXBlcnMvR2VvcmdlL0dlb3JnZS1HdWlsbGFtZS1SZXBweSAtIEEgUG9ydGFibGUgYW5kIE9wdGltaXppbmcgQmFjayBFbmQgZm9yIHRoZSBTTUwtTkogQ29tcGlsZXIgKDE5OTQpLnBkZtIbDxwdV05TLmRhdGFPEQJqAAAAAAJqAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4hrUfR2VvcmdlLUd1aWxsYW1lLVJlcHAjMzg4NzJBLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADiHKsQ+/IYAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABkdlb3JnZQAQAAgAAME0fl0AAAARAAgAAMQ/NMYAAAABABAAOIa1AC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpHZW9yZ2U6R2VvcmdlLUd1aWxsYW1lLVJlcHAjMzg4NzJBLnBkZgAADgC8AF0ARwBlAG8AcgBnAGUALQBHAHUAaQBsAGwAYQBtAGUALQBSAGUAcABwAHkAIAAtACAAQQAgAFAAbwByAHQAYQBiAGwAZQAgAGEAbgBkACAATwBwAHQAaQBtAGkAegBpAG4AZwAgAEIAYQBjAGsAIABFAG4AZAAgAGYAbwByACAAdABoAGUAIABTAE0ATAAtAE4ASgAgAEMAbwBtAHAAaQBsAGUAcgAgACgAMQA5ADkANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHhVc2Vycy9qZXJlbXkvUGFwZXJzL0dlb3JnZS9HZW9yZ2UtR3VpbGxhbWUtUmVwcHkgLSBBIFBvcnRhYmxlIGFuZCBPcHRpbWl6aW5nIEJhY2sgRW5kIGZvciB0aGUgU01MLU5KIENvbXBpbGVyICgxOTk0KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBHgEjASsDmQObA6ADqQO0A7gDxgPNA9YD2wPeAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA+s=}}

@article{Shao:Implementing:1999,
	Address = {New York, NY, USA},
	Author = {Zhong Shao and Christopher League and Stefan Monnier},
	Date-Added = {2008-05-01 04:56:45 -0400},
	Date-Modified = {2008-05-01 04:56:46 -0400},
	Doi = {http://doi.acm.org/10.1145/291251.289460},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {1},
	Pages = {313--323},
	Publisher = {ACM},
	Title = {Implementing typed intermediate languages},
	Volume = {34},
	Year = {1999},
	Abstract = {Recent advances in compiler technology have demonstrated the benefits of using strongly typed intermediate languages to compile richly typed source languages (e.g., ML). A type-preserving compiler can use types to guide advanced optimizations and to help generate provably secure mobile code. Types, unfortunately, are very hard to represent and manipulate efficiently; a naive implementation can easily add exponential overhead to the compilation and execution of a program. This paper describes our experience with implementing the FLINT typed intermediate language in the SML/NJ production compiler. We observe that a type-preserving compiler will not scale to handle large types unless all of its type-preserving stages preserve the asymptotic time and space usage in representing and manipulating types. We present a series of novel techniques for achieving this property and give empirical evidence of their effectiveness.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFwuLi8uLi9QYXBlcnMvU2hhby9TaGFvLUxlYWd1ZS1Nb25uaWVyIC0gSW1wbGVtZW50aW5nIHR5cGVkIGludGVybWVkaWF0ZSBsYW5ndWFnZXMgKDE5OTkpLnBkZtIbDxwdV05TLmRhdGFPEQIsAAAAAAIsAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtlG0fU2hhby1MZWFndWUtTW9ubmllciAjMzg4NzQ4LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADiHSMQ+/cBQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABFNoYW8AEAAIAADBNH5dAAAAEQAIAADEPzYAAAAAAQAQAC2UbQAtkT8AA0esAABr2AACAD1PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6U2hhbzpTaGFvLUxlYWd1ZS1Nb25uaWVyICMzODg3NDgucGRmAAAOAJYASgBTAGgAYQBvAC0ATABlAGEAZwB1AGUALQBNAG8AbgBuAGkAZQByACAALQAgAEkAbQBwAGwAZQBtAGUAbgB0AGkAbgBnACAAdAB5AHAAZQBkACAAaQBuAHQAZQByAG0AZQBkAGkAYQB0AGUAIABsAGEAbgBnAHUAYQBnAGUAcwAgACgAMQA5ADkAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGNVc2Vycy9qZXJlbXkvUGFwZXJzL1NoYW8vU2hhby1MZWFndWUtTW9ubmllciAtIEltcGxlbWVudGluZyB0eXBlZCBpbnRlcm1lZGlhdGUgbGFuZ3VhZ2VzICgxOTk5KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQkBDgEWA0YDSANNA1YDYQNlA3MDegODA4gDiwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOY},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/291251.289460}}

@techreport{League:Formal:1998,
	Address = {New Haven, Conn., USA},
	Author = {Christopher League and Zhong Shao},
	Date-Added = {2008-05-01 04:35:29 -0400},
	Date-Modified = {2008-05-01 04:41:06 -0400},
	Institution = {Yale University},
	Month = {May},
	Number = {Yale-CS-TR 1171},
	Title = {Formal Semantics of the FLINT Intermediate Language},
	Type = {Technical Report},
	Url = {http://flint.cs.yale.edu/flint/publications/formal98.html},
	Year = {1998},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGAuLi8uLi9QYXBlcnMvTGVhZ3VlL0xlYWd1ZS1TaGFvIC0gRm9ybWFsIFNlbWFudGljcyBvZiB0aGUgRkxJTlQgSW50ZXJtZWRpYXRlIExhbmd1YWdlICgxOTk4KS5wZGbSGw8cHVdOUy5kYXRhTxECOAAAAAACOAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOIbjH0xlYWd1ZS1TaGFvIC0gRm9ybWFsIzM4ODZCQy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4hrzEPvjzAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZMZWFndWUAEAAIAADBNH5dAAAAEQAIAADEPzEzAAAAAQAQADiG4wAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6TGVhZ3VlOkxlYWd1ZS1TaGFvIC0gRm9ybWFsIzM4ODZCQy5wZGYAAA4AmgBMAEwAZQBhAGcAdQBlAC0AUwBoAGEAbwAgAC0AIABGAG8AcgBtAGEAbAAgAFMAZQBtAGEAbgB0AGkAYwBzACAAbwBmACAAdABoAGUAIABGAEwASQBOAFQAIABJAG4AdABlAHIAbQBlAGQAaQBhAHQAZQAgAEwAYQBuAGcAdQBhAGcAZQAgACgAMQA5ADkAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGdVc2Vycy9qZXJlbXkvUGFwZXJzL0xlYWd1ZS9MZWFndWUtU2hhbyAtIEZvcm1hbCBTZW1hbnRpY3Mgb2YgdGhlIEZMSU5UIEludGVybWVkaWF0ZSBMYW5ndWFnZSAoMTk5OCkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgENARIBGgNWA1gDXQNmA3EDdQODA4oDkwOYA5sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqA==}}

@article{George:Iterated:1996,
	Address = {New York, NY, USA},
	Author = {Lal George and Andrew W. Appel},
	Date-Added = {2008-05-01 04:34:03 -0400},
	Date-Modified = {2008-05-01 04:34:04 -0400},
	Doi = {http://doi.acm.org/10.1145/229542.229546},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Number = {3},
	Pages = {300--324},
	Publisher = {ACM},
	Title = {Iterated register coalescing},
	Volume = {18},
	Year = {1996},
	Abstract = {An important function of any register allocator is to target registers so as to eliminate copy instructions. Graph-coloring register allocation is an elegant approach to this problem. If the source and destination of a move instruction do not interfere, then their nodes can be coalesced in the interference graph. Chaitin's coalescing heuristic could make a graph uncolorable (i.e., introduce spills); Briggs et al. demonstrated a conservative coalescing heuristic that preserves colorability. But Briggs's algorithm is too conservative and leaves too many move instructions in our programs. We show how to interleave coloring reductions with Briggs's coalescing heuristic, leading to an algorithm that is safe but much more aggressive.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEouLi8uLi9QYXBlcnMvR2VvcmdlL0dlb3JnZS1BcHBlbCAtIEl0ZXJhdGVkIHJlZ2lzdGVyIGNvYWxlc2NpbmcgKDE5OTYpLnBkZtIbDxwdV05TLmRhdGFPEQH2AAAAAAH2AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4hrUfR2VvcmdlLUFwcGVsIC0gSXRlcmEjMzg4NjkyLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADiGksQ+92VQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABkdlb3JnZQAQAAgAAME0fl0AAAARAAgAAMQ/L6UAAAABABAAOIa1AC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpHZW9yZ2U6R2VvcmdlLUFwcGVsIC0gSXRlcmEjMzg4NjkyLnBkZgAADgBuADYARwBlAG8AcgBnAGUALQBBAHAAcABlAGwAIAAtACAASQB0AGUAcgBhAHQAZQBkACAAcgBlAGcAaQBzAHQAZQByACAAYwBvAGEAbABlAHMAYwBpAG4AZwAgACgAMQA5ADkANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFFVc2Vycy9qZXJlbXkvUGFwZXJzL0dlb3JnZS9HZW9yZ2UtQXBwZWwgLSBJdGVyYXRlZCByZWdpc3RlciBjb2FsZXNjaW5nICgxOTk2KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPcA/AEEAv4DAAMFAw4DGQMdAysDMgM7A0ADQwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANQ},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/229542.229546}}

@article{Shao:Efficient:2000,
	Address = {New York, NY, USA},
	Author = {Zhong Shao and Andrew W. Appel},
	Date-Added = {2008-05-01 04:34:03 -0400},
	Date-Modified = {2008-05-01 04:34:04 -0400},
	Doi = {http://doi.acm.org/10.1145/345099.345125},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Number = {1},
	Pages = {129--161},
	Publisher = {ACM},
	Title = {Efficient and safe-for-space closure conversion},
	Volume = {22},
	Year = {2000},
	Abstract = {Modern compilers often implement function calls (or returns) in two steps: first, a ``closure'' environment is properly installed to provide access for free variables in the target program fragment; second, the control is transferred to the target by a ``jump with arguments (for results).'' Closure conversion---which decides where and how to represent closures at runtime---is a crucial step in the compilation of functional languages. This paper presents a new algorithm that exploits the use of compile-time control and data-flow information to optimize funtion calls. By extensive closure sharing and allocation by 36% and memory fetches for local and global variables by 43%; and improves the already efficient code generated by an earlier version of the Standard ML of New Jersey compiler by about 17% on a DECstation 5000. Moreover, unlike most other approaches, our new closure-allocation scheme the strong safe-for-space-complexity rule, thus achieving good asymptotic space usage.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFkuLi8uLi9QYXBlcnMvU2hhby9TaGFvLUFwcGVsIC0gRWZmaWNpZW50IGFuZCBzYWZlLWZvci1zcGFjZSBjbG9zdXJlIGNvbnZlcnNpb24gKDIwMDApLnBkZtIbDxwdV05TLmRhdGFPEQIiAAAAAAIiAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtlG0fU2hhby1BcHBlbCAtIEVmZmljaWUjMzg4NjgzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADiGg8Q+9y5QREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABFNoYW8AEAAIAADBNH5dAAAAEQAIAADEPy9uAAAAAQAQAC2UbQAtkT8AA0esAABr2AACAD1PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6U2hhbzpTaGFvLUFwcGVsIC0gRWZmaWNpZSMzODg2ODMucGRmAAAOAJAARwBTAGgAYQBvAC0AQQBwAHAAZQBsACAALQAgAEUAZgBmAGkAYwBpAGUAbgB0ACAAYQBuAGQAIABzAGEAZgBlAC0AZgBvAHIALQBzAHAAYQBjAGUAIABjAGwAbwBzAHUAcgBlACAAYwBvAG4AdgBlAHIAcwBpAG8AbgAgACgAMgAwADAAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGBVc2Vycy9qZXJlbXkvUGFwZXJzL1NoYW8vU2hhby1BcHBlbCAtIEVmZmljaWVudCBhbmQgc2FmZS1mb3Itc3BhY2UgY2xvc3VyZSBjb252ZXJzaW9uICgyMDAwKS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBBgELARMDOQM7A0ADSQNUA1gDZgNtA3YDewN+AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA4s=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/345099.345125}}

@article{Steckler:Lightweight:1997,
	Address = {New York, NY, USA},
	Author = {Paul A. Steckler and Mitchell Wand},
	Date-Added = {2008-05-01 04:34:03 -0400},
	Date-Modified = {2008-05-01 04:34:04 -0400},
	Doi = {http://doi.acm.org/10.1145/239912.239915},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Number = {1},
	Pages = {48--86},
	Publisher = {ACM},
	Title = {Lightweight closure conversion},
	Volume = {19},
	Year = {1997},
	Abstract = {We consider the problem of lightweight closure conversion, in which multiple procedure call protocols may coexist in the same code. A lightweight closure omits bindings for some of the free variables of the procedure that is represents. Flow analysis is used to match the protocol expected by each procedure and the protocol used at its possible call sites. We formulate the flow analysis as a deductive system that generates a labeled transition system and a set of constraints. We show that any solution to the constraints justifies the resulting transformation. Some of the techniques used are similar to those of abstract interpretation, but others appear to be novel.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE8uLi8uLi9QYXBlcnMvU3RlY2tsZXIvU3RlY2tsZXItV2FuZCAtIExpZ2h0d2VpZ2h0IGNsb3N1cmUgY29udmVyc2lvbiAoMTk5NykucGRm0hsPHB1XTlMuZGF0YU8RAgQAAAAAAgQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADiGth9TdGVja2xlci1XYW5kIC0gTGlnaCMzODg2ODYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOIaGxD73PFBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIU3RlY2tsZXIAEAAIAADBNH5dAAAAEQAIAADEPy98AAAAAQAQADiGtgAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6U3RlY2tsZXI6U3RlY2tsZXItV2FuZCAtIExpZ2gjMzg4Njg2LnBkZgAADgB0ADkAUwB0AGUAYwBrAGwAZQByAC0AVwBhAG4AZAAgAC0AIABMAGkAZwBoAHQAdwBlAGkAZwBoAHQAIABjAGwAbwBzAHUAcgBlACAAYwBvAG4AdgBlAHIAcwBpAG8AbgAgACgAMQA5ADkANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFZVc2Vycy9qZXJlbXkvUGFwZXJzL1N0ZWNrbGVyL1N0ZWNrbGVyLVdhbmQgLSBMaWdodHdlaWdodCBjbG9zdXJlIGNvbnZlcnNpb24gKDE5OTcpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD8AQEBCQMRAxMDGAMhAywDMAM+A0UDTgNTA1YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADYw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/239912.239915}}

@article{Ashley:A-practical:1998,
	Address = {New York, NY, USA},
	Author = {J. Michael Ashley and R. Kent Dybvig},
	Date-Added = {2008-05-01 04:34:03 -0400},
	Date-Modified = {2008-05-01 04:34:04 -0400},
	Doi = {http://doi.acm.org/10.1145/291891.291898},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Number = {4},
	Pages = {845--868},
	Publisher = {ACM},
	Title = {A practical and flexible flow analysis for higher-order languages},
	Volume = {20},
	Year = {1998},
	Abstract = {A flow analysis collects data-flow and control-flow information about programs. A compiler can use this information to enable optimizations. The analysis described in this article unifies and extends previous work on flow analysis for higher-order languages supporting assignment and control operators. The analysis is abstract interpretation based and is parameterized over two polyvariance operators and a projection operator. These operators are used to regulate the speed and accuracy of the analysis. An implementation of the analysis is incorporated into and used in a production Scheme compiler. The analysis can process any legal Scheme program without modification. Others have demonstrated that a 0CFA analysis can enables the optimizations, but a 0CFA analysis is O(n)3). An O(n) instantiation of our analysis successfully enables the optimization of closure representations and procedure calls. Experiments with the cheaper instantiation show that it is as effective as 0CFA for these optimizations.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGYuLi8uLi9QYXBlcnMvQXNobGV5L0FzaGxleS1EeWJ2aWcgLSBBIHByYWN0aWNhbCBhbmQgZmxleGlibGUgZmxvdyBhbmFseXNpcyBmb3IgaGlnaGVyLW9yZGVyICgxOTk4KS5wZGbSGw8cHVdOUy5kYXRhTxECSgAAAAACSgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOIa0H0FzaGxleS1EeWJ2aWcgLSBBIHByIzM4ODY4OS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4honEPvdEUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZBc2hsZXkAEAAIAADBNH5dAAAAEQAIAADEPy+EAAAAAQAQADiGtAAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QXNobGV5OkFzaGxleS1EeWJ2aWcgLSBBIHByIzM4ODY4OS5wZGYAAA4ApgBSAEEAcwBoAGwAZQB5AC0ARAB5AGIAdgBpAGcAIAAtACAAQQAgAHAAcgBhAGMAdABpAGMAYQBsACAAYQBuAGQAIABmAGwAZQB4AGkAYgBsAGUAIABmAGwAbwB3ACAAYQBuAGEAbAB5AHMAaQBzACAAZgBvAHIAIABoAGkAZwBoAGUAcgAtAG8AcgBkAGUAcgAgACgAMQA5ADkAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG1Vc2Vycy9qZXJlbXkvUGFwZXJzL0FzaGxleS9Bc2hsZXktRHlidmlnIC0gQSBwcmFjdGljYWwgYW5kIGZsZXhpYmxlIGZsb3cgYW5hbHlzaXMgZm9yIGhpZ2hlci1vcmRlciAoMTk5OCkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgETARgBIANuA3ADdQN+A4kDjQObA6IDqwOwA7MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADwA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/291891.291898}}

@inproceedings{Shao:Space-efficient:1994,
	Address = {New York, NY, USA},
	Author = {Zhong Shao and Andrew W. Appel},
	Booktitle = {LFP '94: Proceedings of the 1994 ACM conference on LISP and functional programming},
	Date-Added = {2008-05-01 04:34:03 -0400},
	Date-Modified = {2008-05-01 04:34:04 -0400},
	Doi = {http://doi.acm.org/10.1145/182409.156783},
	Isbn = {0-89791-643-3},
	Location = {Orlando, Florida, United States},
	Pages = {150--161},
	Publisher = {ACM},
	Title = {Space-efficient closure representations},
	Year = {1994},
	Abstract = {Many modern compilers implement function calls (or returns) in two steps: first, a closure environment is properly installed to provide access for free variables in the target program fragment; second, the control is transferred to the target by a ``jump with arguments (or results)''. Closure conversion, which decides where and how to represent closures at runtime, is a crucial step in compilation of functional languages. We have a new algorithm that exploits the use of compile-time control and data flow information to optimize closure representations. By extensive closure sharing and allocating as many closures in registers as possible, our new closure conversion algorithm reduces heap allocation by 36% and memory fetches for local/global variables by 43%; and improves the already-efficient code generated by the Standard ML of New Jersey compiler by about 17% on a DECstation 5000. Moreover, unlike most other approaches, our new closure allocation scheme satisfies the strong ``safe for space complexity'' rule, thus achieving good asymptotic space usage.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFEuLi8uLi9QYXBlcnMvU2hhby9TaGFvLUFwcGVsIC0gU3BhY2UtZWZmaWNpZW50IGNsb3N1cmUgcmVwcmVzZW50YXRpb25zICgxOTk0KS5wZGbSGw8cHVdOUy5kYXRhTxECCgAAAAACCgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZRtH1NoYW8tQXBwZWwgLSBTcGFjZS1lIzM4ODY4RC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ho3EPvdSUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAARTaGFvABAACAAAwTR+XQAAABEACAAAxD8vkgAAAAEAEAAtlG0ALZE/AANHrAAAa9gAAgA9T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlNoYW86U2hhby1BcHBlbCAtIFNwYWNlLWUjMzg4NjhELnBkZgAADgCAAD8AUwBoAGEAbwAtAEEAcABwAGUAbAAgAC0AIABTAHAAYQBjAGUALQBlAGYAZgBpAGMAaQBlAG4AdAAgAGMAbABvAHMAdQByAGUAIAByAGUAcAByAGUAcwBlAG4AdABhAHQAaQBvAG4AcwAgACgAMQA5ADkANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFhVc2Vycy9qZXJlbXkvUGFwZXJzL1NoYW8vU2hhby1BcHBlbCAtIFNwYWNlLWVmZmljaWVudCBjbG9zdXJlIHJlcHJlc2VudGF0aW9ucyAoMTk5NCkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAP4BAwELAxkDGwMgAykDNAM4A0YDTQNWA1sDXgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANr},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/182409.156783}}

@inproceedings{Shao:Unrolling:1994,
	Address = {New York, NY, USA},
	Author = {Zhong Shao and John H. Reppy and Andrew W. Appel},
	Booktitle = {LFP '94: Proceedings of the 1994 ACM conference on LISP and functional programming},
	Date-Added = {2008-05-01 04:34:03 -0400},
	Date-Modified = {2008-05-01 04:34:04 -0400},
	Doi = {http://doi.acm.org/10.1145/182409.182453},
	Isbn = {0-89791-643-3},
	Location = {Orlando, Florida, United States},
	Pages = {185--195},
	Publisher = {ACM},
	Title = {Unrolling lists},
	Year = {1994},
	Abstract = { Lists are ubiquitous in functional programs, thus supporting lists efficiently is a major concern to compiler writers for functional languages. Lists are normally represented as linked cons cells, with each cons cell containing a car (the data) and a cdr (the link); this is inefficient in the use of space, because 50% of the storage is used for links. Loops and recursions on lists are slow on modern machines because of the long chains of control dependencies (in checking for nil) and data dependencies (in fetching cdr fields).We present a data structure for ``unrolled lists'', where each cell has several data items (car fields) and one link (cdr). This reduces the memory used for links, and it significantly shortens the length of control-dependence and data-dependence chains in operations on lists.We further present an efficient compile-time analysis that transforms programs written for ``ordinary'' lists into programs on unrolled lists. The use of our new representation requires no change to existing programs.

We sketch the proof of soundness of our analysis---which is based on refinement types---and present some preliminary measurements of our technique.  },
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfED8uLi8uLi9QYXBlcnMvU2hhby9TaGFvLVJlcHB5LUFwcGVsIC0gVW5yb2xsaW5nIGxpc3RzICgxOTk0KS5wZGbSGw8cHVdOUy5kYXRhTxEB1AAAAAAB1AACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZRtH1NoYW8tUmVwcHktQXBwZWwgLSBVIzM4ODY4Ri5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ho/EPvdaUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAARTaGFvABAACAAAwTR+XQAAABEACAAAxD8vmgAAAAEAEAAtlG0ALZE/AANHrAAAa9gAAgA9T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlNoYW86U2hhby1SZXBweS1BcHBlbCAtIFUjMzg4NjhGLnBkZgAADgBcAC0AUwBoAGEAbwAtAFIAZQBwAHAAeQAtAEEAcABwAGUAbAAgAC0AIABVAG4AcgBvAGwAbABpAG4AZwAgAGwAaQBzAHQAcwAgACgAMQA5ADkANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAEZVc2Vycy9qZXJlbXkvUGFwZXJzL1NoYW8vU2hhby1SZXBweS1BcHBlbCAtIFVucm9sbGluZyBsaXN0cyAoMTk5NCkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAOwA8QD5AtEC0wLYAuEC7ALwAv4DBQMOAxMDFgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAMj},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/182409.182453}}

@inproceedings{Shao:Typed:1997,
	Address = {Santa Barbara, CA},
	Author = {Zhong Shao},
	Booktitle = {1997 {USENIX} Conference on Domain-Specific                   Languages},
	Date-Added = {2008-05-01 04:32:57 -0400},
	Date-Modified = {2008-05-01 04:33:00 -0400},
	Month = {Oct},
	Title = {Typed Common Intermediate Format},
	Year = 1997,
	Abstract = {Application languages are very effective in solving
                  specific software problems. Unfortunately, they pose
                  great challenges to reliable and efficient
                  implementations. In fact, most existing application
                  languages are slow, interpreted, and have poor
                  interoperability with general-purpose languages.\par
                  This paper presents a framework for building a high
                  quality systems environment for multiple advanced
                  languages. Our key innovation is the use of a common
                  typed intermediate language, named FLINT, to model
                  the semantics and interactions of various
                  language-specific features. FLINT is based on a
                  predicative variant of the Girard-Reynolds
                  polymorphic calculus F-omega, extended with a very
                  rich set of primitive types and functions.\par FLINT
                  provides a common compiler infrastructure that can
                  be quickly adapted to generate compilers for new
                  general-purpose and domain-specific languages. With
                  its single unified type system, FLINT serves as a
                  great platform for reasoning about cross-language
                  inter-operations. FLINT types act as a glue to
                  connect language features that complicate
                  interoperability, such as mixed data
                  representations, multiple function calling
                  conventions, and different memory management
                  protocols. In addition, because all runtime
                  representations are determined by FLINT types,
                  languages compiled under FLINT can share the same
                  system-wide garbage collector and foreign function
                  call interface.\par },
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEQuLi8uLi9QYXBlcnMvU2hhby9TaGFvIC0gVHlwZWQgQ29tbW9uIEludGVybWVkaWF0ZSBGb3JtYXQgKDE5OTcpLnBkZtIbDxwdV05TLmRhdGFPEQHkAAAAAAHkAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtlG0fU2hhbyAtIFR5cGVkIENvbW1vbiAjMzg4NkE1LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADiGpcQ++JEAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABFNoYW8AEAAIAADBNH5dAAAAEQAIAADEPzDRAAAAAQAQAC2UbQAtkT8AA0esAABr2AACAD1PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6U2hhbzpTaGFvIC0gVHlwZWQgQ29tbW9uICMzODg2QTUucGRmAAAOAGYAMgBTAGgAYQBvACAALQAgAFQAeQBwAGUAZAAgAEMAbwBtAG0AbwBuACAASQBuAHQAZQByAG0AZQBkAGkAYQB0AGUAIABGAG8AcgBtAGEAdAAgACgAMQA5ADkANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAEtVc2Vycy9qZXJlbXkvUGFwZXJzL1NoYW8vU2hhbyAtIFR5cGVkIENvbW1vbiBJbnRlcm1lZGlhdGUgRm9ybWF0ICgxOTk3KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPEA9gD+AuYC6ALtAvYDAQMFAxMDGgMjAygDKwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAM4}}

@book{Jones:Garbage:1996,
	Author = {Richard Jones and Rafael Lins},
	Date-Added = {2008-05-01 01:50:23 -0400},
	Date-Modified = {2008-05-01 02:00:00 -0400},
	Isbn = {978-0-471-94148-4},
	Publisher = {John Wiley \& Sons},
	Title = {Garbage Collection: {A}lgorithms for Automatic Dynamic Memory Management},
	Year = {1996},
	Annote = {See Appel's review at http://www.cs.princeton.edu/~appel/papers/gcreview.html (also published in the J. of Functional Programming).}}

@inproceedings{Danvy:Lambda-Lifting:2002,
	Address = {London, UK},
	Author = {Olivier Danvy and Ulrik Pagh Schultz},
	Booktitle = {FLOPS '02: Proceedings of the 6th International Symposium on Functional and Logic Programming},
	Date-Added = {2008-05-01 00:47:16 -0400},
	Date-Modified = {2008-05-01 00:47:18 -0400},
	Isbn = {3-540-44233-2},
	Pages = {134--151},
	Publisher = {Springer-Verlag},
	Title = {Lambda-Lifting in Quadratic Time},
	Year = {2002},
	Abstract = {Lambda-lifting is a program transformation used in compilers and in partial evaluators and that operates in cubic time. In this article, we show how to reduce this complexity to quadratic time.

Lambda-lifting transforms a block-structured program into a set of recursive equations, one for each local function in the source program. Each equation carries extra parameters to account for the free variables of the corresponding local function and of all its callees. It is the search for these extra parameters that yields the cubic factor in the traditional formulation of lambda-lifting, which is due to Johnsson. This search is carried out by a transitive closure.

Instead, we partition the call graph of the source program into strongly connected components, based on the simple observation that all functions in each component need the same extra parameters and thus a transitive closure is not needed. We therefore simplify the search for extra parameters by treating each strongly connected component instead of each function as a unit, thereby reducing the time complexity of lambda-lifting from $ \mathcal{O}(n^3 log n) $ to $ \mathcal{O}(n^2 log n) $ , where $n$ is the size of the program.
Since a lambda-lifter can output programs of size $ \mathcal{O}(n^2 ) $ , we believe that our algorithm is close to optimal.

An extended version of this article is available in the BRICS Research Series [14].
Basic Research in Computer Science (www.brics.dk), funded by the Danish National Research Foundation.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE4uLi8uLi9QYXBlcnMvRGFudnkvRGFudnktU2NodWx0eiAtIExhbWJkYS1MaWZ0aW5nIGluIFF1YWRyYXRpYyBUaW1lICgyMDAyKS5wZGbSGw8cHVdOUy5kYXRhTxECAgAAAAACAgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOEeKH0RhbnZ5LVNjaHVsdHogLSBMYW1iIzM4N0QyRS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4fS7EPsJiUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVEYW52eQAAEAAIAADBNH5dAAAAEQAIAADEPvqiAAAAAQAQADhHigAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6RGFudnk6RGFudnktU2NodWx0eiAtIExhbWIjMzg3RDJFLnBkZgAOAHgAOwBEAGEAbgB2AHkALQBTAGMAaAB1AGwAdAB6ACAALQAgAEwAYQBtAGIAZABhAC0ATABpAGYAdABpAG4AZwAgAGkAbgAgAFEAdQBhAGQAcgBhAHQAaQBjACAAVABpAG0AZQAgACgAMgAwADAAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFVVc2Vycy9qZXJlbXkvUGFwZXJzL0RhbnZ5L0RhbnZ5LVNjaHVsdHogLSBMYW1iZGEtTGlmdGluZyBpbiBRdWFkcmF0aWMgVGltZSAoMjAwMikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD7AQABCAMOAxADFQMeAykDLQM7A0IDSwNQA1MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADYA==}}

@article{Fischbach:Specification:2003,
	Address = {New York, NY, USA},
	Author = {Adam Fischbach and John Hannan},
	Date-Added = {2008-05-01 00:47:16 -0400},
	Date-Modified = {2008-05-01 00:47:18 -0400},
	Doi = {http://dx.doi.org/10.1017/S0956796802004604},
	Issn = {0956-7968},
	Journal = {J. Funct. Program.},
	Number = {3},
	Pages = {509--543},
	Publisher = {Cambridge University Press},
	Title = {Specification and correctness of lambda lifting},
	Volume = {13},
	Year = {2003},
	Abstract = {We present a formal and general specification of lambda lifting and prove its correctness with respect to a call-by-name operational semantics. We use this specification to prove the correctness of a lambda lifting algorithm similar to the one proposed by Johnsson. Lambda lifting is a program transformation that eliminates free variables from functions by introducing additional formal parameters to function definitions and additional actual parameters to function calls. This operation supports the transformation from a lexically-structured functional program into a set of recursive equations. Existing results provide specific algorithms and only limited correctness results. Our work provides a more general specification of lambda lifting (and related operations) that supports flexible translation strategies, which may result in new implementation techniques. Our work also supports a simple framework in which the interaction of lambda lifting and other optimizations can be studied and from which new algorithms might be obtained.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGQuLi8uLi9QYXBlcnMvRmlzY2hiYWNoL0Zpc2NoYmFjaC1IYW5uYW4gLSBTcGVjaWZpY2F0aW9uIGFuZCBjb3JyZWN0bmVzcyBvZiBsYW1iZGEgbGlmdGluZyAoMjAwMykucGRm0hsPHB1XTlMuZGF0YU8RAkQAAAAAAkQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADh9Ux9GaXNjaGJhY2gtSGFubmFuIC0gUyMzODdEMzgucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOH04xD7CqFBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAJRmlzY2hiYWNoAAAQAAgAAME0fl0AAAARAAgAAMQ++ugAAAABABAAOH1TAC2RPwADR6wAAGvYAAIAQk9kaW46VXNlcnM6amVyZW15OlBhcGVyczpGaXNjaGJhY2g6RmlzY2hiYWNoLUhhbm5hbiAtIFMjMzg3RDM4LnBkZgAOAJwATQBGAGkAcwBjAGgAYgBhAGMAaAAtAEgAYQBuAG4AYQBuACAALQAgAFMAcABlAGMAaQBmAGkAYwBhAHQAaQBvAG4AIABhAG4AZAAgAGMAbwByAHIAZQBjAHQAbgBlAHMAcwAgAG8AZgAgAGwAYQBtAGIAZABhACAAbABpAGYAdABpAG4AZwAgACgAMgAwADAAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGtVc2Vycy9qZXJlbXkvUGFwZXJzL0Zpc2NoYmFjaC9GaXNjaGJhY2gtSGFubmFuIC0gU3BlY2lmaWNhdGlvbiBhbmQgY29ycmVjdG5lc3Mgb2YgbGFtYmRhIGxpZnRpbmcgKDIwMDMpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBEQEWAR4DZgNoA20DdgOBA4UDkwOaA6MDqAOrAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA7g=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1017/S0956796802004604}}

@inproceedings{Johnsson:Lambda:1985,
	Address = {New York, NY, USA},
	Author = {Thomas Johnsson},
	Booktitle = {Proc. of a conference on Functional programming languages and computer architecture},
	Date-Added = {2008-05-01 00:47:16 -0400},
	Date-Modified = {2008-05-01 00:47:18 -0400},
	Doi = {http://dx.doi.org/10.1007/3-540-15975-4},
	Isbn = {3-387-15975-4},
	Location = {Nancy, France},
	Pages = {190--203},
	Publisher = {Springer-Verlag New York, Inc.},
	Title = {Lambda lifting: transforming programs to recursive equations},
	Year = {1985},
	Abstract = {Lambda lifting is a technique for transforming a functional program with local function definitions, possibly with free variables in the function definitions, into a program consisting only of global function (combinator) definitions which will be used as rewrite rules. Different ways of doing lambda lifting are presented, as well as reasons for rejecting or selecting the method used in our Lazy ML compiler. A functional program implementing the chosen algorithm is given.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEF4uLi8uLi9QYXBlcnMvSm9obnNzb24vSm9obnNzb24gLSBMYW1iZGEgbGlmdGluZzogdHJhbnNmb3JtaW5nIHByb2dyYW1zIHRvIHJlY3Vyc2l2ZSAoMTk4NSkucGRm0hsPHB1XTlMuZGF0YU8RAjIAAAAAAjIAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADhHjh9Kb2huc3NvbiAtIExhbWJkYSBsaSMzODhBODAucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOIqAxD+oKFBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAISm9obnNzb24AEAAIAADBNH5dAAAAEQAIAADEP+BoAAAAAQAQADhHjgAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6Sm9obnNzb246Sm9obnNzb24gLSBMYW1iZGEgbGkjMzg4QTgwLnBkZgAADgCSAEgASgBvAGgAbgBzAHMAbwBuACAALQAgAEwAYQBtAGIAZABhACAAbABpAGYAdABpAG4AZwAvACAAdAByAGEAbgBzAGYAbwByAG0AaQBuAGcAIABwAHIAbwBnAHIAYQBtAHMAIAB0AG8AIAByAGUAYwB1AHIAcwBpAHYAZQAgACgAMQA5ADgANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGVVc2Vycy9qZXJlbXkvUGFwZXJzL0pvaG5zc29uL0pvaG5zc29uIC0gTGFtYmRhIGxpZnRpbmc6IHRyYW5zZm9ybWluZyBwcm9ncmFtcyB0byByZWN1cnNpdmUgKDE5ODUpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBCwEQARgDTgNQA1UDXgNpA20DewOCA4sDkAOTAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA6A=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/3-540-15975-4}}

@inproceedings{Hughes:Super-combinators:1982,
	Address = {New York, NY, USA},
	Author = {R. J. M. Hughes},
	Booktitle = {LFP '82: Proceedings of the 1982 ACM symposium on LISP and functional programming},
	Date-Added = {2008-05-01 00:35:39 -0400},
	Date-Modified = {2008-05-01 00:36:45 -0400},
	Doi = {http://doi.acm.org/10.1145/800068.802129},
	Isbn = {0-89791-082-6},
	Location = {Pittsburgh, Pennsylvania, United States},
	Pages = {1--10},
	Publisher = {ACM},
	Title = {Super-combinators: {A} new implementation method for applicative languages},
	Year = {1982},
	Abstract = {There is a growing interest nowadays in functional programming languages and systems, and in special hardware for executing them. Many of these implementations are based on a system called graph reduction (GR), in which a program is represented as a graph which is transformed, or reduced, by the machine until it represents the desired answer. The various graph reduction implementations differ in the structure of the ``machine code'' (the program graph) and the compilation algorithms necessary to produce it from a source language. This paper describes a new implementation method using super-combinators which is apparently more efficient than its predecessors. Consideration of the new method also helps clarify the relationships between several other graph-reduction schemes. This paper is necessarily brief, but a fuller account can be found in [Hughes]. The simplest machine language we shall consider consists of constants combined by function application. This is the language of constant applicative forms (cafs). Some of the constants are basic functions.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHAuLi8uLi9QYXBlcnMvSHVnaGVzL0h1Z2hlcyAtIFN1cGVyLWNvbWJpbmF0b3JzOiBBIG5ldyBpbXBsZW1lbnRhdGlvbiBtZXRob2QgZm9yIGFwcGxpY2F0aXZlIGxhbmd1YWdlcyAoMTk4MikucGRm0hsPHB1XTlMuZGF0YU8RAmgAAAAAAmgAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADh9Ah9IdWdoZXMgLSBTdXBlci1jb21iaSMzODdDRkMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOHz8xD7BFlBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGSHVnaGVzABAACAAAwTR+XQAAABEACAAAxD75VgAAAAEAEAA4fQIALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkh1Z2hlczpIdWdoZXMgLSBTdXBlci1jb21iaSMzODdDRkMucGRmAAAOALoAXABIAHUAZwBoAGUAcwAgAC0AIABTAHUAcABlAHIALQBjAG8AbQBiAGkAbgBhAHQAbwByAHMALwAgAEEAIABuAGUAdwAgAGkAbQBwAGwAZQBtAGUAbgB0AGEAdABpAG8AbgAgAG0AZQB0AGgAbwBkACAAZgBvAHIAIABhAHAAcABsAGkAYwBhAHQAaQB2AGUAIABsAGEAbgBnAHUAYQBnAGUAcwAgACgAMQA5ADgAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHdVc2Vycy9qZXJlbXkvUGFwZXJzL0h1Z2hlcy9IdWdoZXMgLSBTdXBlci1jb21iaW5hdG9yczogQSBuZXcgaW1wbGVtZW50YXRpb24gbWV0aG9kIGZvciBhcHBsaWNhdGl2ZSBsYW5ndWFnZXMgKDE5ODIpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBHQEiASoDlgOYA50DpgOxA7UDwwPKA9MD2APbAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA+g=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/800068.802129}}

@article{Landin:The-Mechanical:1964,
	Author = {Landin, Peter J.},
	Date-Added = {2008-05-01 00:13:54 -0400},
	Date-Modified = {2008-05-01 00:19:08 -0400},
	Issn = {0010-4620},
	Journal = {The Computer Journal},
	Month = {April},
	Number = {4},
	Pages = {308-320},
	Title = {The Mechanical Evaluation of Expressions},
	Volume = {6},
	Year = {1964},
	Annote = {Introduced the SECD machine.}}

@inproceedings{Fradet:Collecting:1994,
	Address = {New York, NY, USA},
	Author = {Pascal Fradet},
	Booktitle = {LFP '94: Proceedings of the 1994 ACM conference on LISP and functional programming},
	Date-Added = {2008-04-30 04:58:57 -0400},
	Date-Modified = {2008-04-30 04:58:59 -0400},
	Doi = {http://doi.acm.org/10.1145/182409.182417},
	Isbn = {0-89791-643-3},
	Location = {Orlando, Florida, United States},
	Pages = {24--33},
	Publisher = {ACM},
	Title = {Collecting more garbage},
	Year = {1994},
	Abstract = {We present a method, adapted to polymorphically typed functional languages, to detect and collect more garbage than existing GCs. It can be applied to strict or lazy higher order languages and to several garbage collection schemes. Our GC exploits the information on utility of arguments provided by polymorphic types of functions. It is able to detect garbage that is still referenced from the stack and may collect useless parts of otherwise useful data structures. We show how to partially collect shared data structures and to extend the type system to infer more precise information. We also present hoe this technique can plug several common forms of space leaks.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfED8uLi8uLi9QYXBlcnMvRnJhZGV0L0ZyYWRldCAtIENvbGxlY3RpbmcgbW9yZSBnYXJiYWdlICgxOTk0KS5wZGbSGw8cHVdOUy5kYXRhTxEB1AAAAAAB1AACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZQPH0ZyYWRldCAtIENvbGxlY3RpbmcgIzM4NzE0Mi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4cULEPa1+UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZGcmFkZXQAEAAIAADBNH5dAAAAEQAIAADEPeW+AAAAAQAQAC2UDwAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6RnJhZGV0OkZyYWRldCAtIENvbGxlY3RpbmcgIzM4NzE0Mi5wZGYAAA4AWAArAEYAcgBhAGQAZQB0ACAALQAgAEMAbwBsAGwAZQBjAHQAaQBuAGcAIABtAG8AcgBlACAAZwBhAHIAYgBhAGcAZQAgACgAMQA5ADkANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAEZVc2Vycy9qZXJlbXkvUGFwZXJzL0ZyYWRldC9GcmFkZXQgLSBDb2xsZWN0aW5nIG1vcmUgZ2FyYmFnZSAoMTk5NCkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAOwA8QD5AtEC0wLYAuEC7ALwAv4DBQMOAxMDFgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAMj},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/182409.182417}}

@inproceedings{Clinger:Proper:1998,
	Address = {New York, NY, USA},
	Author = {William D. Clinger},
	Booktitle = {PLDI '98: Proceedings of the ACM SIGPLAN 1998 conference on Programming language design and implementation},
	Date-Added = {2008-04-30 04:58:57 -0400},
	Date-Modified = {2008-04-30 04:58:59 -0400},
	Doi = {http://doi.acm.org/10.1145/277650.277719},
	Isbn = {0-89791-987-4},
	Location = {Montreal, Quebec, Canada},
	Pages = {174--185},
	Publisher = {ACM},
	Title = {Proper tail recursion and space efficiency},
	Year = {1998},
	Abstract = {The IEEE/ANSI standard for Scheme requires implementations to be \textit{properly tail recursive}. This ensures that portable code can rely upon the space efficiency of continuation-passing style and other idioms. On its face, proper tail recursion concerns the efficiency of procedure calls that occur within a tail context. When examined closely, proper tail recursion also depends upon the fact that garbage collection can be asymptotically more space-efficient than Algol-like stack allocation.

Proper tail recursion is not the same as ad hoc tail call optimization in stack-based languages. Proper tail recursion often precludes stack allocation of variables, but yields a well-defined asymptotic space complexity that can be relied upon by portable programs.This paper offers a formal and implementation-independent definition of proper tail recursion for Scheme. It also shows how an entire family of reference implementations can be used to characterize related safe-for-space properties, and proves the asymptotic inequalities that hold between them.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFQuLi8uLi9QYXBlcnMvQ2xpbmdlci9DbGluZ2VyIC0gUHJvcGVyIHRhaWwgcmVjdXJzaW9uIGFuZCBzcGFjZSBlZmZpY2llbmN5ICgxOTk4KS5wZGbSGw8cHVdOUy5kYXRhTxECFAAAAAACFAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOHFZH0NsaW5nZXIgLSBQcm9wZXIgdGFpIzM4NzE0Ny5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4cUfEPa2SUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdDbGluZ2VyAAAQAAgAAME0fl0AAAARAAgAAMQ95dIAAAABABAAOHFZAC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpDbGluZ2VyOkNsaW5nZXIgLSBQcm9wZXIgdGFpIzM4NzE0Ny5wZGYADgCAAD8AQwBsAGkAbgBnAGUAcgAgAC0AIABQAHIAbwBwAGUAcgAgAHQAYQBpAGwAIAByAGUAYwB1AHIAcwBpAG8AbgAgAGEAbgBkACAAcwBwAGEAYwBlACAAZQBmAGYAaQBjAGkAZQBuAGMAeQAgACgAMQA5ADkAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFtVc2Vycy9qZXJlbXkvUGFwZXJzL0NsaW5nZXIvQ2xpbmdlciAtIFByb3BlciB0YWlsIHJlY3Vyc2lvbiBhbmQgc3BhY2UgZWZmaWNpZW5jeSAoMTk5OCkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEBAQYBDgMmAygDLQM2A0EDRQNTA1oDYwNoA2sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADeA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/277650.277719}}

@article{Baker:CONS:1995,
	Address = {New York, NY, USA},
	Author = {Henry G. Baker},
	Date-Added = {2008-04-30 04:58:57 -0400},
	Date-Modified = {2008-04-30 04:58:59 -0400},
	Doi = {http://doi.acm.org/10.1145/214448.214454},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {9},
	Pages = {17--20},
	Publisher = {ACM},
	Title = {CONS should not CONS its arguments, part II: Cheney on the M.T.A.},
	Volume = {30},
	Year = {1995},
	Abstract = {Previous Schemes for implementing full tail-recursion when compiling into C have required some form of "trampoline" to pop the stack. We propose solving the tail-recursion problem in the same manner as Standard ML of New Jersey, by allocating all frames in the (garbage-collected) heap. The Scheme program is translated into continuation-passing style, so the target C functions never return. The C stack pointer then becomes the allocation pointer for a Cheney-style copying garbage collection scheme. Our Scheme can use C function calls, C arguments, C variable-arity functions, and separate compilation without requiring complex block-compilation of entire programs. Our C version of the "Boyer" benchmark is available at ftp://ftp.netcom.com/pub/hb/hbaker/cboyer13.c.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE4uLi8uLi9QYXBlcnMvQmFrZXIvQmFrZXIgLSBDT05TIHNob3VsZCBub3QgQ09OUyBpdHMgYXJndW1lbnRzLCBwYXJ0ICgxOTk1KS5wZGbSGw8cHVdOUy5kYXRhTxECAgAAAAACAgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOEaOH0Jha2VyIC0gQ09OUyBzaG91bGQgIzM4NzE0Qi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4cUvEPa2hUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVCYWtlcgAAEAAIAADBNH5dAAAAEQAIAADEPeXhAAAAAQAQADhGjgAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QmFrZXI6QmFrZXIgLSBDT05TIHNob3VsZCAjMzg3MTRCLnBkZgAOAHgAOwBCAGEAawBlAHIAIAAtACAAQwBPAE4AUwAgAHMAaABvAHUAbABkACAAbgBvAHQAIABDAE8ATgBTACAAaQB0AHMAIABhAHIAZwB1AG0AZQBuAHQAcwAsACAAcABhAHIAdAAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFVVc2Vycy9qZXJlbXkvUGFwZXJzL0Jha2VyL0Jha2VyIC0gQ09OUyBzaG91bGQgbm90IENPTlMgaXRzIGFyZ3VtZW50cywgcGFydCAoMTk5NSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD7AQABCAMOAxADFQMeAykDLQM7A0IDSwNQA1MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADYA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/214448.214454}}

@article{Baker:CONS:1992,
	Address = {New York, NY, USA},
	Author = {Henry G. Baker},
	Date-Added = {2008-04-30 04:58:57 -0400},
	Date-Modified = {2008-04-30 04:58:59 -0400},
	Doi = {http://doi.acm.org/10.1145/130854.130858},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {3},
	Pages = {24--34},
	Publisher = {ACM},
	Title = {CONS should not CONS its arguments, or, a lazy alloc is a smart alloc},
	Volume = {27},
	Year = {1992},
	Abstract = {\textit{Lazy allocation} is a model for allocating objects on the execution stack of a high-level language which does not create dangling references. Our model provides safe transportation into the heap for objects that may survive the deallocation of the surrounding stack frame. Space for objects that do not survive the deallocation of the surrounding stack frame is reclaimed without additional effort when the stack is popped. Lazy allocation thus performs a first-level garbage collection, and if the language supports garbage collection of the heap, then our model can reduce the amortized cost of allocation in such a heap by filtering out the short-lived objects that can be more efficiently managed in LIFO order. A run-time mechanism called \textit{result expectation} further filters out unneeded results from functions called only for their effects. In a shared-memory multi-processor environment, this filtering reduces contention for the allocation and management of global memory.

Our model performs simple local operations, and is therefore suitable for an interpreter or a hardware implementation. Its overheads for functional data are associated only with \textit{assignments}, making lazy allocation attractive for \textit{mostly functional} programming styles. Many existing stack allocation optimizations can be seen as instances of this generic model, in which some portion of these local operations have been optimized away through static analysis techniques.

Important applications of our model include the efficient allocation of temporary data structures that are passed as arguments to anonymous procedures which may or may not use these data structures in a stack-like fashion. The most important of these objects are functional arguments (\textit{funargs}), which require some run-time allocation to preserve the local environment. Since a funarg is sometimes returned as a first-class value, its lifetime can survive the stack frame in which it was created. Arguments which are evaluated in a lazy fashion (Scheme \textit{delays} or "suspensions") are similarly handled. Variable-length argument "lists" themselves can be allocated in this fashion, allowing these objects to become "first-class". Finally, lazy allocation correctly handles the allocation of a Scheme control stack, allowing Scheme continuations to become first-class values.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFQuLi8uLi9QYXBlcnMvQmFrZXIvQmFrZXIgLSBDT05TIHNob3VsZCBub3QgQ09OUyBpdHMgYXJndW1lbnRzLCBvciwgYSBsYXp5ICgxOTkyKS5wZGbSGw8cHVdOUy5kYXRhTxECFAAAAAACFAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOEaOH0Jha2VyIC0gQ09OUyBzaG91bGQgIzM4NzE0RS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4cU7EPa2uUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVCYWtlcgAAEAAIAADBNH5dAAAAEQAIAADEPeXuAAAAAQAQADhGjgAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QmFrZXI6QmFrZXIgLSBDT05TIHNob3VsZCAjMzg3MTRFLnBkZgAOAIQAQQBCAGEAawBlAHIAIAAtACAAQwBPAE4AUwAgAHMAaABvAHUAbABkACAAbgBvAHQAIABDAE8ATgBTACAAaQB0AHMAIABhAHIAZwB1AG0AZQBuAHQAcwAsACAAbwByACwAIABhACAAbABhAHoAeQAgACgAMQA5ADkAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFtVc2Vycy9qZXJlbXkvUGFwZXJzL0Jha2VyL0Jha2VyIC0gQ09OUyBzaG91bGQgbm90IENPTlMgaXRzIGFyZ3VtZW50cywgb3IsIGEgbGF6eSAoMTk5MikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEBAQYBDgMmAygDLQM2A0EDRQNTA1oDYwNoA2sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADeA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/130854.130858}}

@article{Baker-Jr.:Shallow:1978,
	Address = {New York, NY, USA},
	Author = {Henry G. {Baker, Jr.}},
	Date-Added = {2008-04-30 04:58:57 -0400},
	Date-Modified = {2008-04-30 05:03:02 -0400},
	Doi = {http://doi.acm.org/10.1145/359545.359566},
	Issn = {0001-0782},
	Journal = {Commun. ACM},
	Number = {7},
	Pages = {565--569},
	Publisher = {ACM},
	Title = {Shallow binding in Lisp 1.5},
	Volume = {21},
	Year = {1978},
	Abstract = {Shallow binding is a scheme which allows the value of a variable to be accessed in a bounded amount of computation. An elegant model for shallow binding in Lisp 1.5 is presented in which context-switching is an environment tree transformation called rerooting. Rerooting is completely general and reversible, and is optional in the sense that a Lisp 1.5 interpreter will operate correctly whether or not rerooting is invoked on every context change. Since rerooting leaves assoc [v, a] invariant, for all variables v and all environments a, the programmer can have access to a rerooting primitive, shallow[], which gives him dynamic control over whether accesses are shallow or deep, and which affects only the speed of execution of a program, not its semantics. In addition, multiple processes can be active in the same environment structure, so long as rerooting is an indivisible operation. Finally, the concept of rerooting is shown to combine the concept of shallow binding in Lisp with Dijkstra's display for Algol and hence is a general model for shallow binding.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEsuLi8uLi9QYXBlcnMvQmFrZXIsIEpyLi9CYWtlciwgSnIuIC0gU2hhbGxvdyBiaW5kaW5nIGluIExpc3AgMS41ICgxOTc4KS5wZGbSGw8cHVdOUy5kYXRhTxEB+AAAAAAB+AACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOHFkH0Jha2VyLCBKci4gLSBTaGFsbG93IzM4NzE1Mi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4cVLEPa2+UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAApCYWtlciwgSnIuABAACAAAwTR+XQAAABEACAAAxD3l/gAAAAEAEAA4cWQALZE/AANHrAAAa9gAAgBDT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkJha2VyLCBKci46QmFrZXIsIEpyLiAtIFNoYWxsb3cjMzg3MTUyLnBkZgAADgBoADMAQgBhAGsAZQByACwAIABKAHIALgAgAC0AIABTAGgAYQBsAGwAbwB3ACAAYgBpAG4AZABpAG4AZwAgAGkAbgAgAEwAaQBzAHAAIAAxAC4ANQAgACgAMQA5ADcAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFJVc2Vycy9qZXJlbXkvUGFwZXJzL0Jha2VyLCBKci4vQmFrZXIsIEpyLiAtIFNoYWxsb3cgYmluZGluZyBpbiBMaXNwIDEuNSAoMTk3OCkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPgA/QEFAwEDAwMIAxEDHAMgAy4DNQM+A0MDRgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANT},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/359545.359566}}

@inproceedings{Meijer:Confessions:2007,
	Address = {New York, NY, USA},
	Author = {Erik Meijer},
	Booktitle = {OOPSLA '07: Proceedings of the 22nd annual ACM SIGPLAN conference on Object oriented programming systems and applications},
	Date-Added = {2008-04-30 01:20:39 -0400},
	Date-Modified = {2008-04-30 01:21:19 -0400},
	Doi = {http://doi.acm.org/10.1145/1297027.1297078},
	Isbn = {978-1-59593-786-5},
	Location = {Montreal, Quebec, Canada},
	Pages = {677--694},
	Publisher = {ACM},
	Title = {Confessions of a used programming language salesman},
	Year = {2007},
	Abstract = {For many years I had been fruitlessly trying to sell functional programming and Haskell to solve real world problems such as scripting and data-intensive three-tier distributed web applications. The lack of widespread adoption of Haskell is a real pity. Functional programming concepts are key to curing many of the headaches that plague the majority of programmers, who today are forced to use imperative languages. If the mountain won't come to Mohammed, Mohammed must go to the mountain, and so I left academia to join industry. Instead of trying to convince imperative programmers to forget everything they already know and learn something completely new, I decided to infuse existing imperative object-oriented programming languages with functional programming features. As a result, functional programming has finally reached the masses, except that it is called Visual Basic 9 instead of Haskell 98.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFsuLi8uLi9QYXBlcnMvTWVpamVyL01laWplciAtIENvbmZlc3Npb25zIG9mIGEgdXNlZCBwcm9ncmFtbWluZyBsYW5ndWFnZSBzYWxlc21hbiAoMjAwNykucGRm0hsPHB1XTlMuZGF0YU8RAigAAAAAAigAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADaBIB9NZWlqZXIgLSBDb25mZXNzaW9ucyMyOUY4ODIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKfiCAAAAAAAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGTWVpamVyABAACAAAwTR+XQAAABEACAAAAAAAAAAAAAEAEAA2gSAALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOk1laWplcjpNZWlqZXIgLSBDb25mZXNzaW9ucyMyOUY4ODIucGRmAAAOAJAARwBNAGUAaQBqAGUAcgAgAC0AIABDAG8AbgBmAGUAcwBzAGkAbwBuAHMAIABvAGYAIABhACAAdQBzAGUAZAAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgAGwAYQBuAGcAdQBhAGcAZQAgAHMAYQBsAGUAcwBtAGEAbgAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGJVc2Vycy9qZXJlbXkvUGFwZXJzL01laWplci9NZWlqZXIgLSBDb25mZXNzaW9ucyBvZiBhIHVzZWQgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2Ugc2FsZXNtYW4gKDIwMDcpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEIAQ0BFQNBA0MDSANRA1wDYANuA3UDfgODA4YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1297027.1297078}}

@article{Jones:Tail:1992,
	Author = {Richard E. Jones},
	Date-Added = {2008-04-29 02:46:30 -0400},
	Date-Modified = {2008-05-01 03:40:57 -0400},
	Journal = {Journal of Functional Programming},
	Month = {January},
	Number = {1},
	Pages = {73--79},
	Title = {Tail recursion without Space Leaks},
	Volume = {2},
	Year = {1992},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEguLi8uLi9QYXBlcnMvSm9uZXMvSm9uZXMgLSBUYWlsIHJlY3Vyc2lvbiB3aXRob3V0IFNwYWNlIExlYWtzICgxOTkyKS5wZGbSGw8cHVdOUy5kYXRhTxEB8AAAAAAB8AACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOCgEH0pvbmVzIC0gVGFpbCByZWN1cnNpIzM4NTZCMC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4VrDEPDxoAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVKb25lcwAAEAAIAADBNH5dAAAAEQAIAADEPHSoAAAAAQAQADgoBAAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6Sm9uZXM6Sm9uZXMgLSBUYWlsIHJlY3Vyc2kjMzg1NkIwLnBkZgAOAGwANQBKAG8AbgBlAHMAIAAtACAAVABhAGkAbAAgAHIAZQBjAHUAcgBzAGkAbwBuACAAdwBpAHQAaABvAHUAdAAgAFMAcABhAGMAZQAgAEwAZQBhAGsAcwAgACgAMQA5ADkAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAE9Vc2Vycy9qZXJlbXkvUGFwZXJzL0pvbmVzL0pvbmVzIC0gVGFpbCByZWN1cnNpb24gd2l0aG91dCBTcGFjZSBMZWFrcyAoMTk5MikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD1APoBAgL2AvgC/QMGAxEDFQMjAyoDMwM4AzsAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADSA==},
	Bdsk-Url-1 = {citeseer.ist.psu.edu/jones91tail.html}}

@techreport{Ager:A-Functional:2003b,
	Address = {Aarhus, Denmark},
	Author = {Mads Sig Ager and Dariusz Biernacki and Olivier Danvy and Jan Midtgaard},
	Date-Added = {2008-04-29 01:22:44 -0400},
	Date-Modified = {2008-04-29 01:27:06 -0400},
	Institution = {DAIMI, Department of Computer Science, University of Aarhus},
	Issn = {0909-0878},
	Month = {Nov},
	Number = {BRICS RS-03-14},
	Title = {A Functional Correspondence between Monadic Evaluators and Abstract Machines for Languages with Computational Effects},
	Type = {Technical Report},
	Year = {2003},
	Abstract = {We extend our correspondence between evaluators and abstract machines from the pure setting of the lambda-calculus to the impure setting of the computational lambda-calculus. Specifically, we show how to derive new abstract machines from monadic evaluators for the computational lambda-calculus. Starting from a monadic evaluator and a given monad, we inline the components of the monad in the evaluator and we derive the corresponding abstract machine by closure-converting, CPS-transforming, and defunctionalizing this inlined interpreter. We illustrate the construction first with the identity monad, obtaining yet again the CEK machine, and then with a state monad, an exception monad, and a combination of both.

In addition, we characterize the tail-recursive stack inspection presented by Clements and Felleisen at ESOP 2003 as a canonical state monad. Combining this state monad with an exception monad, we construct an abstract machine for a language with exceptions and properly tail-recursive stack inspection. The construction scales to other monads--including one more properly dedicated to stack inspection than the state monad--and other monadic evaluators.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGouLi8uLi9QYXBlcnMvQWdlci9BZ2VyLUJpZXJuYWNraS1EYW52eSAtIEEgRnVuY3Rpb25hbCBDb3JyZXNwb25kZW5jZSBiZXR3ZWVuIE1vbmFkaWMgRXZhbHVhdG9ycyAoMjAwMykucGRm0hsPHB1XTlMuZGF0YU8RAlYAAAAAAlYAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADhGjB9BZ2VyLUJpZXJuYWNraS1EYW52eSMzODU1MTMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOFUTxDwoqQAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAEQWdlcgAQAAgAAME0fl0AAAARAAgAAMQ8YOkAAAABABAAOEaMAC2RPwADR6wAAGvYAAIAPU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpBZ2VyOkFnZXItQmllcm5hY2tpLURhbnZ5IzM4NTUxMy5wZGYAAA4AsgBYAEEAZwBlAHIALQBCAGkAZQByAG4AYQBjAGsAaQAtAEQAYQBuAHYAeQAgAC0AIABBACAARgB1AG4AYwB0AGkAbwBuAGEAbAAgAEMAbwByAHIAZQBzAHAAbwBuAGQAZQBuAGMAZQAgAGIAZQB0AHcAZQBlAG4AIABNAG8AbgBhAGQAaQBjACAARQB2AGEAbAB1AGEAdABvAHIAcwAgACgAMgAwADAAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHFVc2Vycy9qZXJlbXkvUGFwZXJzL0FnZXIvQWdlci1CaWVybmFja2ktRGFudnkgLSBBIEZ1bmN0aW9uYWwgQ29ycmVzcG9uZGVuY2UgYmV0d2VlbiBNb25hZGljIEV2YWx1YXRvcnMgKDIwMDMpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBFwEcASQDfgOAA4UDjgOZA50DqwOyA7sDwAPDAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA9A=}}

@techreport{Ager:A-Functional:2003a,
	Address = {Aarhus, Denmark},
	Author = {Mads Sig Ager and Dariusz Biernacki and Olivier Danvy and Jan Midtgaard},
	Date-Added = {2008-04-29 01:22:44 -0400},
	Date-Modified = {2008-04-29 01:27:12 -0400},
	Institution = {DAIMI, Department of Computer Science, University of Aarhus},
	Issn = {0909-0878},
	Month = {Mar},
	Number = {BRICS RS-03-13},
	Title = {A Functional Correspondence between Evaluators and Abstract Machines},
	Type = {Technical Report},
	Year = {2003},
	Abstract = {We bridge the gap between functional evaluators and abstract machines for the lambda-calculus, using closure conversion, transformation into continuation-passing style, and defunctionalization of continuations.

We illustrate this bridge by deriving Krivine's abstract machine from an ordinary call-by-name evaluator and by deriving an ordinary call-by-value evaluator from Felleisen et al.'s CEK machine. The first derivation is strikingly simpler than what can be found in the literature. The second one is new. Together, they show that Krivine's abstract machine and the CEK machine correspond to the call-by-name and call-by-value facets of an ordinary evaluator for the lambda-calculus.

We then reveal the denotational content of Hannan and Miller's CLS machine and of Landin's SECD machine. We formally compare the corresponding evaluators and we illustrate some relative degrees of freedom in the design spaces of evaluators and of abstract machines for the lambda-calculus with computational effects.

For the purpose of this work, we distinguish between virtual machines, which have an instruction set, and abstract machines, which do not. The Categorical Abstract Machine, for example, has an instruction set, but Krivine's machine, the CEK machine, the CLS machine, and the SECD machine do not; they directly operate on lambda-terms instead. We present the abstract machine that corresponds to the Categorical Abstract Machine.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHAuLi8uLi9QYXBlcnMvQWdlci9BZ2VyLUJpZXJuYWNraS1EYW52eSAtIEEgRnVuY3Rpb25hbCBDb3JyZXNwb25kZW5jZSBiZXR3ZWVuIEV2YWx1YXRvcnMgYW5kIEFic3RyYWN0ICgyMDAzYSkucGRm0hsPHB1XTlMuZGF0YU8RAmgAAAAAAmgAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADhGjB9BZ2VyLUJpZXJuYWNraS1EYW52eSMzODU1MUEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOFUaxDwoygAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAEQWdlcgAQAAgAAME0fl0AAAARAAgAAMQ8YQoAAAABABAAOEaMAC2RPwADR6wAAGvYAAIAPU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpBZ2VyOkFnZXItQmllcm5hY2tpLURhbnZ5IzM4NTUxQS5wZGYAAA4AvgBeAEEAZwBlAHIALQBCAGkAZQByAG4AYQBjAGsAaQAtAEQAYQBuAHYAeQAgAC0AIABBACAARgB1AG4AYwB0AGkAbwBuAGEAbAAgAEMAbwByAHIAZQBzAHAAbwBuAGQAZQBuAGMAZQAgAGIAZQB0AHcAZQBlAG4AIABFAHYAYQBsAHUAYQB0AG8AcgBzACAAYQBuAGQAIABBAGIAcwB0AHIAYQBjAHQAIAAoADIAMAAwADMAYQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHdVc2Vycy9qZXJlbXkvUGFwZXJzL0FnZXIvQWdlci1CaWVybmFja2ktRGFudnkgLSBBIEZ1bmN0aW9uYWwgQ29ycmVzcG9uZGVuY2UgYmV0d2VlbiBFdmFsdWF0b3JzIGFuZCBBYnN0cmFjdCAoMjAwM2EpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBHQEiASoDlgOYA50DpgOxA7UDwwPKA9MD2APbAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA+g=}}

@techreport{Ager:A-Functional:2004,
	Address = {Aarhus, Denmark},
	Author = {Mads Sig Ager and Olivier Danvy and Jan Midtgaard},
	Date-Added = {2008-04-29 01:22:41 -0400},
	Date-Modified = {2008-04-29 01:25:57 -0400},
	Institution = {DAIMI, Department of Computer Science, University of Aarhus},
	Issn = {0909-0878},
	Month = {February},
	Number = {BRICS RS-04-3},
	Title = {A Functional Correspondence between Call-by-Need Evaluators and Lazy Abstract Machines},
	Type = {Technical Report},
	Year = {2004},
	Abstract = {We bridge the gap between compositional evaluators and abstract machines for the lambda-calculus, using closure conversion, transformation into continuation-passing style, and defunctionalization of continuations. This article is a followup of our article at PPDP 2003, where we consider call by name and call by value. Here, however, we consider call by need.

We derive a lazy abstract machine from an ordinary call-by-need evaluator that threads a heap of updatable cells. In this resulting abstract machine, the continuation fragment for updating a heap cell naturally appears as an `update marker', an implementation technique that was invented for the Three Instruction Machine and subsequently used to construct lazy variants of Krivine's abstract machine. Tuning the evaluator leads to other implementation techniques such as unboxed values. The correctness of the resulting abstract machines is a corollary of the correctness of the original evaluators and of the program transformations used in the derivation.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEG8uLi8uLi9QYXBlcnMvQWdlci9BZ2VyLURhbnZ5LU1pZHRnYWFyZCAtIEEgRnVuY3Rpb25hbCBDb3JyZXNwb25kZW5jZSBiZXR3ZWVuIENhbGwtYnktTmVlZCBFdmFsdWF0b3JzICgyMDA0KS5wZGbSGw8cHVdOUy5kYXRhTxECZAAAAAACZAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOEaMH0FnZXItRGFudnktTWlkdGdhYXJkIzM4NTUyMS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4VSHEPCjeAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAARBZ2VyABAACAAAwTR+XQAAABEACAAAxDxhHgAAAAEAEAA4RowALZE/AANHrAAAa9gAAgA9T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkFnZXI6QWdlci1EYW52eS1NaWR0Z2FhcmQjMzg1NTIxLnBkZgAADgC8AF0AQQBnAGUAcgAtAEQAYQBuAHYAeQAtAE0AaQBkAHQAZwBhAGEAcgBkACAALQAgAEEAIABGAHUAbgBjAHQAaQBvAG4AYQBsACAAQwBvAHIAcgBlAHMAcABvAG4AZABlAG4AYwBlACAAYgBlAHQAdwBlAGUAbgAgAEMAYQBsAGwALQBiAHkALQBOAGUAZQBkACAARQB2AGEAbAB1AGEAdABvAHIAcwAgACgAMgAwADAANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHZVc2Vycy9qZXJlbXkvUGFwZXJzL0FnZXIvQWdlci1EYW52eS1NaWR0Z2FhcmQgLSBBIEZ1bmN0aW9uYWwgQ29ycmVzcG9uZGVuY2UgYmV0d2VlbiBDYWxsLWJ5LU5lZWQgRXZhbHVhdG9ycyAoMjAwNCkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARwBIQEpA5EDkwOYA6EDrAOwA74DxQPOA9MD1gAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAPj}}

@techreport{Ager:From:2003,
	Address = {Aarhus, Denmark},
	Author = {Mads Sig Ager and Dariusz Biernacki and Olivier Danvy and Jan Midtgaard},
	Date-Added = {2008-04-29 01:12:41 -0400},
	Date-Modified = {2008-04-29 01:27:22 -0400},
	Institution = {DAIMI, Department of Computer Science, University of Aarhus},
	Issn = {0909-0878},
	Month = {Mar},
	Number = {BRICS RS-03-14},
	Title = {From Interpreter to Compiler and Virtual Machine: {A} Functional Derivation},
	Type = {Technical Report},
	Year = {2003},
	Abstract = {We show how to derive a compiler and a virtual machine from a compositional interpreter. We first illustrate the derivation with two evaluation functions and two normalization functions. We obtain Krivine's machine, Felleisen et al.'s CEK machine, and a generalization of these machines performing strong normalization, which is new. We observe that several existing compilers and virtual machines--e.g., the Categorical Abstract Machine (CAM), Schmidt's VEC machine, and Leroy's Zinc abstract machine--are already in derived form and we present the corresponding interpreter for the CAM and the VEC machine. We also consider Hannan and Miller's CLS machine and Landin's SECD machine.

We derived Krivine's machine via a call-by-name CPS transformation and the CEK machine via a call-by-value CPS transformation. These two derivations hold both for an evaluation function and for a normalization function. They provide a non-trivial illustration of Reynolds's warning about the evaluation order of a meta-language.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGUuLi8uLi9QYXBlcnMvQWdlci9BZ2VyLUJpZXJuYWNraS1EYW52eSAtIEZyb20gSW50ZXJwcmV0ZXIgdG8gQ29tcGlsZXIgYW5kIFZpcnR1YWwgTWFjaGluZTogKDIwMDMpLnBkZtIbDxwdV05TLmRhdGFPEQJGAAAAAAJGAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4RowfQWdlci1CaWVybmFja2ktRGFudnkjMzg1NEU3LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhU58Q8Js8AAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABEFnZXIAEAAIAADBNH5dAAAAEQAIAADEPF8PAAAAAQAQADhGjAAtkT8AA0esAABr2AACAD1PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QWdlcjpBZ2VyLUJpZXJuYWNraS1EYW52eSMzODU0RTcucGRmAAAOAKgAUwBBAGcAZQByAC0AQgBpAGUAcgBuAGEAYwBrAGkALQBEAGEAbgB2AHkAIAAtACAARgByAG8AbQAgAEkAbgB0AGUAcgBwAHIAZQB0AGUAcgAgAHQAbwAgAEMAbwBtAHAAaQBsAGUAcgAgAGEAbgBkACAAVgBpAHIAdAB1AGEAbAAgAE0AYQBjAGgAaQBuAGUALwAgACgAMgAwADAAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGxVc2Vycy9qZXJlbXkvUGFwZXJzL0FnZXIvQWdlci1CaWVybmFja2ktRGFudnkgLSBGcm9tIEludGVycHJldGVyIHRvIENvbXBpbGVyIGFuZCBWaXJ0dWFsIE1hY2hpbmU6ICgyMDAzKS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBEgEXAR8DaQNrA3ADeQOEA4gDlgOdA6YDqwOuAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA7s=}}

@book{Appel:Compiling:1992,
	Address = {New York, NY, USA},
	Author = {Andrew W. Appel},
	Date-Added = {2008-04-28 19:57:06 -0400},
	Date-Modified = {2008-04-28 19:57:07 -0400},
	Isbn = {0-521-41695-7},
	Publisher = {Cambridge University Press},
	Title = {Compiling with continuations},
	Year = {1992}}

@article{Kennedy:Compiling:2007,
	Address = {New York, NY, USA},
	Author = {Andrew Kennedy},
	Date-Added = {2008-04-28 19:55:08 -0400},
	Date-Modified = {2008-04-28 19:55:28 -0400},
	Doi = {http://doi.acm.org/10.1145/1291220.1291179},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {9},
	Pages = {177--190},
	Publisher = {ACM},
	Title = {Compiling with continuations, continued},
	Volume = {42},
	Year = {2007},
	Abstract = {We present a series of CPS-based intermediate languages suitable for functional language compilation, arguing that they have practical benefits over direct-style languages based on $A$-normal form (ANF) or monads. Inlining of functions demonstrates the benefits most clearly: in ANF-based languages, inlining involves a re-normalization step that rearranges let expressions and possibly introduces a new 'join point' function, and in monadic languages, commuting conversions must be applied; in contrast, inlining in our CPS language is a simple substitution of variables for variables.

We present a contification transformation implemented by simple rewrites on the intermediate language. Exceptions are modelled using so-called 'double-barrelled' CPS. Subtyping on exception constructors then gives a very straightforward effect analysis for exceptions. We also show how a graph-based representation of CPS terms can be implemented extremely efficiently, with linear-time term simplification.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFEuLi8uLi9QYXBlcnMvS2VubmVkeS9LZW5uZWR5IC0gQ29tcGlsaW5nIHdpdGggY29udGludWF0aW9ucywgY29udGludWVkICgyMDA3KS5wZGbSGw8cHVdOUy5kYXRhTxECCgAAAAACCgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOFFbH0tlbm5lZHkgLSBDb21waWxpbmcgIzM4NTE1QS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4UVrEO9xkUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdLZW5uZWR5AAAQAAgAAME0fl0AAAARAAgAAMQ8FKQAAAABABAAOFFbAC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpLZW5uZWR5Oktlbm5lZHkgLSBDb21waWxpbmcgIzM4NTE1QS5wZGYADgB6ADwASwBlAG4AbgBlAGQAeQAgAC0AIABDAG8AbQBwAGkAbABpAG4AZwAgAHcAaQB0AGgAIABjAG8AbgB0AGkAbgB1AGEAdABpAG8AbgBzACwAIABjAG8AbgB0AGkAbgB1AGUAZAAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFhVc2Vycy9qZXJlbXkvUGFwZXJzL0tlbm5lZHkvS2VubmVkeSAtIENvbXBpbGluZyB3aXRoIGNvbnRpbnVhdGlvbnMsIGNvbnRpbnVlZCAoMjAwNykucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAP4BAwELAxkDGwMgAykDNAM4A0YDTQNWA1sDXgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANr},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1291220.1291179}}

@article{Plotkin:Call-by-name:1975,
	Author = {Plotkin, Gordon},
	Date-Added = {2008-04-28 16:54:06 -0400},
	Date-Modified = {2008-04-28 16:55:23 -0400},
	Journal = {Theoretical Computer Science},
	Number = {2},
	Pages = {125--159},
	Title = {Call-by-name, call-by-value, and the {$\lambda$}-calculus},
	Volume = {1},
	Year = {1975},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGEuLi8uLi9QYXBlcnMvUGxvdGtpbi9QbG90a2luIC0gQ2FsbC1ieS1uYW1lLCBjYWxsLWJ5LXZhbHVlLCBhbmQgdGhlICRcbGFtYmRhJC1jYWxjdWx1cyAoMTk3NSkucGRm0hsPHB1XTlMuZGF0YU8RAjoAAAAAAjoAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADhOOB9QbG90a2luIC0gQ2FsbC1ieS1uYSMzODRFMDkucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOE4JxDuwblBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAHUGxvdGtpbgAAEAAIAADBNH5dAAAAEQAIAADEO+iuAAAAAQAQADhOOAAtkT8AA0esAABr2AACAEBPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6UGxvdGtpbjpQbG90a2luIC0gQ2FsbC1ieS1uYSMzODRFMDkucGRmAA4AmgBMAFAAbABvAHQAawBpAG4AIAAtACAAQwBhAGwAbAAtAGIAeQAtAG4AYQBtAGUALAAgAGMAYQBsAGwALQBiAHkALQB2AGEAbAB1AGUALAAgAGEAbgBkACAAdABoAGUAIAAkAFwAbABhAG0AYgBkAGEAJAAtAGMAYQBsAGMAdQBsAHUAcwAgACgAMQA5ADcANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGhVc2Vycy9qZXJlbXkvUGFwZXJzL1Bsb3RraW4vUGxvdGtpbiAtIENhbGwtYnktbmFtZSwgY2FsbC1ieS12YWx1ZSwgYW5kIHRoZSAkXGxhbWJkYSQtY2FsY3VsdXMgKDE5NzUpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEOARMBGwNZA1sDYANpA3QDeAOGA40DlgObA54AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqw==}}

@article{Flanagan:The-essence:2004,
	Address = {New York, NY, USA},
	Author = {Cormac Flanagan and Amr Sabry and Bruce F. Duba and Matthias Felleisen},
	Date-Added = {2008-04-28 16:52:22 -0400},
	Date-Modified = {2008-04-28 19:19:56 -0400},
	Doi = {http://doi.acm.org/10.1145/989393.989443},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Note = {Includes a retrospective on the article, which was originally presented at PLDI 1993},
	Number = {4},
	Pages = {502--514},
	Publisher = {ACM},
	Rating = {4},
	Title = {The essence of compiling with continuations},
	Volume = {39},
	Year = {2004},
	Abstract = {In order to simplify the compilation process, many compilers for higher-order languages use the continuation-passing style (CPS) transformation in a first phase to generate an intermediate representation of the source program. The salient aspect of this intermediate form is that all procedures take an argument that represents the rest of the computation (the "continuation"). Since the na{\"\i}ve CPS transformation considerably increases the size of programs, CPS compilers perform reductions to produce a more compact intermediate representation. Although often implemented as a part of the CPS transformation, this step is conceptually a second phase. Finally, code generators for typical CPS compilers treat continuations specially in order to optimize the interpretation of continuation parameters.

A thorough analysis of the abstract machine for CPS terms shows that the actions of the code generator invert the na{\"\i}ve CPS translation step. Put differently, the combined effect of the three phases is equivalent to a source-to-source transformation that simulates the compaction phase. Thus, fully developed CPS compilers do not need to employ the CPS transformation but can achieve the same results with a simple source-level transformation.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGIuLi8uLi9QYXBlcnMvRmxhbmFnYW4vRmxhbmFnYW4tU2FicnktRHViYSAtIFRoZSBlc3NlbmNlIG9mIGNvbXBpbGluZyB3aXRoIGNvbnRpbnVhdGlvbnMgKDIwMDQpLnBkZtIbDxwdV05TLmRhdGFPEQI+AAAAAAI+AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4TkIfRmxhbmFnYW4tU2FicnktRHViYSAjMzg0RTNFLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhOPsQ7shlQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAACEZsYW5hZ2FuABAACAAAwTR+XQAAABEACAAAxDvqWQAAAAEAEAA4TkIALZE/AANHrAAAa9gAAgBBT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkZsYW5hZ2FuOkZsYW5hZ2FuLVNhYnJ5LUR1YmEgIzM4NEUzRS5wZGYAAA4AmgBMAEYAbABhAG4AYQBnAGEAbgAtAFMAYQBiAHIAeQAtAEQAdQBiAGEAIAAtACAAVABoAGUAIABlAHMAcwBlAG4AYwBlACAAbwBmACAAYwBvAG0AcABpAGwAaQBuAGcAIAB3AGkAdABoACAAYwBvAG4AdABpAG4AdQBhAHQAaQBvAG4AcwAgACgAMgAwADAANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGlVc2Vycy9qZXJlbXkvUGFwZXJzL0ZsYW5hZ2FuL0ZsYW5hZ2FuLVNhYnJ5LUR1YmEgLSBUaGUgZXNzZW5jZSBvZiBjb21waWxpbmcgd2l0aCBjb250aW51YXRpb25zICgyMDA0KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQ8BFAEcA14DYANlA24DeQN9A4sDkgObA6ADowAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOw},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/989393.989443}}

@article{Foster:A-theory:1999,
	Address = {New York, NY, USA},
	Author = {Jeffrey S. Foster and Manuel F\"{a}hndrich and Alexander Aiken},
	Date-Added = {2008-04-28 16:51:14 -0400},
	Date-Modified = {2008-04-28 16:51:27 -0400},
	Doi = {http://doi.acm.org/10.1145/301631.301665},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {5},
	Pages = {192--203},
	Publisher = {ACM},
	Title = {A theory of type qualifiers},
	Volume = {34},
	Year = {1999},
	Abstract = {We describe a framework for adding type qualifiers to a language. Type qualifiers encode a simple but highly useful form of subtyping. Our framework extends standard type rules to model the flow of qualifiers through a program, where each qualifier or set of qualifiers comes with additional rules that capture its semantics. Our framework allows types to be polymorphic in the type qualifiers. We present a const-inference system for C as an example application of the framework. We show that for a set of real C programs, many more consts can be used than are actually present in the original code.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFMuLi8uLi9QYXBlcnMvRm9zdGVyL0Zvc3Rlci1GYWhuZHJpY2gtQWlrZW4gLSBBIHRoZW9yeSBvZiB0eXBlIHF1YWxpZmllcnMgKDE5OTkpLnBkZtIbDxwdV05TLmRhdGFPEQIQAAAAAAIQAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4Ti8fRm9zdGVyLUZhaG5kcmljaC1BaWsjMzg0RTFGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhOH8Q7sSRQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABkZvc3RlcgAQAAgAAME0fl0AAAARAAgAAMQ76WQAAAABABAAOE4vAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpGb3N0ZXI6Rm9zdGVyLUZhaG5kcmljaC1BaWsjMzg0RTFGLnBkZgAADgCAAD8ARgBvAHMAdABlAHIALQBGAGEAaABuAGQAcgBpAGMAaAAtAEEAaQBrAGUAbgAgAC0AIABBACAAdABoAGUAbwByAHkAIABvAGYAIAB0AHkAcABlACAAcQB1AGEAbABpAGYAaQBlAHIAcwAgACgAMQA5ADkAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFpVc2Vycy9qZXJlbXkvUGFwZXJzL0Zvc3Rlci9Gb3N0ZXItRmFobmRyaWNoLUFpa2VuIC0gQSB0aGVvcnkgb2YgdHlwZSBxdWFsaWZpZXJzICgxOTk5KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBAAEFAQ0DIQMjAygDMQM8A0ADTgNVA14DYwNmAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA3M=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/301631.301665}}

@article{Hatcliff:Thunks:1997,
	Address = {New York, NY, USA},
	Author = {John Hatcliff and Olivier Danvy},
	Date-Added = {2008-04-28 16:33:55 -0400},
	Date-Modified = {2008-04-28 16:43:52 -0400},
	Doi = {http://dx.doi.org/10.1017/S0956796897002748},
	Issn = {0956-7968},
	Journal = {J. Funct. Program.},
	Number = {3},
	Pages = {303--319},
	Publisher = {Cambridge University Press},
	Title = {Thunks and the $\lambda$-calculus},
	Volume = {7},
	Year = {1997},
	Abstract = {Thirty-five years ago, thunks were used to simulate call-by-name under call-by-value in Algol 60. Twenty years ago, Plotkin presented continuation-based simulations of call-by-name under call-by-value and vice versa in the $\lambda$-calculus. We connect all three of these classical simulations by factorizing the continuation-based call-by-name simulation $\mathcal{C}_n$ with a thunk-based call-by-name simulation $\mathcal{T}$; followed by the continuation-based call-by-value simulation $\mathcal{C}_v$,extended to thunks.

\centerline{\xymatrix{
\Lambda \ar[dr]^{\mathcal{C}_n} 
\ar[r]^{\mathcal{T}} 
& \Lambda_{\text{thunks}} 
\ar[d]^{\mathcal{C}_v}\\
&\Lambda_{\text{CPS}}
}}

We show that $\mathcal{T}$ actually satisfies all of Plotkin's correctness criteria for $\mathcal{C}_n$ (i.e. his Indifference, Simulation and Translation theorems). Furthermore, most of the correctness theorems for $\mathcal{C}_n$ can now be seen as simple corollaries of the corresponding theorems for $\mathcal{C}_v$ and $\mathcal{T}$.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFMuLi8uLi9QYXBlcnMvSGF0Y2xpZmYvSGF0Y2xpZmYtRGFudnkgLSBUaHVua3MgYW5kIHRoZSAkXGxhbWJkYSQtY2FsY3VsdXMgKDE5OTcpLnBkZtIbDxwdV05TLmRhdGFPEQIQAAAAAAIQAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4TdUfSGF0Y2xpZmYtRGFudnkgLSBUaHUjMzg0RDhFLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhNjsQ7qsNQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAACEhhdGNsaWZmABAACAAAwTR+XQAAABEACAAAxDvjAwAAAAEAEAA4TdUALZE/AANHrAAAa9gAAgBBT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkhhdGNsaWZmOkhhdGNsaWZmLURhbnZ5IC0gVGh1IzM4NEQ4RS5wZGYAAA4AfAA9AEgAYQB0AGMAbABpAGYAZgAtAEQAYQBuAHYAeQAgAC0AIABUAGgAdQBuAGsAcwAgAGEAbgBkACAAdABoAGUAIAAkAFwAbABhAG0AYgBkAGEAJAAtAGMAYQBsAGMAdQBsAHUAcwAgACgAMQA5ADkANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFpVc2Vycy9qZXJlbXkvUGFwZXJzL0hhdGNsaWZmL0hhdGNsaWZmLURhbnZ5IC0gVGh1bmtzIGFuZCB0aGUgJFxsYW1iZGEkLWNhbGN1bHVzICgxOTk3KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBAAEFAQ0DIQMjAygDMQM8A0ADTgNVA14DYwNmAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA3M=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1017/S0956796897002748}}

@inproceedings{Bergin:Teaching:1993,
	Address = {New York, NY, USA},
	Author = {John Bergin and Stuart Greenfield},
	Booktitle = {SIGCSE '93: Proceedings of the twenty-fourth SIGCSE technical symposium on Computer science education},
	Date-Added = {2008-04-28 16:33:55 -0400},
	Date-Modified = {2008-04-28 16:33:56 -0400},
	Doi = {http://doi.acm.org/10.1145/169070.169083},
	Isbn = {0-89791-565-8},
	Location = {Indianapolis, Indiana, United States},
	Pages = {10--14},
	Publisher = {ACM},
	Title = {Teaching parameter passing by example using thunks in C and C++},
	Year = {1993},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEF4uLi8uLi9QYXBlcnMvQmVyZ2luL0Jlcmdpbi1HcmVlbmZpZWxkIC0gVGVhY2hpbmcgcGFyYW1ldGVyIHBhc3NpbmcgYnkgZXhhbXBsZSB1c2luZyAoMTk5MykucGRm0hsPHB1XTlMuZGF0YU8RAjIAAAAAAjIAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADhN1B9CZXJnaW4tR3JlZW5maWVsZCAtICMzODREOTUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOE2VxDuq6lBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGQmVyZ2luABAACAAAwTR+XQAAABEACAAAxDvjKgAAAAEAEAA4TdQALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkJlcmdpbjpCZXJnaW4tR3JlZW5maWVsZCAtICMzODREOTUucGRmAAAOAJYASgBCAGUAcgBnAGkAbgAtAEcAcgBlAGUAbgBmAGkAZQBsAGQAIAAtACAAVABlAGEAYwBoAGkAbgBnACAAcABhAHIAYQBtAGUAdABlAHIAIABwAGEAcwBzAGkAbgBnACAAYgB5ACAAZQB4AGEAbQBwAGwAZQAgAHUAcwBpAG4AZwAgACgAMQA5ADkAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGVVc2Vycy9qZXJlbXkvUGFwZXJzL0Jlcmdpbi9CZXJnaW4tR3JlZW5maWVsZCAtIFRlYWNoaW5nIHBhcmFtZXRlciBwYXNzaW5nIGJ5IGV4YW1wbGUgdXNpbmcgKDE5OTMpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBCwEQARgDTgNQA1UDXgNpA20DewOCA4sDkAOTAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA6A=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/169070.169083}}

@article{Ingerman:Thunks:1961,
	Address = {New York, NY, USA},
	Author = {P. Z. Ingerman},
	Date-Added = {2008-04-28 16:33:55 -0400},
	Date-Modified = {2008-04-28 16:37:14 -0400},
	Doi = {http://doi.acm.org/10.1145/366062.366084},
	Issn = {0001-0782},
	Journal = {Commun. ACM},
	Number = {1},
	Pages = {55--58},
	Publisher = {ACM},
	Title = {Thunks: a way of compiling procedure statements with some comments on procedure declarations},
	Volume = {4},
	Year = {1961},
	Abstract = {This paper presents a technique for the implementation of procedure statements, with some comments on the implementation of procedure declarations. It was felt that a solution which had both elegance and mechanizability was more desirable than a brute-force solution. It is to be explicitly understood that this solution is \textit{one} acceptable solution to a problem soluble in many ways.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGAuLi8uLi9QYXBlcnMvSW5nZXJtYW4vSW5nZXJtYW4gLSBUaHVua3M6IGEgd2F5IG9mIGNvbXBpbGluZyBwcm9jZWR1cmUgc3RhdGVtZW50cyB3aXRoICgxOTYxKS5wZGbSGw8cHVdOUy5kYXRhTxECOAAAAAACOAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOE3WH0luZ2VybWFuIC0gVGh1bmtzLyBhIzM4NEQ5Qy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4TZzEO6sbUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAhJbmdlcm1hbgAQAAgAAME0fl0AAAARAAgAAMQ741sAAAABABAAOE3WAC2RPwADR6wAAGvYAAIAQU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpJbmdlcm1hbjpJbmdlcm1hbiAtIFRodW5rcy8gYSMzODREOUMucGRmAAAOAJYASgBJAG4AZwBlAHIAbQBhAG4AIAAtACAAVABoAHUAbgBrAHMALwAgAGEAIAB3AGEAeQAgAG8AZgAgAGMAbwBtAHAAaQBsAGkAbgBnACAAcAByAG8AYwBlAGQAdQByAGUAIABzAHQAYQB0AGUAbQBlAG4AdABzACAAdwBpAHQAaAAgACgAMQA5ADYAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGdVc2Vycy9qZXJlbXkvUGFwZXJzL0luZ2VybWFuL0luZ2VybWFuIC0gVGh1bmtzOiBhIHdheSBvZiBjb21waWxpbmcgcHJvY2VkdXJlIHN0YXRlbWVudHMgd2l0aCAoMTk2MSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgENARIBGgNWA1gDXQNmA3EDdQODA4oDkwOYA5sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/366062.366084}}

@article{Anderson:Compilation:1990,
	Address = {New York, NY, USA},
	Author = {Steven Anderson and Paul Hudak},
	Date-Added = {2008-04-28 16:33:55 -0400},
	Date-Modified = {2008-04-28 16:34:34 -0400},
	Doi = {http://doi.acm.org/10.1145/93548.93561},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Keywords = {optimization},
	Number = {6},
	Pages = {137--149},
	Publisher = {ACM},
	Title = {Compilation of Haskell array comprehensions for scientific computing},
	Volume = {25},
	Year = {1990},
	Abstract = { Monolithic approaches to functional language arrays, such as Haskell array comprehensions, define elements all at once, at the time the array is created, instead of incrementally. Although monolithic arrays are elegant, a naive implementation can be very inefficient. For example, if a compiler does not know whether an element has zero or many definitions, it must compile runtime tests. If a compiler does not know inter-element data dependencies, it must resort to pessimistic strategies such as compiling elements as thunks, or making unnecessary copies when updating an array. Subscript analysis, originally developed for imperative language vectorizing and parallelizing compilers, can be adapted to provide a functional language compiler with the information needed for efficient compilation of monolithic arrays. Our contribution is to develop the number-theoretic basis of subscript analysis with assumptions appropriate to functional arrays, detail the kinds of dependence information subscript analysis can uncover, and apply that dependence information to sequential efficient compilation of functional arrays.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGwuLi8uLi9QYXBlcnMvQW5kZXJzb24vQW5kZXJzb24tSHVkYWsgLSBDb21waWxhdGlvbiBvZiBIYXNrZWxsIGFycmF5IGNvbXByZWhlbnNpb25zIGZvciBzY2llbnRpZmljICgxOTkwKS5wZGbSGw8cHVdOUy5kYXRhTxECXAAAAAACXAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOE3TH0FuZGVyc29uLUh1ZGFrIC0gQ29tIzM4NERBNC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4TaTEO6tAUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAhBbmRlcnNvbgAQAAgAAME0fl0AAAARAAgAAMQ744AAAAABABAAOE3TAC2RPwADR6wAAGvYAAIAQU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpBbmRlcnNvbjpBbmRlcnNvbi1IdWRhayAtIENvbSMzODREQTQucGRmAAAOAK4AVgBBAG4AZABlAHIAcwBvAG4ALQBIAHUAZABhAGsAIAAtACAAQwBvAG0AcABpAGwAYQB0AGkAbwBuACAAbwBmACAASABhAHMAawBlAGwAbAAgAGEAcgByAGEAeQAgAGMAbwBtAHAAcgBlAGgAZQBuAHMAaQBvAG4AcwAgAGYAbwByACAAcwBjAGkAZQBuAHQAaQBmAGkAYwAgACgAMQA5ADkAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHNVc2Vycy9qZXJlbXkvUGFwZXJzL0FuZGVyc29uL0FuZGVyc29uLUh1ZGFrIC0gQ29tcGlsYXRpb24gb2YgSGFza2VsbCBhcnJheSBjb21wcmVoZW5zaW9ucyBmb3Igc2NpZW50aWZpYyAoMTk5MCkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEZAR4BJgOGA4gDjQOWA6EDpQOzA7oDwwPIA8sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAD2A==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/93548.93561}}

@article{Thielecke:Using:1999,
	Address = {Hingham, MA, USA},
	Author = {Hayo Thielecke},
	Date-Added = {2008-04-28 16:33:55 -0400},
	Date-Modified = {2008-04-28 16:33:56 -0400},
	Doi = {http://dx.doi.org/10.1023/A:1010068800499},
	Issn = {1388-3690},
	Journal = {Higher Order Symbol. Comput.},
	Number = {1},
	Pages = {47--73},
	Publisher = {Kluwer Academic Publishers},
	Title = {Using a Continuation Twice and Its Implications for the Expressive Power of call/cc},
	Volume = {12},
	Year = {1999},
	Abstract = {We study the implications for the expressive power of call/cc of upward continuations, specifically the idiom of using a continuation twice. Although such control effects were known to Landin and Reynolds when they invented J and {\tt escape}, the forebears of call/cc, they still act as a conceptual pitfall for some attempts to reason about continuations. We use this idiom to refute some recent conjectures about equivalences in a language with continuations, but no other effects. This shows that first-class continuations as given by call/cc have greater expressive power than one would expect from {\tt goto} or exits.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHAuLi8uLi9QYXBlcnMvVGhpZWxlY2tlL1RoaWVsZWNrZSAtIFVzaW5nIGEgQ29udGludWF0aW9uIFR3aWNlIGFuZCBJdHMgSW1wbGljYXRpb25zIGZvciB0aGUgRXhwcmVzc2l2ZSAoMTk5OSkucGRm0hsPHB1XTlMuZGF0YU8RAmgAAAAAAmgAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADhM3x9UaGllbGVja2UgLSBVc2luZyBhICMzODREQjkucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOE25xDur4gAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAJVGhpZWxlY2tlAAAQAAgAAME0fl0AAAARAAgAAMQ75CIAAAABABAAOEzfAC2RPwADR6wAAGvYAAIAQk9kaW46VXNlcnM6amVyZW15OlBhcGVyczpUaGllbGVja2U6VGhpZWxlY2tlIC0gVXNpbmcgYSAjMzg0REI5LnBkZgAOALQAWQBUAGgAaQBlAGwAZQBjAGsAZQAgAC0AIABVAHMAaQBuAGcAIABhACAAQwBvAG4AdABpAG4AdQBhAHQAaQBvAG4AIABUAHcAaQBjAGUAIABhAG4AZAAgAEkAdABzACAASQBtAHAAbABpAGMAYQB0AGkAbwBuAHMAIABmAG8AcgAgAHQAaABlACAARQB4AHAAcgBlAHMAcwBpAHYAZQAgACgAMQA5ADkAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHdVc2Vycy9qZXJlbXkvUGFwZXJzL1RoaWVsZWNrZS9UaGllbGVja2UgLSBVc2luZyBhIENvbnRpbnVhdGlvbiBUd2ljZSBhbmQgSXRzIEltcGxpY2F0aW9ucyBmb3IgdGhlIEV4cHJlc3NpdmUgKDE5OTkpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBHQEiASoDlgOYA50DpgOxA7UDwwPKA9MD2APbAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA+g=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1023/A:1010068800499}}

@article{Sangiorgi:From:1999,
	Address = {New York, NY, USA},
	Author = {Davide Sangiorgi},
	Date-Added = {2008-04-28 16:33:55 -0400},
	Date-Modified = {2008-04-28 16:33:56 -0400},
	Doi = {http://dx.doi.org/10.1017/S0960129599002881},
	Issn = {0960-1295},
	Journal = {Mathematical. Structures in Comp. Sci.},
	Number = {4},
	Pages = {367--401},
	Publisher = {Cambridge University Press},
	Title = {From $\lambda$ to $\pi$; or, Rediscovering continuations},
	Volume = {9},
	Year = {1999},
	Abstract = {We study the relationship between the encodings of the $\lambda$-calculus into $\pi$-calculus, the Continuation Passing Style (CPS) transforms, and the compilation of the Higher-Order $\pi$-calculus (HO$\pi$) into $\pi$-calculus. We factorise the $\pi$-calculus encodings of (untyped as well as simply-typed) call-by-name and call-by-value $\lambda$-calculus into three steps: a CPS transform, the inclusion of CPS terms into HO$\pi$ and the compilation from HO$\pi$ to $\pi$-calculus. The factorisations are used both to derive the encodings and to prove their correctness.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGYuLi8uLi9QYXBlcnMvU2FuZ2lvcmdpL1Nhbmdpb3JnaSAtIEZyb20gJFxsYW1iZGEkIHRvICRccGkkOyBvciwgUmVkaXNjb3ZlcmluZyBjb250aW51YXRpb25zICgxOTk5KS5wZGbSGw8cHVdOUy5kYXRhTxECSgAAAAACSgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOE3XH1Nhbmdpb3JnaSAtIEZyb20gJFxsIzM4NERCRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4Tb/EO6vrUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAlTYW5naW9yZ2kAABAACAAAwTR+XQAAABEACAAAxDvkKwAAAAEAEAA4TdcALZE/AANHrAAAa9gAAgBCT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlNhbmdpb3JnaTpTYW5naW9yZ2kgLSBGcm9tICRcbCMzODREQkYucGRmAA4AoABPAFMAYQBuAGcAaQBvAHIAZwBpACAALQAgAEYAcgBvAG0AIAAkAFwAbABhAG0AYgBkAGEAJAAgAHQAbwAgACQAXABwAGkAJAA7ACAAbwByACwAIABSAGUAZABpAHMAYwBvAHYAZQByAGkAbgBnACAAYwBvAG4AdABpAG4AdQBhAHQAaQBvAG4AcwAgACgAMQA5ADkAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG1Vc2Vycy9qZXJlbXkvUGFwZXJzL1Nhbmdpb3JnaS9TYW5naW9yZ2kgLSBGcm9tICRcbGFtYmRhJCB0byAkXHBpJDsgb3IsIFJlZGlzY292ZXJpbmcgY29udGludWF0aW9ucyAoMTk5OSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgETARgBIANuA3ADdQN+A4kDjQObA6IDqwOwA7MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADwA==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1017/S0960129599002881}}

@article{Thielecke:An-Introduction:1998,
	Address = {Hingham, MA, USA},
	Author = {Hayo Thielecke},
	Date-Added = {2008-04-28 15:43:44 -0400},
	Date-Modified = {2008-04-28 15:48:02 -0400},
	Doi = {http://dx.doi.org/10.1023/A:1010060315625},
	Issn = {1388-3690},
	Journal = {Higher Order Symbol. Comput.},
	Number = {2},
	Pages = {117--123},
	Publisher = {Kluwer Academic Publishers},
	Title = {An Introduction to Landin\'s \"A Generalization of Jumps and Labels\"},
	Volume = {11},
	Year = {1998},
	Abstract = {This note introduces Peter Landin`s 1965 technical report ``A Generalization of Jumps and Labels'', which is reprinted in this volume. Its aim is to make that historic paper more accessible to the reader and to help reading it in context. To this end, we explain Landin`s control operator J in more contemporary terms, and we recall Burge`s solution to a technical problem in Landin`s original account.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFvEHMALgAuAC8ALgAuAC8AUABhAHAAZQByAHMALwBUAGgAaQBlAGwAZQBjAGsAZQAvAFQAaABpAGUAbABlAGMAawBlACAALQAgAEEAbgAgAEkAbgB0AHIAbwBkAHUAYwB0AGkAbwBuACAAdABvACAATABhAG4AZABpAG4AXCAYAHMAIABcIBwAQQAgAEcAZQBuAGUAcgBhAGwAaQB6AGEAdABpAG8AbgAgAG8AZgAgAEoAdQBtAHAAcwAgAGEAbgBkACAATABhAGIAZQBsAHMAXCAdACAAKAAxADkAOQA4ACkALgBwAGQAZtIbDxwdV05TLmRhdGFPEQJ2AAAAAAJ2AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4TN8fVGhpZWxlY2tlIC0gQW4gSW50cm8jMzg0QzM4LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhMOMQ7nIUAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAACVRoaWVsZWNrZQAAEAAIAADBNH5dAAAAEQAIAADEO9TFAAAAAQAQADhM3wAtkT8AA0esAABr2AACAEJPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6VGhpZWxlY2tlOlRoaWVsZWNrZSAtIEFuIEludHJvIzM4NEMzOC5wZGYADgC6AFwAVABoAGkAZQBsAGUAYwBrAGUAIAAtACAAQQBuACAASQBuAHQAcgBvAGQAdQBjAHQAaQBvAG4AIAB0AG8AIABMAGEAbgBkAGkAbgBcIBgAcwAgAFwgHABBACAARwBlAG4AZQByAGEAbABpAHoAYQB0AGkAbwBuACAAbwBmACAASgB1AG0AcABzACAAYQBuAGQAIABMAGEAYgBlAGwAcwBcIB0AIAAoADEAOQA5ADgAKQAuAHAAZABmAA8ACgAEAE8AZABpAG4AEgCAVXNlcnMvamVyZW15L1BhcGVycy9UaGllbGVja2UvVGhpZWxlY2tlIC0gQW4gSW50cm9kdWN0aW9uIHRvIExhbmRpblzigJhzIFzigJxBIEdlbmVyYWxpemF0aW9uIG9mIEp1bXBzIGFuZCBMYWJlbHNc4oCdICgxOTk4KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBkwGYAaAEGgQcBCEEKgQ1BDkERwROBFcEXARfAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAABGw=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1023/A:1010060315625}}

@article{Zhang:A-survey:2004,
	Address = {New York, NY, USA},
	Author = {Yingzhou Zhang and Baowen Xu},
	Date-Added = {2008-04-28 15:43:44 -0400},
	Date-Modified = {2008-04-28 15:43:46 -0400},
	Doi = {http://doi.acm.org/10.1145/981009.981013},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {3},
	Pages = {14--30},
	Publisher = {ACM},
	Title = {A survey of semantic description frameworks for programming languages},
	Volume = {39},
	Year = {2004},
	Abstract = {Formal semantic description is significant for design, reasoning and standardization of programming languages, and it plays an important part in the optimization of the compiler. However, compared to the amount of effort that has been made to the research of various semantic frameworks over more than forty years, their actual applications are definitely frustrating. This survey reviews the history of developments on semantic description frame-works for programming languages. It also illustrates features and actual applications of the main frameworks (including operational, deno-tational, axiomatic and hybrid semantics). In some practical aspects, such as comprehensibility, extensibility and applicability, the qualitative comparisons of these frameworks are given distinctly. It suggests that a more popular formal semantic description should behave more elegantly in readability, modularity, abstractness, comparability, reasonability, applicability and tool-support.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGQuLi8uLi9QYXBlcnMvWmhhbmcvWmhhbmctWHUgLSBBIHN1cnZleSBvZiBzZW1hbnRpYyBkZXNjcmlwdGlvbiBmcmFtZXdvcmtzIGZvciBwcm9ncmFtbWluZyAoMjAwNCkucGRm0hsPHB1XTlMuZGF0YU8RAkQAAAAAAkQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADhM4B9aaGFuZy1YdSAtIEEgc3VydmV5ICMzODRDM0UucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOEw+xDucm1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAFWmhhbmcAABAACAAAwTR+XQAAABEACAAAxDvU2wAAAAEAEAA4TOAALZE/AANHrAAAa9gAAgA+T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlpoYW5nOlpoYW5nLVh1IC0gQSBzdXJ2ZXkgIzM4NEMzRS5wZGYADgCkAFEAWgBoAGEAbgBnAC0AWAB1ACAALQAgAEEAIABzAHUAcgB2AGUAeQAgAG8AZgAgAHMAZQBtAGEAbgB0AGkAYwAgAGQAZQBzAGMAcgBpAHAAdABpAG8AbgAgAGYAcgBhAG0AZQB3AG8AcgBrAHMAIABmAG8AcgAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMgAwADAANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGtVc2Vycy9qZXJlbXkvUGFwZXJzL1poYW5nL1poYW5nLVh1IC0gQSBzdXJ2ZXkgb2Ygc2VtYW50aWMgZGVzY3JpcHRpb24gZnJhbWV3b3JrcyBmb3IgcHJvZ3JhbW1pbmcgKDIwMDQpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBEQEWAR4DZgNoA20DdgOBA4UDkwOaA6MDqAOrAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA7g=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/981009.981013}}

@inproceedings{Jagadeesan:Open:2007,
	Address = {New York, NY, USA},
	Author = {Radha Jagadeesan and Corin Pitcher and James Riely},
	Booktitle = {AOSD '07: Proceedings of the 6th international conference on Aspect-oriented software development},
	Date-Added = {2008-04-28 15:43:44 -0400},
	Date-Modified = {2008-04-28 15:43:46 -0400},
	Doi = {http://doi.acm.org/10.1145/1218563.1218577},
	Isbn = {1-59593-615-7},
	Location = {Vancouver, British Columbia, Canada},
	Pages = {107--120},
	Publisher = {ACM},
	Title = {Open bisimulation for aspects},
	Year = {2007},
	Abstract = {We define and study bisimulation for proving contextual equivalence in an aspect extension of the untyped lambda-calculus. To our knowledge, this is the first study of coinductive reasoning principles aimed at proving equality of aspect programs. The language we study is very small, yet powerful enough to encode mutable references and a range of temporal pointcuts (including cflow and regular event patterns).Examples suggest that our bisimulation principle is useful. For an encoding of higher-order programs with state, our methods suffice to establish well-known and well-studied subtle examples involving higher-order functions with state.

Even in the presence of first class dynamic advice and expressive pointcuts, our reasoning principles show that aspect-aware interfaces can aid in ensuring that clients of a component are unaffected by changes to an implementation. Our paper generalizes existing results given for open modules to also include a variety of history-sensitive pointcuts such as cflow and regular event patterns.

Our formal techniques and results suggest that aspects are amenable to the formal techniques developed for stateful higher-order programs.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFsuLi8uLi9QYXBlcnMvSmFnYWRlZXNhbi9KYWdhZGVlc2FuLVBpdGNoZXItUmllbHkgLSBPcGVuIGJpc2ltdWxhdGlvbiBmb3IgYXNwZWN0cyAoMjAwNykucGRm0hsPHB1XTlMuZGF0YU8RAigAAAAAAigAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADhM3R9KYWdhZGVlc2FuLVBpdGNoZXItUiMzODRDNDMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOExDxDuc2VBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAKSmFnYWRlZXNhbgAQAAgAAME0fl0AAAARAAgAAMQ71RkAAAABABAAOEzdAC2RPwADR6wAAGvYAAIAQ09kaW46VXNlcnM6amVyZW15OlBhcGVyczpKYWdhZGVlc2FuOkphZ2FkZWVzYW4tUGl0Y2hlci1SIzM4NEM0My5wZGYAAA4AiABDAEoAYQBnAGEAZABlAGUAcwBhAG4ALQBQAGkAdABjAGgAZQByAC0AUgBpAGUAbAB5ACAALQAgAE8AcABlAG4AIABiAGkAcwBpAG0AdQBsAGEAdABpAG8AbgAgAGYAbwByACAAYQBzAHAAZQBjAHQAcwAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGJVc2Vycy9qZXJlbXkvUGFwZXJzL0phZ2FkZWVzYW4vSmFnYWRlZXNhbi1QaXRjaGVyLVJpZWx5IC0gT3BlbiBiaXNpbXVsYXRpb24gZm9yIGFzcGVjdHMgKDIwMDcpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEIAQ0BFQNBA0MDSANRA1wDYANuA3UDfgODA4YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1218563.1218577}}

@article{Strachey:Fundamental:2000,
	Address = {Hingham, MA, USA},
	Author = {Christopher Strachey},
	Date-Added = {2008-04-28 15:43:44 -0400},
	Date-Modified = {2008-04-28 15:43:46 -0400},
	Issn = {1388-3690},
	Journal = {Higher Order Symbol. Comput.},
	Number = {1-2},
	Pages = {11--49},
	Publisher = {Kluwer Academic Publishers},
	Title = {Fundamental Concepts in Programming Languages},
	Volume = {13},
	Year = {2000},
	Abstract = {This paper forms the substance of a course of lectures given at the International Summer School in Computer Programming at Copenhagen in August, 1967. The lectures were originally given from notes and the paper was written after the course was finished. In spite of this, and only partly because of the shortage of time, the paper still retains many of the shortcomings of a lecture course. The chief of these are an uncertainty of aim---it is never quite clear what sort of audience there will be for such lectures---and an associated switching from formal to informal modes of presentation which may well be less acceptable in print than it is natural in the lecture room. For these (and other) faults, I apologise to the reader.

There are numerous references throughout the course to CPL [1--3]. This is a programming language which has been under development since 1962 at Cambridge and London and Oxford. It has served as a vehicle for research into both programming languages and the design of compilers. Partial implementations exist at Cambridge and London. The language is still evolving so that there is no definitive manual available yet. We hope to reach another resting point in its evolution quite soon and to produce a compiler and reference manuals for this version. The compiler will probably be written in such a way that it is relatively easyto transfer it to another machine, and in the first instance we hope to establish it on three or four machines more or less at the same time.

The lack of a precise formulation for CPL should not cause much difficulty in this course, as we are primarily concerned with the ideas and concepts involved rather than with their precise representation in a programming language.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFkuLi8uLi9QYXBlcnMvU3RyYWNoZXkvU3RyYWNoZXkgLSBGdW5kYW1lbnRhbCBDb25jZXB0cyBpbiBQcm9ncmFtbWluZyBMYW5ndWFnZXMgKDIwMDApLnBkZtIbDxwdV05TLmRhdGFPEQIiAAAAAAIiAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4TN4fU3RyYWNoZXkgLSBGdW5kYW1lbnQjMzg0QzUwLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhMUMQ7nV0AAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAACFN0cmFjaGV5ABAACAAAwTR+XQAAABEACAAAxDvVnQAAAAEAEAA4TN4ALZE/AANHrAAAa9gAAgBBT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlN0cmFjaGV5OlN0cmFjaGV5IC0gRnVuZGFtZW50IzM4NEM1MC5wZGYAAA4AiABDAFMAdAByAGEAYwBoAGUAeQAgAC0AIABGAHUAbgBkAGEAbQBlAG4AdABhAGwAIABDAG8AbgBjAGUAcAB0AHMAIABpAG4AIABQAHIAbwBnAHIAYQBtAG0AaQBuAGcAIABMAGEAbgBnAHUAYQBnAGUAcwAgACgAMgAwADAAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGBVc2Vycy9qZXJlbXkvUGFwZXJzL1N0cmFjaGV5L1N0cmFjaGV5IC0gRnVuZGFtZW50YWwgQ29uY2VwdHMgaW4gUHJvZ3JhbW1pbmcgTGFuZ3VhZ2VzICgyMDAwKS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBBgELARMDOQM7A0ADSQNUA1gDZgNtA3YDewN+AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA4s=}}

@article{Bjorner:Pinnacles:2000,
	Address = {Red Bank, NJ, USA},
	Author = {Dines Bj{\o}rner},
	Date-Added = {2008-04-28 15:43:44 -0400},
	Date-Modified = {2008-04-28 15:47:45 -0400},
	Issn = {1022-7091},
	Journal = {Ann. Softw. Eng.},
	Number = {1-4},
	Pages = {11--66},
	Publisher = {J. C. Baltzer AG, Science Publishers},
	Title = {Pinnacles of software engineering: 25 years of formal methods},
	Volume = {10},
	Year = {2000},
	Abstract = {In this invited paper we review 25 years of propagating formal specification in software engineering. We will do so through outlining a paradigmatic approach to the practice of software engineering. For the sake of contrasting argument we shall claim that this approach stands in sharp contrast to classical engineering -- and that there is little help to be obtained from classical engineering in securing the quality of the most important facets of software engineering!

We shall be outlining a software engineering* practice in which formal techniques are applied in capturing the application domain void of any reference to requirements let alone software; and in then capturing requirements: Domain requirements (projected, instantiated, possibly extended and usually initialised from domain descriptions), interface requirements and machine requirements. The software engineering practice then goes on to design the software: First the architecture, then the program structure, etc. Throughout abstraction and modelling, hand-in-hand, are used in applicative (functional), imperative and process oriented descriptions, from loose specifications towards concrete, instantiated descriptions, using hierarchical as well as configurational modelling, denotational as well as computational modelling, and in structuring even small scale descriptions using appropriate modularisation concepts: Schemes, classes and objects.

All the concepts spelled in this font are software engineering "program" description notions that have been honed over the years, starting in 1973 with VDM [Beki{\'c} et al. 1974; Bj{\o}rner and Jones 1978, 1982b] and continuing with RAISE [Group 1992, 1995]. The current status of our approach to software engineering, based on extensive, but not exclusive use of formal techniques, developed significantly during my years as UN Director of the UN University's International Institute for Software Technology (UNU/IIST) in Macau, 1992--1997. Many large scale software developments based on the domain/requirements/software design paradigm outlined here were systematically applied to the experimental development of software designs for the computing support of a number of diverse infrastructure components**. Special boxes, scattered throughout the text, highlight 'pinnacle' contribution by named computer and computing scientists as well as by specific R&D projects.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFvEF8ALgAuAC8ALgAuAC8AUABhAHAAZQByAHMALwBCAGoA+AByAG4AZQByAC8AQgBqAPgAcgBuAGUAcgAgAC0AIABQAGkAbgBuAGEAYwBsAGUAcwAgAG8AZgAgAHMAbwBmAHQAdwBhAHIAZQAgAGUAbgBnAGkAbgBlAGUAcgBpAG4AZwA6ACAAMgA1ACAAeQBlAGEAcgBzACAAbwBmACAAZgBvAHIAbQBhAGwAIAAoADIAMAAwADAAKQAuAHAAZABm0hsPHB1XTlMuZGF0YU8RAjYAAAAAAjYAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADhM3B9Car9ybmVyIC0gUGlubmFjbGVzICMzODRDNUQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOExdxDudwgAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAHQmq/cm5lcgAAEAAIAADBNH5dAAAAEQAIAADEO9YCAAAAAQAQADhM3AAtkT8AA0esAABr2AACAEBPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6Qmq/cm5lcjpCar9ybmVyIC0gUGlubmFjbGVzICMzODRDNUQucGRmAA4AlgBKAEIAagD4AHIAbgBlAHIAIAAtACAAUABpAG4AbgBhAGMAbABlAHMAIABvAGYAIABzAG8AZgB0AHcAYQByAGUAIABlAG4AZwBpAG4AZQBlAHIAaQBuAGcALwAgADIANQAgAHkAZQBhAHIAcwAgAG8AZgAgAGYAbwByAG0AYQBsACAAKAAyADAAMAAwACkALgBwAGQAZgAPAAoABABPAGQAaQBuABIAaFVzZXJzL2plcmVteS9QYXBlcnMvQmrDuHJuZXIvQmrDuHJuZXIgLSBQaW5uYWNsZXMgb2Ygc29mdHdhcmUgZW5naW5lZXJpbmc6IDI1IHllYXJzIG9mIGZvcm1hbCAoMjAwMCkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAWsBcAF4A7IDtAO5A8IDzQPRA98D5gPvA/QD9wAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAQE}}

@inproceedings{Ennals:Optimistic:2003,
	Address = {New York, NY, USA},
	Author = {Robert Ennals and Peyton Jones, Simon},
	Booktitle = {ICFP '03: Proceedings of the eighth ACM SIGPLAN international conference on Functional programming},
	Date-Added = {2008-04-28 13:38:21 -0400},
	Date-Modified = {2008-04-28 13:38:50 -0400},
	Doi = {http://doi.acm.org/10.1145/944705.944731},
	Isbn = {1-58113-756-7},
	Keywords = {optimization},
	Location = {Uppsala, Sweden},
	Pages = {287--298},
	Publisher = {ACM},
	Title = {Optimistic evaluation: an adaptive evaluation strategy for non-strict programs},
	Year = {2003},
	Abstract = {Lazy programs are beautiful, but they are slow because they build many thunks. Simple measurements show that most of these thunks are unnecessary: they are in fact always evaluated, or are always cheap. In this paper we describe Optimistic Evaluation -- an evaluation strategy that exploits this observation. Optimistic Evaluation complements compile-time analyses with run-time experiments: it evaluates a thunk speculatively, but has an abortion mechanism to back out if it makes a bad choice. A run-time adaption mechanism records expressions found to be unsuitable for speculative evaluation, and arranges for them to be evaluated more lazily in the future.We have implemented optimistic evaluation in the Glasgow Haskell Compiler. The results are encouraging: many programs speed up significantly (5--25\%), some improve dramatically, and none go more than 15% slower.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGsuLi8uLi9QYXBlcnMvRW5uYWxzL0VubmFscy1QZXl0b24gSm9uZXMgLSBPcHRpbWlzdGljIGV2YWx1YXRpb246IGFuIGFkYXB0aXZlIGV2YWx1YXRpb24gc3RyYXRlZ3kgKDIwMDMpLnBkZtIbDxwdV05TLmRhdGFPEQJYAAAAAAJYAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4ShYfRW5uYWxzLVBleXRvbiBKb25lcyAjMzg0OTk2LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhJlsQ7eJ1QREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABkVubmFscwAQAAgAAME0fl0AAAARAAgAAMQ7sN0AAAABABAAOEoWAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpFbm5hbHM6RW5uYWxzLVBleXRvbiBKb25lcyAjMzg0OTk2LnBkZgAADgCwAFcARQBuAG4AYQBsAHMALQBQAGUAeQB0AG8AbgAgAEoAbwBuAGUAcwAgAC0AIABPAHAAdABpAG0AaQBzAHQAaQBjACAAZQB2AGEAbAB1AGEAdABpAG8AbgAvACAAYQBuACAAYQBkAGEAcAB0AGkAdgBlACAAZQB2AGEAbAB1AGEAdABpAG8AbgAgAHMAdAByAGEAdABlAGcAeQAgACgAMgAwADAAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHJVc2Vycy9qZXJlbXkvUGFwZXJzL0VubmFscy9Fbm5hbHMtUGV5dG9uIEpvbmVzIC0gT3B0aW1pc3RpYyBldmFsdWF0aW9uOiBhbiBhZGFwdGl2ZSBldmFsdWF0aW9uIHN0cmF0ZWd5ICgyMDAzKS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBGAEdASUDgQODA4gDkQOcA6ADrgO1A74DwwPGAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA9M=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/944705.944731}}

@article{Henderson:Accurate:2003,
	Address = {New York, NY, USA},
	Author = {Fergus Henderson},
	Date-Added = {2008-04-28 13:38:21 -0400},
	Date-Modified = {2008-04-28 13:38:23 -0400},
	Doi = {http://doi.acm.org/10.1145/773039.512449},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {2 supplement},
	Pages = {150--156},
	Publisher = {ACM},
	Title = {Accurate garbage collection in an uncooperative environment},
	Volume = {38},
	Year = {2003},
	Abstract = {Previous attempts at garbage collection in uncooperative environments have generally used conservative or mostly-conservative approaches. We describe a technique for doing fully type-accurate garbage collection in an uncooperative environment, using a "shadow stack" to link structs of pointer-containing variables, together with the data or code needed to trace them. We have implemented this in the Mercury compiler, which generates C code, and present preliminary performance data on the overheads of this technique. We also show how this technique can be extended to handle multithreaded applications.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGkuLi8uLi9QYXBlcnMvSGVuZGVyc29uL0hlbmRlcnNvbiAtIEFjY3VyYXRlIGdhcmJhZ2UgY29sbGVjdGlvbiBpbiBhbiB1bmNvb3BlcmF0aXZlIGVudmlyb25tZW50ICgyMDAzKS5wZGbSGw8cHVdOUy5kYXRhTxECUgAAAAACUgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOEoXH0hlbmRlcnNvbiAtIEFjY3VyYXRlIzM4NDk5RC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4SZ3EO3jJUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAlIZW5kZXJzb24AABAACAAAwTR+XQAAABEACAAAxDuxCQAAAAEAEAA4ShcALZE/AANHrAAAa9gAAgBCT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkhlbmRlcnNvbjpIZW5kZXJzb24gLSBBY2N1cmF0ZSMzODQ5OUQucGRmAA4ApgBSAEgAZQBuAGQAZQByAHMAbwBuACAALQAgAEEAYwBjAHUAcgBhAHQAZQAgAGcAYQByAGIAYQBnAGUAIABjAG8AbABsAGUAYwB0AGkAbwBuACAAaQBuACAAYQBuACAAdQBuAGMAbwBvAHAAZQByAGEAdABpAHYAZQAgAGUAbgB2AGkAcgBvAG4AbQBlAG4AdAAgACgAMgAwADAAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHBVc2Vycy9qZXJlbXkvUGFwZXJzL0hlbmRlcnNvbi9IZW5kZXJzb24gLSBBY2N1cmF0ZSBnYXJiYWdlIGNvbGxlY3Rpb24gaW4gYW4gdW5jb29wZXJhdGl2ZSBlbnZpcm9ubWVudCAoMjAwMykucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARYBGwEjA3kDewOAA4kDlAOYA6YDrQO2A7sDvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAPL},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/773039.512449}}

@inproceedings{Encina:Formally:2003,
	Address = {New York, NY, USA},
	Author = {Alberto de la Encina and Ricardo Pe\, {n}a},
	Booktitle = {PPDP '03: Proceedings of the 5th ACM SIGPLAN international conference on Principles and practice of declaritive programming},
	Date-Added = {2008-04-28 13:38:21 -0400},
	Date-Modified = {2008-04-30 21:12:14 -0400},
	Doi = {http://doi.acm.org/10.1145/888251.888262},
	Isbn = {1-58113-705-2},
	Location = {Uppsala, Sweden},
	Pages = {102--112},
	Publisher = {ACM},
	Title = {Formally deriving an {STG} machine},
	Year = {2003},
	Abstract = {Starting from P. Sestoft semantics for lazy evaluation, we define a new semantics in which normal forms consist of variables pointing to lambdas or constructions. This is in accordance with the more recent changes in the Spineless Tagless G-machine (STG) machine, where constructions only appear in closures (lambdas only appeared in closures already in previous versions). We prove the equivalence between the new semantics and Sestoft's. Then, a sequence of STG machines are derived, formally proving the correctness of each derivation. The last machine consists of a few imperative instructions and its distance to a conventional language is minimal.

The paper also discusses the differences between the final machine and the actual STG machine implemented in the Glasgow Haskell Compiler.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFQuLi8uLi9QYXBlcnMvRW5jaW5hL0VuY2luYS1SaWNhcmRvIFBlXCAtIEZvcm1hbGx5IGRlcml2aW5nIGFuIFNURyBtYWNoaW5lICgyMDAzKS5wZGbSGw8cHVdOUy5kYXRhTxECFAAAAAACFAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOEoVH0VuY2luYS1SaWNhcmRvIFBlXCAtIzM4NDlBNC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4SaTEO3kDUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZFbmNpbmEAEAAIAADBNH5dAAAAEQAIAADEO7FDAAAAAQAQADhKFQAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6RW5jaW5hOkVuY2luYS1SaWNhcmRvIFBlXCAtIzM4NDlBNC5wZGYAAA4AggBAAEUAbgBjAGkAbgBhAC0AUgBpAGMAYQByAGQAbwAgAFAAZQBcACAALQAgAEYAbwByAG0AYQBsAGwAeQAgAGQAZQByAGkAdgBpAG4AZwAgAGEAbgAgAFMAVABHACAAbQBhAGMAaABpAG4AZQAgACgAMgAwADAAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFtVc2Vycy9qZXJlbXkvUGFwZXJzL0VuY2luYS9FbmNpbmEtUmljYXJkbyBQZVwgLSBGb3JtYWxseSBkZXJpdmluZyBhbiBTVEcgbWFjaGluZSAoMjAwMykucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEBAQYBDgMmAygDLQM2A0EDRQNTA1oDYwNoA2sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADeA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/888251.888262}}

@article{Printezis:GCspy:2002,
	Address = {New York, NY, USA},
	Author = {Tony Printezis and Richard Jones},
	Date-Added = {2008-04-28 13:38:21 -0400},
	Date-Modified = {2008-04-29 01:29:35 -0400},
	Doi = {http://doi.acm.org/10.1145/583854.582451},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {11},
	Pages = {343--358},
	Publisher = {ACM},
	Title = {GCspy: an adaptable heap visualisation framework},
	Volume = {37},
	Year = {2002},
	Abstract = {GCspy is an architectural framework for the collection, transmission, storage and replay of memory management behaviour. It makes new contributions to the understanding of the dynamic memory behaviour of programming languages (and especially object-oriented languages that make heavy demands on the performance of memory managers). GCspy's architecture allows easy incorporation into any memory management system: it is not limited to garbage-collected languages. It requires only small changes to the system in which it is incorporated but provides a simple to use yet powerful data-gathering API. GCspy scales to allow very large heaps to be visualised effectively and efficiently. It allows already-running, local or remote systems to be visualised and those systems to run at full speed outside the points at which data is gathered. GCspy's visualisation tool presents this information in a number of novel ways.Deep understanding of program behaviour is essential to the design of the next generation of garbage collectors and explicit allocators. Until now, no satisfactory tools have been available to assist the implementer in gaining an understanding of heap behaviour. GCspy has been demonstrated to be a practical solution to this dilemma. It has been used to analyse production Java virtual machines running applications of realistic sizes. Its use has revealed important insights into the interaction between application program and JVM and has led to the development of better garbage collectors.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGQuLi8uLi9QYXBlcnMvUHJpbnRlemlzL1ByaW50ZXppcy1Kb25lcyAtIEdDc3B5OiBhbiBhZGFwdGFibGUgaGVhcCB2aXN1YWxpc2F0aW9uIGZyYW1ld29yayAoMjAwMikucGRm0hsPHB1XTlMuZGF0YU8RAkQAAAAAAkQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADhKGR9QcmludGV6aXMtSm9uZXMgLSBHQyMzODQ5QUEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOEmqxDt5J1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAJUHJpbnRlemlzAAAQAAgAAME0fl0AAAARAAgAAMQ7sWcAAAABABAAOEoZAC2RPwADR6wAAGvYAAIAQk9kaW46VXNlcnM6amVyZW15OlBhcGVyczpQcmludGV6aXM6UHJpbnRlemlzLUpvbmVzIC0gR0MjMzg0OUFBLnBkZgAOAJwATQBQAHIAaQBuAHQAZQB6AGkAcwAtAEoAbwBuAGUAcwAgAC0AIABHAEMAcwBwAHkALwAgAGEAbgAgAGEAZABhAHAAdABhAGIAbABlACAAaABlAGEAcAAgAHYAaQBzAHUAYQBsAGkAcwBhAHQAaQBvAG4AIABmAHIAYQBtAGUAdwBvAHIAawAgACgAMgAwADAAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGtVc2Vycy9qZXJlbXkvUGFwZXJzL1ByaW50ZXppcy9QcmludGV6aXMtSm9uZXMgLSBHQ3NweTogYW4gYWRhcHRhYmxlIGhlYXAgdmlzdWFsaXNhdGlvbiBmcmFtZXdvcmsgKDIwMDIpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBEQEWAR4DZgNoA20DdgOBA4UDkwOaA6MDqAOrAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA7g=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/583854.582451}}

@article{Gordon:Typing:2001,
	Address = {New York, NY, USA},
	Author = {Andrew D. Gordon and Don Syme},
	Date-Added = {2008-04-28 13:38:21 -0400},
	Date-Modified = {2008-04-28 13:38:23 -0400},
	Doi = {http://doi.acm.org/10.1145/373243.360228},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {3},
	Pages = {248--260},
	Publisher = {ACM},
	Title = {Typing a multi-language intermediate code},
	Volume = {36},
	Year = {2001},
	Abstract = {The Microsoft .NET Framework is a new computing architecture designed to support a variety of distributed applications and web-based services. .NET software components are typically distributed in an object-oriented intermediate language, Microsoft IL, executed by the Microsoft Common Language Runtime. To allow convenient multi-language working, IL supports a wide variety of high-level language constructs, including class-based objects, inheritance, garbage collection, and a security mechanism based on type safe execution.

This paper precisely describes the type system for a substantial fragment of IL that includes several novel features: certain objects may be allocated either on the heap or on the stack; those on the stack may be boxed onto the heap, and those on the heap may be unboxed onto the stack; methods may receive arguments and return results via typed pointers, which can reference both the stack and the heap, including the interiors of objects on the heap. We present a formal semantics for the fragment. Our typing rules determine well-typed IL instruction sequences that can be assembled and executed. Of particular interest are rules to ensure no pointer into the stack outlives its target. Our main theorem asserts type safety, that well-typed programs in our IL fragment do not lead to untrapped execution errors.

Our main theorem does not directly apply to the product. Still, the formal system of this paper is an abstraction of informal and executable specifications we wrote for the full product during its development. Our informal specification became the basis of the product team's working specification of type-checking. The process of writing this specification, deploying the executable specification as a test oracle, and applying theorem proving techniques, helped us identify several security critical bugs during development.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFYuLi8uLi9QYXBlcnMvR29yZG9uL0dvcmRvbi1TeW1lIC0gVHlwaW5nIGEgbXVsdGktbGFuZ3VhZ2UgaW50ZXJtZWRpYXRlIGNvZGUgKDIwMDEpLnBkZtIbDxwdV05TLmRhdGFPEQIaAAAAAAIaAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4ElofR29yZG9uLVN5bWUgLSBUeXBpbmcjMzg0OUIyLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhJssQ7eZtQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABkdvcmRvbgAQAAgAAME0fl0AAAARAAgAAMQ7sdsAAAABABAAOBJaAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpHb3Jkb246R29yZG9uLVN5bWUgLSBUeXBpbmcjMzg0OUIyLnBkZgAADgCGAEIARwBvAHIAZABvAG4ALQBTAHkAbQBlACAALQAgAFQAeQBwAGkAbgBnACAAYQAgAG0AdQBsAHQAaQAtAGwAYQBuAGcAdQBhAGcAZQAgAGkAbgB0AGUAcgBtAGUAZABpAGEAdABlACAAYwBvAGQAZQAgACgAMgAwADAAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF1Vc2Vycy9qZXJlbXkvUGFwZXJzL0dvcmRvbi9Hb3Jkb24tU3ltZSAtIFR5cGluZyBhIG11bHRpLWxhbmd1YWdlIGludGVybWVkaWF0ZSBjb2RlICgyMDAxKS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQMBCAEQAy4DMAM1Az4DSQNNA1sDYgNrA3ADcwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOA},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/373243.360228}}

@inproceedings{Peyton-Jones:Let-floating:1996,
	Address = {New York, NY, USA},
	Author = {Peyton Jones, Simon and Will Partain and Andr\'{e} Santos},
	Booktitle = {ICFP '96: Proceedings of the first ACM SIGPLAN international conference on Functional programming},
	Date-Added = {2008-04-28 13:38:21 -0400},
	Date-Modified = {2008-04-28 13:40:05 -0400},
	Doi = {http://doi.acm.org/10.1145/232627.232630},
	Isbn = {0-89791-770-7},
	Keywords = {optimization},
	Location = {Philadelphia, Pennsylvania, United States},
	Pages = {1--12},
	Publisher = {ACM},
	Title = {Let-floating: moving bindings to give faster programs},
	Year = {1996},
	Abstract = {Virtually every compiler performs transformations on the program it is compiling in an attempt to improve efficiency. Despite their importance, however, there have been few systematic attempts to categorise such transformations and measure their impact.In this paper we describe a particular group of transformations -- the "let-floating" transformations -- and give detailed measurements of their effect in an optimizing compiler for the non-strict functional language Haskell. Let-floating has not received much explicit attention in the past, but our measurements show that it is an important group of transformations (at least for lazy languages), offering a reduction of more than 30\% in heap allocation and 15\% in execution time.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEG8uLi8uLi9QYXBlcnMvUGV5dG9uIEpvbmVzL1BleXRvbiBKb25lcy1QYXJ0YWluLVNhbnRvcyAtIExldC1mbG9hdGluZzogbW92aW5nIGJpbmRpbmdzIHRvIGdpdmUgZmFzdGVyICgxOTk2KS5wZGbSGw8cHVdOUy5kYXRhTxECZAAAAAACZAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZF6H1BleXRvbiBKb25lcy1QYXJ0YWluIzM4NDlENi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4SdbEO4DbUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAxQZXl0b24gSm9uZXMAEAAIAADBNH5dAAAAEQAIAADEO7kbAAAAAQAQAC2RegAtkT8AA0esAABr2AACAEVPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6UGV5dG9uIEpvbmVzOlBleXRvbiBKb25lcy1QYXJ0YWluIzM4NDlENi5wZGYAAA4ArABVAFAAZQB5AHQAbwBuACAASgBvAG4AZQBzAC0AUABhAHIAdABhAGkAbgAtAFMAYQBuAHQAbwBzACAALQAgAEwAZQB0AC0AZgBsAG8AYQB0AGkAbgBnAC8AIABtAG8AdgBpAG4AZwAgAGIAaQBuAGQAaQBuAGcAcwAgAHQAbwAgAGcAaQB2AGUAIABmAGEAcwB0AGUAcgAgACgAMQA5ADkANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHZVc2Vycy9qZXJlbXkvUGFwZXJzL1BleXRvbiBKb25lcy9QZXl0b24gSm9uZXMtUGFydGFpbi1TYW50b3MgLSBMZXQtZmxvYXRpbmc6IG1vdmluZyBiaW5kaW5ncyB0byBnaXZlIGZhc3RlciAoMTk5NikucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARwBIQEpA5EDkwOYA6EDrAOwA74DxQPOA9MD1gAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAPj},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/232627.232630}}

@article{Ohori:An-Unboxed:1997,
	Address = {Hingham, MA, USA},
	Author = {Atsushi Ohori and Tomonobu Takamizawa},
	Date-Added = {2008-04-28 13:38:21 -0400},
	Date-Modified = {2008-04-28 13:38:22 -0400},
	Doi = {http://dx.doi.org/10.1023/A:1007730624053},
	Issn = {0892-4635},
	Journal = {Lisp Symb. Comput.},
	Number = {1},
	Pages = {61--91},
	Publisher = {Kluwer Academic Publishers},
	Title = {An Unboxed Operational Semantics for ML Polymorphism},
	Volume = {10},
	Year = {1997},
	Abstract = {We present an unboxed operational semantics for an ML-style polymorphic language. Different from the conventional formalisms, the proposed semantics accounts for actual representations of run-time objects of various types, and supports a refined notion of polymorphism that allows polymorphic functions to be applied directly to values of various different representations. In particular, polymorphic functions can receive multi-word constants such as floating-point numbers without requiring them to be ``boxed'' (i.e., heap allocated.) This semantics will serve as an alternative basis for implementing polymorphic languages. The development of the semantics is based on the technique of the type-inference-based compilation for polymorphic record operations [20]. We first develop a lower-level calculus, called a polymorphic unboxed calculus, that accounts for direct manipulation of unboxed values in a polymorphic language. This unboxed calculus supports efficient value binding through integer representation of variables. Different from de Bruijn indexes, our integer representation of a variable corresponds to the actual offset to the value in a run-time environment consisting of objects of various sizes. Polymorphism is supported through an abstraction mechanism over argument sizes. We then develop an algorithm that translates ML into the polymorphic unboxed calculus by using type information obtained through type inference. At the time of polymorphic let binding, the necessary size abstractions are inserted so that a polymorphic function is translated into a function that is polymorphic not only in the type of the argument but also in its size. The ML type system is shown to be sound with respect to the operational semantics realized by the translation.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGUuLi8uLi9QYXBlcnMvT2hvcmkvT2hvcmktVGFrYW1pemF3YSAtIEFuIFVuYm94ZWQgT3BlcmF0aW9uYWwgU2VtYW50aWNzIGZvciBNTCBQb2x5bW9ycGhpc20gKDE5OTcpLnBkZtIbDxwdV05TLmRhdGFPEQJGAAAAAAJGAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4ShgfT2hvcmktVGFrYW1pemF3YSAtIEEjMzg0OUUwLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhJ4MQ7gQZQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABU9ob3JpAAAQAAgAAME0fl0AAAARAAgAAMQ7uUYAAAABABAAOEoYAC2RPwADR6wAAGvYAAIAPk9kaW46VXNlcnM6amVyZW15OlBhcGVyczpPaG9yaTpPaG9yaS1UYWthbWl6YXdhIC0gQSMzODQ5RTAucGRmAA4ApgBSAE8AaABvAHIAaQAtAFQAYQBrAGEAbQBpAHoAYQB3AGEAIAAtACAAQQBuACAAVQBuAGIAbwB4AGUAZAAgAE8AcABlAHIAYQB0AGkAbwBuAGEAbAAgAFMAZQBtAGEAbgB0AGkAYwBzACAAZgBvAHIAIABNAEwAIABQAG8AbAB5AG0AbwByAHAAaABpAHMAbQAgACgAMQA5ADkANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGxVc2Vycy9qZXJlbXkvUGFwZXJzL09ob3JpL09ob3JpLVRha2FtaXphd2EgLSBBbiBVbmJveGVkIE9wZXJhdGlvbmFsIFNlbWFudGljcyBmb3IgTUwgUG9seW1vcnBoaXNtICgxOTk3KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBEgEXAR8DaQNrA3ADeQOEA4gDlgOdA6YDqwOuAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA7s=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1023/A:1007730624053}}

@article{Peyton-Jones:A-transformation-based:1998,
	Address = {Amsterdam, The Netherlands, The Netherlands},
	Author = {Peyton Jones, Simon L. and Andr\'{e} L. M. Santos},
	Date-Added = {2008-04-28 13:38:21 -0400},
	Date-Modified = {2008-04-28 13:39:45 -0400},
	Doi = {http://dx.doi.org/10.1016/S0167-6423(97)00029-4},
	Issn = {0167-6423},
	Journal = {Sci. Comput. Program.},
	Keywords = {optimization},
	Number = {1-3},
	Pages = {3--47},
	Publisher = {Elsevier North-Holland, Inc.},
	Title = {A transformation-based optimiser for Haskell},
	Volume = {32},
	Year = {1998},
	Abstract = {Many compilers do some of their work by means of correctness-preserving, and hopefully performance-improving, program transformations. The Glasgow Haskell Compiler (GHC) takes this idea of ``compilation by transformation'' as its war-cry, trying to express as much as possible of the compilation process in the form of program transformations.

This paper reports on our practical experience of the transformational approach to compilation, in the context of a substantial compiler.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGcuLi8uLi9QYXBlcnMvUGV5dG9uIEpvbmVzL1BleXRvbiBKb25lcy1TYW50b3MgLSBBIHRyYW5zZm9ybWF0aW9uLWJhc2VkIG9wdGltaXNlciBmb3IgSGFza2VsbCAoMTk5OCkucGRm0hsPHB1XTlMuZGF0YU8RAkwAAAAAAkwAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2Reh9QZXl0b24gSm9uZXMtU2FudG9zICMzODQ5RjAucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOEnwxDuBeFBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAMUGV5dG9uIEpvbmVzABAACAAAwTR+XQAAABEACAAAxDu5uAAAAAEAEAAtkXoALZE/AANHrAAAa9gAAgBFT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlBleXRvbiBKb25lczpQZXl0b24gSm9uZXMtU2FudG9zICMzODQ5RjAucGRmAAAOAJwATQBQAGUAeQB0AG8AbgAgAEoAbwBuAGUAcwAtAFMAYQBuAHQAbwBzACAALQAgAEEAIAB0AHIAYQBuAHMAZgBvAHIAbQBhAHQAaQBvAG4ALQBiAGEAcwBlAGQAIABvAHAAdABpAG0AaQBzAGUAcgAgAGYAbwByACAASABhAHMAawBlAGwAbAAgACgAMQA5ADkAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG5Vc2Vycy9qZXJlbXkvUGFwZXJzL1BleXRvbiBKb25lcy9QZXl0b24gSm9uZXMtU2FudG9zIC0gQSB0cmFuc2Zvcm1hdGlvbi1iYXNlZCBvcHRpbWlzZXIgZm9yIEhhc2tlbGwgKDE5OTgpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEUARkBIQNxA3MDeAOBA4wDkAOeA6UDrgOzA7YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADww==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1016/S0167-6423(97)00029-4}}

@inproceedings{Cheadle:Non-stop:2000,
	Address = {New York, NY, USA},
	Author = {A. M. Cheadle and A. J. Field and S. Marlow and S. L. Peyton Jones and R. L. While},
	Booktitle = {ICFP '00: Proceedings of the fifth ACM SIGPLAN international conference on Functional programming},
	Date-Added = {2008-04-28 01:49:03 -0400},
	Date-Modified = {2008-04-30 21:12:14 -0400},
	Doi = {http://doi.acm.org/10.1145/351240.351265},
	Isbn = {1-58113-202-6},
	Pages = {257--267},
	Publisher = {ACM},
	Title = {Non-stop Haskell},
	Year = {2000},
	Abstract = {We describe an efficient technique for incorporating Baker's incremental garbage collection algorithm into the Spineless Tagless G-machine on stock hardware. This algorithm eliminates the stop/go execution associated with bulk copying collection algorithms, allowing the system to place an upper bound on the pauses due to garbage collection. The technique exploits the fact that objects are always accessed by jumping to code rather than being explicitly dereferenced. It works by modifying the entry code-pointer when an object is in the transient state of being evacuated but not scavenged. An attempt to enter it from the mutator causes the object to "self-scavenge" transparently before resetting its entry code pointer. We describe an implementation of the scheme in v4.01 of the Glasgow Haskell Compiler and report performance results obtained by executing a range of applications. These experiments show that the read barrier can be implemented in dynamic dispatching systems such as the STG-machine with very short mutator pause times and with negligible overhead on execution time.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEcuLi8uLi9QYXBlcnMvQ2hlYWRsZS9DaGVhZGxlLUZpZWxkLU1hcmxvdyAtIE5vbi1zdG9wIEhhc2tlbGwgKDIwMDApLnBkZtIbDxwdV05TLmRhdGFPEQHsAAAAAAHsAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4R4gfQ2hlYWRsZS1GaWVsZC1NYXJsb3cjMzg0NkJGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhGv8Q61hJQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAB0NoZWFkbGUAABAACAAAwTR+XQAAABEACAAAxDsOUgAAAAEAEAA4R4gALZE/AANHrAAAa9gAAgBAT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkNoZWFkbGU6Q2hlYWRsZS1GaWVsZC1NYXJsb3cjMzg0NkJGLnBkZgAOAGYAMgBDAGgAZQBhAGQAbABlAC0ARgBpAGUAbABkAC0ATQBhAHIAbABvAHcAIAAtACAATgBvAG4ALQBzAHQAbwBwACAASABhAHMAawBlAGwAbAAgACgAMgAwADAAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAE5Vc2Vycy9qZXJlbXkvUGFwZXJzL0NoZWFkbGUvQ2hlYWRsZS1GaWVsZC1NYXJsb3cgLSBOb24tc3RvcCBIYXNrZWxsICgyMDAwKS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA9AD5AQEC8QLzAvgDAQMMAxADHgMlAy4DMwM2AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA0M=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/351240.351265}}

@article{Mogensen:Glossary:2000,
	Address = {Hingham, MA, USA},
	Author = {Torben \Ae. Mogensen},
	Date-Added = {2008-04-28 01:49:03 -0400},
	Date-Modified = {2008-04-28 01:54:23 -0400},
	Doi = {http://dx.doi.org/10.1023/A:1026551132647},
	Issn = {1388-3690},
	Journal = {Higher Order Symbol. Comput.},
	Keywords = {optimization},
	Number = {4},
	Pages = {355--368},
	Publisher = {Kluwer Academic Publishers},
	Title = {Glossary for Partial Evaluation and Related Topics},
	Volume = {13},
	Year = {2000},
	Abstract = {Most areas of research or work use their own set of words and phrases and gives specific technical meaning to terms that in everyday speech may mean something less specific or something else entirely. The area of partial evaluation and program transformation is no different, which may make it hard for the uninitiated to grasp some parts of technical papers or discussions. This list of words and terms is intended as a help to people new in the subject area, but may also be of help to experienced researchers, as different research groups tend to develop different terminology.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFguLi8uLi9QYXBlcnMvKEVkLikvKEVkLikgLSBHbG9zc2FyeSBmb3IgUGFydGlhbCBFdmFsdWF0aW9uIGFuZCBSZWxhdGVkIFRvcGljcyAoMjAwMCkucGRm0hsPHB1XTlMuZGF0YU8RAiAAAAAAAiAAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADhHlh8oRWQuKSAtIEdsb3NzYXJ5IGZvciMzODQ1QjgucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOEW4xDrOkgAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAFKEVkLikAABAACAAAwTR+XQAAABEACAAAxDsG0gAAAAEAEAA4R5YALZE/AANHrAAAa9gAAgA+T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOihFZC4pOihFZC4pIC0gR2xvc3NhcnkgZm9yIzM4NDVCOC5wZGYADgCMAEUAKABFAGQALgApACAALQAgAEcAbABvAHMAcwBhAHIAeQAgAGYAbwByACAAUABhAHIAdABpAGEAbAAgAEUAdgBhAGwAdQBhAHQAaQBvAG4AIABhAG4AZAAgAFIAZQBsAGEAdABlAGQAIABUAG8AcABpAGMAcwAgACgAMgAwADAAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF9Vc2Vycy9qZXJlbXkvUGFwZXJzLyhFZC4pLyhFZC4pIC0gR2xvc3NhcnkgZm9yIFBhcnRpYWwgRXZhbHVhdGlvbiBhbmQgUmVsYXRlZCBUb3BpY3MgKDIwMDApLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBBQEKARIDNgM4Az0DRgNRA1UDYwNqA3MDeAN7AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA4g=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1023/A:1026551132647}}

@article{Johnsson:Efficient:2004,
	Address = {New York, NY, USA},
	Author = {Thomas Johnsson},
	Date-Added = {2008-04-28 01:49:03 -0400},
	Date-Modified = {2008-04-28 01:49:06 -0400},
	Doi = {http://doi.acm.org/10.1145/989393.989409},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {4},
	Pages = {125--138},
	Publisher = {ACM},
	Title = {Efficient compilation of lazy evaluation},
	Volume = {39},
	Year = {2004},
	Abstract = {This paper describes the principles underlying an efficient implementation of a lazy functional language, compiling to code for ordinary computers. It is based on combinator-like graph reduction: the user defined functions are used as rewrite rules in the graph. Each function is compiled into an instruction sequence for an abstract graph reduction machine, called the G-machine, the code reduces a function application graph to its value. The G-machine instructions are then translated into target code. Speed improvements by almost two orders of magnitude over previous lazy evaluators have been measured; we provide some performance figures.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFQuLi8uLi9QYXBlcnMvSm9obnNzb24vSm9obnNzb24gLSBFZmZpY2llbnQgY29tcGlsYXRpb24gb2YgbGF6eSBldmFsdWF0aW9uICgyMDA0KS5wZGbSGw8cHVdOUy5kYXRhTxECFAAAAAACFAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOEeOH0pvaG5zc29uIC0gRWZmaWNpZW50IzM4NDZDRS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4Rs7EOtaOUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAhKb2huc3NvbgAQAAgAAME0fl0AAAARAAgAAMQ7Ds4AAAABABAAOEeOAC2RPwADR6wAAGvYAAIAQU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpKb2huc3NvbjpKb2huc3NvbiAtIEVmZmljaWVudCMzODQ2Q0UucGRmAAAOAH4APgBKAG8AaABuAHMAcwBvAG4AIAAtACAARQBmAGYAaQBjAGkAZQBuAHQAIABjAG8AbQBwAGkAbABhAHQAaQBvAG4AIABvAGYAIABsAGEAegB5ACAAZQB2AGEAbAB1AGEAdABpAG8AbgAgACgAMgAwADAANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFtVc2Vycy9qZXJlbXkvUGFwZXJzL0pvaG5zc29uL0pvaG5zc29uIC0gRWZmaWNpZW50IGNvbXBpbGF0aW9uIG9mIGxhenkgZXZhbHVhdGlvbiAoMjAwNCkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEBAQYBDgMmAygDLQM2A0EDRQNTA1oDYwNoA2sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADeA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/989393.989409}}

@inproceedings{Maessen:Eager:2002,
	Address = {New York, NY, USA},
	Author = {Jan-Willem Maessen},
	Booktitle = {Haskell '02: Proceedings of the 2002 ACM SIGPLAN workshop on Haskell},
	Date-Added = {2008-04-28 01:49:03 -0400},
	Date-Modified = {2008-04-28 01:49:06 -0400},
	Doi = {http://doi.acm.org/10.1145/581690.581694},
	Isbn = {1-58113-605-6},
	Location = {Pittsburgh, Pennsylvania},
	Pages = {38--50},
	Publisher = {ACM},
	Title = {Eager Haskell: resource-bounded execution yields efficient iteration},
	Year = {2002},
	Abstract = {The advantages of the Haskell programming language are rooted in its clean equational semantics. Those advantages evaporate as soon as programmers try to write simple iterative computations and discover that their code must be annotated with calls to seq in order to overcome space leaks introduced by lazy evaluation. The Eager Haskell compiler executes Haskell programs eagerly by default, i.e., bindings and function arguments are evaluated before bodies. When resource bounds are exceeded, computation falls back and is restarted lazily. By using a hybrid of eager and lazy evaluation, we preserve the semantics of Haskell and yet permit efficient iteration.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFouLi8uLi9QYXBlcnMvTWFlc3Nlbi9NYWVzc2VuIC0gRWFnZXIgSGFza2VsbDogcmVzb3VyY2UtYm91bmRlZCBleGVjdXRpb24geWllbGRzICgyMDAyKS5wZGbSGw8cHVdOUy5kYXRhTxECJgAAAAACJgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOEePH01hZXNzZW4gLSBFYWdlciBIYXNrIzM4NDZDOS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4RsnEOtZwUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdNYWVzc2VuAAAQAAgAAME0fl0AAAARAAgAAMQ7DrAAAAABABAAOEePAC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpNYWVzc2VuOk1hZXNzZW4gLSBFYWdlciBIYXNrIzM4NDZDOS5wZGYADgCMAEUATQBhAGUAcwBzAGUAbgAgAC0AIABFAGEAZwBlAHIAIABIAGEAcwBrAGUAbABsAC8AIAByAGUAcwBvAHUAcgBjAGUALQBiAG8AdQBuAGQAZQBkACAAZQB4AGUAYwB1AHQAaQBvAG4AIAB5AGkAZQBsAGQAcwAgACgAMgAwADAAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGFVc2Vycy9qZXJlbXkvUGFwZXJzL01hZXNzZW4vTWFlc3NlbiAtIEVhZ2VyIEhhc2tlbGw6IHJlc291cmNlLWJvdW5kZWQgZXhlY3V0aW9uIHlpZWxkcyAoMjAwMikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEHAQwBFAM+A0ADRQNOA1kDXQNrA3IDewOAA4MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/581690.581694}}

@article{Chitnis:Rationalized:1993,
	Address = {New York, NY, USA},
	Author = {Sachin V. Chitnis and Manoranjan Satpathy and Sundeep Oberoi},
	Date-Added = {2008-04-28 01:49:03 -0400},
	Date-Modified = {2008-04-28 01:49:06 -0400},
	Doi = {http://doi.acm.org/10.1145/202530.202539},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {3},
	Pages = {94--102},
	Publisher = {ACM},
	Title = {Rationalized three instruction machine},
	Volume = {30},
	Year = {1993},
	Abstract = {The declarative nature of functional programming languages causes many difficulties in their efficient implementation on conventional machines. The problem is much harder when the language has non-strict (lazy) semantics. Abstract machines serve as an intellectual aid in bridging the semantic gap between such languages and the conventional von Neumann architecture. However they become more and more complex with time as efficiency considerations force the instruction set of the machine to grow in size. In this paper we explain the phenomenon in context of the Three Instruction Machine (TIM). We then define a rationalized instruction set for TIM that allows us to view all enhancements to TIM in a uniform way. This instruction set is quite close to RISC instructions and clearly identifies the key operations on closures. Translation of functional programs to our rationalized instruction set opens up scope for various local and global optimizations. We illustrate this by showing how to build control flow graphs and perform optimizations on it. Lazy arguments in functional programs make it hard to predict evaluation order statistically. We define the notion of pseudo-lazy arguments to statically expose the control flow information, wherever possible, for doing better flow analysis.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGAuLi8uLi9QYXBlcnMvQ2hpdG5pcy9DaGl0bmlzLVNhdHBhdGh5LU9iZXJvaSAtIFJhdGlvbmFsaXplZCB0aHJlZSBpbnN0cnVjdGlvbiBtYWNoaW5lICgxOTkzKS5wZGbSGw8cHVdOUy5kYXRhTxECOAAAAAACOAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOEeJH0NoaXRuaXMtU2F0cGF0aHktT2JlIzM4NDZFMi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4RuLEOtfwUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdDaGl0bmlzAAAQAAgAAME0fl0AAAARAAgAAMQ7EDAAAAABABAAOEeJAC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpDaGl0bmlzOkNoaXRuaXMtU2F0cGF0aHktT2JlIzM4NDZFMi5wZGYADgCYAEsAQwBoAGkAdABuAGkAcwAtAFMAYQB0AHAAYQB0AGgAeQAtAE8AYgBlAHIAbwBpACAALQAgAFIAYQB0AGkAbwBuAGEAbABpAHoAZQBkACAAdABoAHIAZQBlACAAaQBuAHMAdAByAHUAYwB0AGkAbwBuACAAbQBhAGMAaABpAG4AZQAgACgAMQA5ADkAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGdVc2Vycy9qZXJlbXkvUGFwZXJzL0NoaXRuaXMvQ2hpdG5pcy1TYXRwYXRoeS1PYmVyb2kgLSBSYXRpb25hbGl6ZWQgdGhyZWUgaW5zdHJ1Y3Rpb24gbWFjaGluZSAoMTk5MykucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgENARIBGgNWA1gDXQNmA3EDdQODA4oDkwOYA5sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/202530.202539}}

@inproceedings{Argo:Improving:1989,
	Address = {New York, NY, USA},
	Author = {Guy Argo},
	Booktitle = {FPCA '89: Proceedings of the fourth international conference on Functional programming languages and computer architecture},
	Date-Added = {2008-04-28 01:49:03 -0400},
	Date-Modified = {2008-04-28 01:49:06 -0400},
	Doi = {http://doi.acm.org/10.1145/99370.99378},
	Isbn = {0-89791-328-0},
	Location = {Imperial College, London, United Kingdom},
	Pages = {100--115},
	Publisher = {ACM},
	Title = {Improving the three instruction machine},
	Year = {1989},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEsuLi8uLi9QYXBlcnMvQXJnby9BcmdvIC0gSW1wcm92aW5nIHRoZSB0aHJlZSBpbnN0cnVjdGlvbiBtYWNoaW5lICgxOTg5KS5wZGbSGw8cHVdOUy5kYXRhTxEB+AAAAAAB+AACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOEeEH0FyZ28gLSBJbXByb3ZpbmcgdGhlIzM4NDc1OC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4R1jEOtvJUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAARBcmdvABAACAAAwTR+XQAAABEACAAAxDsUCQAAAAEAEAA4R4QALZE/AANHrAAAa9gAAgA9T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkFyZ286QXJnbyAtIEltcHJvdmluZyB0aGUjMzg0NzU4LnBkZgAADgB0ADkAQQByAGcAbwAgAC0AIABJAG0AcAByAG8AdgBpAG4AZwAgAHQAaABlACAAdABoAHIAZQBlACAAaQBuAHMAdAByAHUAYwB0AGkAbwBuACAAbQBhAGMAaABpAG4AZQAgACgAMQA5ADgAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFJVc2Vycy9qZXJlbXkvUGFwZXJzL0FyZ28vQXJnbyAtIEltcHJvdmluZyB0aGUgdGhyZWUgaW5zdHJ1Y3Rpb24gbWFjaGluZSAoMTk4OSkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPgA/QEFAwEDAwMIAxEDHAMgAy4DNQM+A0MDRgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANT},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/99370.99378}}

@inproceedings{Burn:The-spineless:1988,
	Address = {New York, NY, USA},
	Author = {G. L. Burn and S. L. Peyton Jones and J. D. Robson},
	Booktitle = {LFP '88: Proceedings of the 1988 ACM conference on LISP and functional programming},
	Date-Added = {2008-04-28 01:49:03 -0400},
	Date-Modified = {2008-04-28 01:49:06 -0400},
	Doi = {http://doi.acm.org/10.1145/62678.62717},
	Isbn = {0-89791-273-X},
	Location = {Snowbird, Utah, United States},
	Pages = {244--258},
	Publisher = {ACM},
	Title = {The spineless G-machine},
	Year = {1988},
	Abstract = { Recent developments in functional language implementations have resulted in the G-machine, a programmed graph-reduction machine. Taking this as a basis, we introduce an optimised method of performing graph reduction, which does not need to build the spine of the expression being reduced. This Spineless G-machine only updates shared expressions, and then only when they have been reduced to weak head normal form. It is thus more efficient than the standard method of performing graph reduction. We begin by outlining the philosophy and key features of the Spineless G-machine, and comparing it with the standard G-machine. Simulation results for the two machines are then presented and discussed. The Spineless G-machine is also compared with Tim, giving a series of transformations by which they can be interconverted. These open up a wide design space for abstract graph reduction machines, which was previously unknown. A full specification of the spineless machine is given in the appendix, together with compilation rules for a simple functional language.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEguLi8uLi9QYXBlcnMvQnVybi9CdXJuLUpvbmVzLVJvYnNvbiAtIFRoZSBzcGluZWxlc3MgRy1tYWNoaW5lICgxOTg4KS5wZGbSGw8cHVdOUy5kYXRhTxEB8AAAAAAB8AACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOEeHH0J1cm4tSm9uZXMtUm9ic29uIC0gIzM4NDZGMC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4RvDEOthwUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAARCdXJuABAACAAAwTR+XQAAABEACAAAxDsQsAAAAAEAEAA4R4cALZE/AANHrAAAa9gAAgA9T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkJ1cm46QnVybi1Kb25lcy1Sb2Jzb24gLSAjMzg0NkYwLnBkZgAADgBuADYAQgB1AHIAbgAtAEoAbwBuAGUAcwAtAFIAbwBiAHMAbwBuACAALQAgAFQAaABlACAAcwBwAGkAbgBlAGwAZQBzAHMAIABHAC0AbQBhAGMAaABpAG4AZQAgACgAMQA5ADgAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAE9Vc2Vycy9qZXJlbXkvUGFwZXJzL0J1cm4vQnVybi1Kb25lcy1Sb2Jzb24gLSBUaGUgc3BpbmVsZXNzIEctbWFjaGluZSAoMTk4OCkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD1APoBAgL2AvgC/QMGAxEDFQMjAyoDMwM4AzsAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADSA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/62678.62717}}

@inproceedings{Hudak:A-combinator-based:1984,
	Address = {New York, NY, USA},
	Author = {Paul Hudak and David Kranz},
	Booktitle = {POPL '84: Proceedings of the 11th ACM SIGACT-SIGPLAN symposium on Principles of programming languages},
	Date-Added = {2008-04-28 01:49:03 -0400},
	Date-Modified = {2008-04-28 01:49:06 -0400},
	Doi = {http://doi.acm.org/10.1145/800017.800523},
	Isbn = {0-89791-125-3},
	Location = {Salt Lake City, Utah, United States},
	Pages = {122--132},
	Publisher = {ACM},
	Title = {A combinator-based compiler for a functional language},
	Year = {1984},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGEuLi8uLi9QYXBlcnMvSHVkYWsvSHVkYWstS3JhbnogLSBBIGNvbWJpbmF0b3ItYmFzZWQgY29tcGlsZXIgZm9yIGEgZnVuY3Rpb25hbCBsYW5ndWFnZSAoMTk4NCkucGRm0hsPHB1XTlMuZGF0YU8RAjoAAAAAAjoAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2ReR9IdWRhay1LcmFueiAtIEEgY29tYiMzODQ2RjQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOEb0xDrYelBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAFSHVkYWsAABAACAAAwTR+XQAAABEACAAAxDsQugAAAAEAEAAtkXkALZE/AANHrAAAa9gAAgA+T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkh1ZGFrOkh1ZGFrLUtyYW56IC0gQSBjb21iIzM4NDZGNC5wZGYADgCeAE4ASAB1AGQAYQBrAC0ASwByAGEAbgB6ACAALQAgAEEAIABjAG8AbQBiAGkAbgBhAHQAbwByAC0AYgBhAHMAZQBkACAAYwBvAG0AcABpAGwAZQByACAAZgBvAHIAIABhACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgAGwAYQBuAGcAdQBhAGcAZQAgACgAMQA5ADgANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGhVc2Vycy9qZXJlbXkvUGFwZXJzL0h1ZGFrL0h1ZGFrLUtyYW56IC0gQSBjb21iaW5hdG9yLWJhc2VkIGNvbXBpbGVyIGZvciBhIGZ1bmN0aW9uYWwgbGFuZ3VhZ2UgKDE5ODQpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEOARMBGwNZA1sDYANpA3QDeAOGA40DlgObA54AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/800017.800523}}

@inproceedings{Fairbairn:TIM::1987,
	Address = {London, UK},
	Author = {John Fairbairn and Stuart Wray},
	Booktitle = {Proc. of a conference on Functional programming languages and computer architecture},
	Date-Added = {2008-04-28 01:49:03 -0400},
	Date-Modified = {2008-04-28 01:49:06 -0400},
	Isbn = {0-387-18317-5},
	Location = {Portland, Oregon, United States},
	Pages = {34--45},
	Publisher = {Springer-Verlag},
	Title = {TIM: A simple, lazy abstract machine to execute supercombinators},
	Year = {1987}}

@inproceedings{Danvy:A-journey:2003,
	Address = {New York, NY, USA},
	Author = {Olivier Danvy},
	Booktitle = {GPCE '03: Proceedings of the 2nd international conference on Generative programming and component engineering},
	Date-Added = {2008-04-28 01:49:03 -0400},
	Date-Modified = {2008-04-28 01:49:06 -0400},
	Isbn = {3-540-20102-5},
	Location = {Erfurt, Germany},
	Pages = {117--117},
	Publisher = {Springer-Verlag New York, Inc.},
	Title = {A journey from interpreters to compilers and virtual machines},
	Year = {2003},
	Abstract = {We review a simple sequence of steps to stage a programming-language interpreter into a compiler and virtual machine. We illustrate the applicability of this derivation with a number of existing virtual machines, mostly for functional languages. We then outline its relevance for today's language development [5].The work is joint with Mads Sig Ager, Dariusz Biernacki, and Jan Midtgaard [1-4].},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFouLi8uLi9QYXBlcnMvRGFudnkvRGFudnkgLSBBIGpvdXJuZXkgZnJvbSBpbnRlcnByZXRlcnMgdG8gY29tcGlsZXJzIGFuZCB2aXJ0dWFsICgyMDAzKS5wZGbSGw8cHVdOUy5kYXRhTxECJgAAAAACJgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOEeKH0RhbnZ5IC0gQSBqb3VybmV5IGZyIzM4NDcyNC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4RyTEOtotUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVEYW52eQAAEAAIAADBNH5dAAAAEQAIAADEOxJtAAAAAQAQADhHigAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6RGFudnk6RGFudnkgLSBBIGpvdXJuZXkgZnIjMzg0NzI0LnBkZgAOAJAARwBEAGEAbgB2AHkAIAAtACAAQQAgAGoAbwB1AHIAbgBlAHkAIABmAHIAbwBtACAAaQBuAHQAZQByAHAAcgBlAHQAZQByAHMAIAB0AG8AIABjAG8AbQBwAGkAbABlAHIAcwAgAGEAbgBkACAAdgBpAHIAdAB1AGEAbAAgACgAMgAwADAAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGFVc2Vycy9qZXJlbXkvUGFwZXJzL0RhbnZ5L0RhbnZ5IC0gQSBqb3VybmV5IGZyb20gaW50ZXJwcmV0ZXJzIHRvIGNvbXBpbGVycyBhbmQgdmlydHVhbCAoMjAwMykucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEHAQwBFAM+A0ADRQNOA1kDXQNrA3IDewOAA4MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkA==}}

@article{Gustavsson:A-type:1999,
	Address = {New York, NY, USA},
	Author = {J{\"{o}}rgen Gustavsson},
	Date-Added = {2008-04-28 01:49:03 -0400},
	Date-Modified = {2008-04-28 01:54:23 -0400},
	Doi = {http://doi.acm.org/10.1145/291251.289427},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Keywords = {optimization},
	Number = {1},
	Pages = {39--50},
	Publisher = {ACM},
	Title = {A type based sharing analysis for update avoidance and optimisation},
	Volume = {34},
	Year = {1999},
	Abstract = {Sharing of evaluation is crucial for the efficiency of lazy functional languages, but unfortunately the machinery to implement it carries an inherent overhead. In abstract machines this overhead shows up as the cost of performing updates, many of them actually unnecessary, and also in the cost of the associated bookkeeping, that is keeping track of when and where to update. In spineless abstract machines, such as the STG-machine and the TIM, this bookkeeping consists of pushing, checking for and popping update markers. Checking for update markers is a very frequent operation and indeed the implementation of the STG-machine has been optimised for fast update marker checks at the expense of making the pushing and popping of update markers more costly.In this paper we present a type based sharing analysis that can determine when updates can be safely omitted and marker checks bypassed. The type system is proved sound with respect to the lazy Krivine machine. We have implemented the analysis and the preliminary benchmarks seem very promising. Most notably, virtually all update marker checks can be avoided. This may make the tradeoffs of current implementations obsolete and calls for new abstract machine designs.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFguLi8uLi9QYXBlcnMvR3VzdGF2c3Nvbi9HdXN0YXZzc29uIC0gQSB0eXBlIGJhc2VkIHNoYXJpbmcgYW5hbHlzaXMgZm9yIHVwZGF0ZSAoMTk5OSkucGRm0hsPHB1XTlMuZGF0YU8RAiAAAAAAAiAAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADhHix9HdXN0YXZzc29uIC0gQSB0eXBlICMzODQ3MkEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOEcqxDraUlBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAKR3VzdGF2c3NvbgAQAAgAAME0fl0AAAARAAgAAMQ7EpIAAAABABAAOEeLAC2RPwADR6wAAGvYAAIAQ09kaW46VXNlcnM6amVyZW15OlBhcGVyczpHdXN0YXZzc29uOkd1c3RhdnNzb24gLSBBIHR5cGUgIzM4NDcyQS5wZGYAAA4AggBAAEcAdQBzAHQAYQB2AHMAcwBvAG4AIAAtACAAQQAgAHQAeQBwAGUAIABiAGEAcwBlAGQAIABzAGgAYQByAGkAbgBnACAAYQBuAGEAbAB5AHMAaQBzACAAZgBvAHIAIAB1AHAAZABhAHQAZQAgACgAMQA5ADkAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF9Vc2Vycy9qZXJlbXkvUGFwZXJzL0d1c3RhdnNzb24vR3VzdGF2c3NvbiAtIEEgdHlwZSBiYXNlZCBzaGFyaW5nIGFuYWx5c2lzIGZvciB1cGRhdGUgKDE5OTkpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBBQEKARIDNgM4Az0DRgNRA1UDYwNqA3MDeAN7AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA4g=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/291251.289427}}

@inproceedings{Ager:A-functional:2003,
	Address = {New York, NY, USA},
	Author = {Mads Sig Ager and Dariusz Biernacki and Olivier Danvy and Jan Midtgaard},
	Booktitle = {PPDP '03: Proceedings of the 5th ACM SIGPLAN international conference on Principles and practice of declaritive programming},
	Date-Added = {2008-04-28 01:49:03 -0400},
	Date-Modified = {2008-04-28 01:51:52 -0400},
	Doi = {http://doi.acm.org/10.1145/888251.888254},
	Isbn = {1-58113-705-2},
	Location = {Uppsala, Sweden},
	Pages = {8--19},
	Publisher = {ACM},
	Title = {A functional correspondence between evaluators and abstract machines},
	Year = {2003},
	Abstract = {We bridge the gap between functional evaluators and abstract machines for the $\lambda$-calculus, using closure conversion, transformation into continuation-passing style, and defunctionalization.

We illustrate this approach by deriving Krivine's abstract machine from an ordinary call-by-name evaluator and by deriving an ordinary call-by-value evaluator from Felleisen et al.'s CEK machine. The first derivation is strikingly simpler than what can be found in the literature. The second one is new. Together, they show that Krivine's abstract machine and the CEK machine correspond to the call-by-name and call-by-value facets of an ordinary evaluator for the $\lambda$-calculus.

We then reveal the denotational content of Hannan and Miller's CLS machine and of Landin's SECD machine. We formally compare the corresponding evaluators and we illustrate some degrees of freedom in the design spaces of evaluators and of abstract machines for the $\lambda$-calculus with computational effects.

Finally, we consider the Categorical Abstract Machine and the extent to which it is more of a virtual machine than an abstract machine.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEG8uLi8uLi9QYXBlcnMvQWdlci9BZ2VyLUJpZXJuYWNraS1EYW52eSAtIEEgZnVuY3Rpb25hbCBjb3JyZXNwb25kZW5jZSBiZXR3ZWVuIGV2YWx1YXRvcnMgYW5kIGFic3RyYWN0ICgyMDAzKS5wZGbSGw8cHVdOUy5kYXRhTxECZAAAAAACZAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOEaMH0FnZXItQmllcm5hY2tpLURhbnZ5IzJEMEQyRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtDS/DgnKYAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAARBZ2VyABAACAAAwTR+XQAAABEACAAAw4K46AAAAAEAEAA4RowALZE/AANHrAAAa9gAAgA9T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkFnZXI6QWdlci1CaWVybmFja2ktRGFudnkjMkQwRDJGLnBkZgAADgC8AF0AQQBnAGUAcgAtAEIAaQBlAHIAbgBhAGMAawBpAC0ARABhAG4AdgB5ACAALQAgAEEAIABmAHUAbgBjAHQAaQBvAG4AYQBsACAAYwBvAHIAcgBlAHMAcABvAG4AZABlAG4AYwBlACAAYgBlAHQAdwBlAGUAbgAgAGUAdgBhAGwAdQBhAHQAbwByAHMAIABhAG4AZAAgAGEAYgBzAHQAcgBhAGMAdAAgACgAMgAwADAAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHZVc2Vycy9qZXJlbXkvUGFwZXJzL0FnZXIvQWdlci1CaWVybmFja2ktRGFudnkgLSBBIGZ1bmN0aW9uYWwgY29ycmVzcG9uZGVuY2UgYmV0d2VlbiBldmFsdWF0b3JzIGFuZCBhYnN0cmFjdCAoMjAwMykucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARwBIQEpA5EDkwOYA6EDrAOwA74DxQPOA9MD1gAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAPj},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/888251.888254}}

@article{Douence:The-next:2007,
	Address = {Hingham, MA, USA},
	Author = {R\'{e}mi Douence and Pascal Fradet},
	Date-Added = {2008-04-28 01:49:03 -0400},
	Date-Modified = {2008-04-28 01:52:30 -0400},
	Doi = {http://dx.doi.org/10.1007/s10990-007-9016-y},
	Issn = {1388-3690},
	Journal = {Higher Order Symbol. Comput.},
	Number = {3},
	Pages = {237--255},
	Publisher = {Kluwer Academic Publishers},
	Title = {The next 700 {K}rivine machines},
	Volume = {20},
	Year = {2007},
	Abstract = {The Krivine machine is a simple and natural implementation of the normal weak-head reduction strategy for pure $\lambda$-terms. While its original description has remained unpublished, this machine has served as a basis for many variants, extensions and theoretical studies. In this paper, we present the Krivine machine and some well-known variants in a common framework. Our framework consists of a hierarchy of intermediate languages that are subsets of the $\lambda$-calculus. The whole implementation process (compiler + abstract machine) is described via a sequence of transformations all of which express an implementation choice. We characterize the essence of the Krivine machine and locate it in the design space of functional language implementations. We show that, even within the particular class of Krivine machines, hundreds of variants can be designed.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE4uLi8uLi9QYXBlcnMvRG91ZW5jZS9Eb3VlbmNlLUZyYWRldCAtIFRoZSBuZXh0IDcwMCBLcml2aW5lIG1hY2hpbmVzICgyMDA3KS5wZGbSGw8cHVdOUy5kYXRhTxECAgAAAAACAgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZNJH0RvdWVuY2UtRnJhZGV0IC0gVGhlIzM4NDczRC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4Rz3EOtrTUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdEb3VlbmNlAAAQAAgAAME0fl0AAAARAAgAAMQ7ExMAAAABABAALZNJAC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpEb3VlbmNlOkRvdWVuY2UtRnJhZGV0IC0gVGhlIzM4NDczRC5wZGYADgB0ADkARABvAHUAZQBuAGMAZQAtAEYAcgBhAGQAZQB0ACAALQAgAFQAaABlACAAbgBlAHgAdAAgADcAMAAwACAASwByAGkAdgBpAG4AZQAgAG0AYQBjAGgAaQBuAGUAcwAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFVVc2Vycy9qZXJlbXkvUGFwZXJzL0RvdWVuY2UvRG91ZW5jZS1GcmFkZXQgLSBUaGUgbmV4dCA3MDAgS3JpdmluZSBtYWNoaW5lcyAoMjAwNykucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD7AQABCAMOAxADFQMeAykDLQM7A0IDSwNQA1MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADYA==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/s10990-007-9016-y}}

@article{Biernacka:A-concrete:2007,
	Address = {New York, NY, USA},
	Author = {Ma\lgorzata Biernacka and Olivier Danvy},
	Date-Added = {2008-04-28 01:49:03 -0400},
	Date-Modified = {2008-04-28 01:49:06 -0400},
	Doi = {http://doi.acm.org/10.1145/1297658.1297664},
	Issn = {1529-3785},
	Journal = {ACM Trans. Comput. Logic},
	Number = {1},
	Pages = {6},
	Publisher = {ACM},
	Title = {A concrete framework for environment machines},
	Volume = {9},
	Year = {2007},
	Abstract = {We materialize the common understanding that calculi with explicit substitutions provide an intermediate step between an abstract specification of substitution in the lambda-calculus and its concrete implementations. To this end, we go back to Curien's original calculus of closures (an early calculus with explicit substitutions), we extend it minimally so that it can also express one-step reduction strategies, and we methodically derive a series of environment machines from the specification of two one-step reduction strategies for the lambda-calculus: normal order and applicative order. The derivation extends Danvy and Nielsen's refocusing-based construction of abstract machines with two new steps: one for coalescing two successive transitions into one, and the other for unfolding a closure into a term and an environment in the resulting abstract machine. The resulting environment machines include both the Krivine machine and the original version of Krivine's machine, Felleisen et al.'s CEK machine, and Leroy's Zinc abstract machine.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGEuLi8uLi9QYXBlcnMvQmllcm5hY2thL0JpZXJuYWNrYS1EYW52eSAtIEEgY29uY3JldGUgZnJhbWV3b3JrIGZvciBlbnZpcm9ubWVudCBtYWNoaW5lcyAoMjAwNykucGRm0hsPHB1XTlMuZGF0YU8RAjoAAAAAAjoAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADhHhh9CaWVybmFja2EtRGFudnkgLSBBICMzODQ3NDAucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOEdAxDra3FBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAJQmllcm5hY2thAAAQAAgAAME0fl0AAAARAAgAAMQ7ExwAAAABABAAOEeGAC2RPwADR6wAAGvYAAIAQk9kaW46VXNlcnM6amVyZW15OlBhcGVyczpCaWVybmFja2E6Qmllcm5hY2thLURhbnZ5IC0gQSAjMzg0NzQwLnBkZgAOAJYASgBCAGkAZQByAG4AYQBjAGsAYQAtAEQAYQBuAHYAeQAgAC0AIABBACAAYwBvAG4AYwByAGUAdABlACAAZgByAGEAbQBlAHcAbwByAGsAIABmAG8AcgAgAGUAbgB2AGkAcgBvAG4AbQBlAG4AdAAgAG0AYQBjAGgAaQBuAGUAcwAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGhVc2Vycy9qZXJlbXkvUGFwZXJzL0JpZXJuYWNrYS9CaWVybmFja2EtRGFudnkgLSBBIGNvbmNyZXRlIGZyYW1ld29yayBmb3IgZW52aXJvbm1lbnQgbWFjaGluZXMgKDIwMDcpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEOARMBGwNZA1sDYANpA3QDeAOGA40DlgObA54AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1297658.1297664}}

@article{P.-J.-Koopman:A-fresh:1989,
	Address = {New York, NY, USA},
	Author = {P. J. Koopman, Jr. and P. Lee},
	Date-Added = {2008-04-28 01:49:03 -0400},
	Date-Modified = {2008-04-28 01:49:06 -0400},
	Doi = {http://doi.acm.org/10.1145/74818.74828},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {7},
	Pages = {110--119},
	Publisher = {ACM},
	Title = {A fresh look at combinator graph reduction},
	Volume = {24},
	Year = {1989},
	Abstract = {We present a new abstract machine for graph reduction called TIGRE. Benchmark results show that TIGRE's execution speed compares quite favorably with previous combinator-graph reduction techniques on similar hardware. Furthermore, the mapping of TIGRE onto conventional hardware is simple and efficient. Mainframe implementations of TIGRE provide performance levels exceeding those previously available on custom graph reduction hardware.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGQuLi8uLi9QYXBlcnMvUC4gSi4gS29vcG1hbi9QLiBKLiBLb29wbWFuLUxlZSAtIEEgZnJlc2ggbG9vayBhdCBjb21iaW5hdG9yIGdyYXBoIHJlZHVjdGlvbiAoMTk4OSkucGRm0hsPHB1XTlMuZGF0YU8RAkQAAAAAAkQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADhHkB9QLiBKLiBLb29wbWFuLUxlZSAtICMzODQ3NEIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOEdLxDrbJVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAANUC4gSi4gS29vcG1hbgAAEAAIAADBNH5dAAAAEQAIAADEOxNlAAAAAQAQADhHkAAtkT8AA0esAABr2AACAEZPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6UC4gSi4gS29vcG1hbjpQLiBKLiBLb29wbWFuLUxlZSAtICMzODQ3NEIucGRmAA4AlABJAFAALgAgAEoALgAgAEsAbwBvAHAAbQBhAG4ALQBMAGUAZQAgAC0AIABBACAAZgByAGUAcwBoACAAbABvAG8AawAgAGEAdAAgAGMAbwBtAGIAaQBuAGEAdABvAHIAIABnAHIAYQBwAGgAIAByAGUAZAB1AGMAdABpAG8AbgAgACgAMQA5ADgAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGtVc2Vycy9qZXJlbXkvUGFwZXJzL1AuIEouIEtvb3BtYW4vUC4gSi4gS29vcG1hbi1MZWUgLSBBIGZyZXNoIGxvb2sgYXQgY29tYmluYXRvciBncmFwaCByZWR1Y3Rpb24gKDE5ODkpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBEQEWAR4DZgNoA20DdgOBA4UDkwOaA6MDqAOrAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA7g=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/74818.74828}}

@article{Beemster:Strictness:1994,
	Address = {New York, NY, USA},
	Author = {Marcel Beemster},
	Date-Added = {2008-04-28 01:49:03 -0400},
	Date-Modified = {2008-04-28 01:54:23 -0400},
	Doi = {http://doi.acm.org/10.1145/186025.186040},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Keywords = {optimization},
	Number = {5},
	Pages = {1449--1466},
	Publisher = {ACM},
	Title = {Strictness optimization for graph reduction machines (why id might not be strict)},
	Volume = {16},
	Year = {1994},
	Abstract = {Strictness optimizations in the implementation of lazy functional languages are not always valid. In nonoptimized graph reduction, evaluation always takes place at the request of case analysis or a primitive operation. Hence, the result of a reduction is always a data value and never a function. This implies that in an implementation no argument satisfaction check is required. But in the presence of strict arguments, ``premature'' reduction may take place outside the scope of a case or primitive operation. This causes problems in graph reducers that use an aggressive take. Two solutions are presented, one based on a run-time argument satisfaction check, the other on a weakened strictness analyzer. Experimental results are used to compare the two solutions and show that the cost of the aggressive take can be arbitrarily high for specific programs. The experimental results enable a trade-off to be made by the reduction machine designer.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGAuLi8uLi9QYXBlcnMvQmVlbXN0ZXIvQmVlbXN0ZXIgLSBTdHJpY3RuZXNzIG9wdGltaXphdGlvbiBmb3IgZ3JhcGggcmVkdWN0aW9uIG1hY2hpbmVzICgxOTk0KS5wZGbSGw8cHVdOUy5kYXRhTxECOAAAAAACOAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOEeFH0JlZW1zdGVyIC0gU3RyaWN0bmVzIzM4NDc0RS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4R07EOts0UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAhCZWVtc3RlcgAQAAgAAME0fl0AAAARAAgAAMQ7E3QAAAABABAAOEeFAC2RPwADR6wAAGvYAAIAQU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpCZWVtc3RlcjpCZWVtc3RlciAtIFN0cmljdG5lcyMzODQ3NEUucGRmAAAOAJYASgBCAGUAZQBtAHMAdABlAHIAIAAtACAAUwB0AHIAaQBjAHQAbgBlAHMAcwAgAG8AcAB0AGkAbQBpAHoAYQB0AGkAbwBuACAAZgBvAHIAIABnAHIAYQBwAGgAIAByAGUAZAB1AGMAdABpAG8AbgAgAG0AYQBjAGgAaQBuAGUAcwAgACgAMQA5ADkANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGdVc2Vycy9qZXJlbXkvUGFwZXJzL0JlZW1zdGVyL0JlZW1zdGVyIC0gU3RyaWN0bmVzcyBvcHRpbWl6YXRpb24gZm9yIGdyYXBoIHJlZHVjdGlvbiBtYWNoaW5lcyAoMTk5NCkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgENARIBGgNWA1gDXQNmA3EDdQODA4oDkwOYA5sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/186025.186040}}

@article{Philip-J.-Koopman:Cache:1992,
	Address = {New York, NY, USA},
	Author = {Philip J. Koopman, Jr. and Peter Lee and Daniel P. Siewiorek},
	Date-Added = {2008-04-28 01:49:03 -0400},
	Date-Modified = {2008-04-28 01:49:06 -0400},
	Doi = {http://doi.acm.org/10.1145/128861.128867},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Number = {2},
	Pages = {265--297},
	Publisher = {ACM},
	Title = {Cache behavior of combinator graph reduction},
	Volume = {14},
	Year = {1992},
	Abstract = { The results of cache-simulation experiments with an abstract machine for reducing combinator graphs are presented. The abstract machine, called TIGRE, exhibits reduction rates that, for similar kinds of combinator graphs on similar kinds of hardware, compare favorably with previously reported techniques. Furthermore, TIGRE maps easily and efficiently onto standard computer architectures, particularly those that allow a restricted form of self-modifying code. This provides some indication that the conventional "stored program" organization of computer systems is not necessarily an inappropriate one for functional programming language implementations. This is not to say, however, that present day computer systems are well equipped to reduce combinator graphs. In particular, the behavior of the cache memory has a significant effect on performance. In order to study and quantify this effect, trace-driven cache simulations of a TIGRE graph reducer running on a reduced instruction-set computer are conducted. The results of these simulations are presented with the following hardware-cache parameters varied: cache size, block size, associativity, memory update policy, and write-allocation policy. To begin with, the cache organization of a commercially available system is used and then the performance sensitivity with respect to variations of each parameter are measured. From the results of the simulation study, a conclusion is made that combinator-graph reduction using TIGRE runs most efficiently when using a cache memory with an allocate-on-write-miss strategy, moderately large block size (preferably with subblock placement), and copy-back memory updates.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHguLi8uLi9QYXBlcnMvUGhpbGlwIEouIEtvb3BtYW4vUGhpbGlwIEouIEtvb3BtYW4tTGVlLVNpZXdpb3JlayAtIENhY2hlIGJlaGF2aW9yIG9mIGNvbWJpbmF0b3IgZ3JhcGggcmVkdWN0aW9uICgxOTkyKS5wZGbSGw8cHVdOUy5kYXRhTxECgAAAAAACgAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOEeRH1BoaWxpcCBKLiBLb29wbWFuLUxlIzM4NDc2MC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4R2DEOtwlUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAABFQaGlsaXAgSi4gS29vcG1hbgAAEAAIAADBNH5dAAAAEQAIAADEOxRlAAAAAQAQADhHkQAtkT8AA0esAABr2AACAEpPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6UGhpbGlwIEouIEtvb3BtYW46UGhpbGlwIEouIEtvb3BtYW4tTGUjMzg0NzYwLnBkZgAOALQAWQBQAGgAaQBsAGkAcAAgAEoALgAgAEsAbwBvAHAAbQBhAG4ALQBMAGUAZQAtAFMAaQBlAHcAaQBvAHIAZQBrACAALQAgAEMAYQBjAGgAZQAgAGIAZQBoAGEAdgBpAG8AcgAgAG8AZgAgAGMAbwBtAGIAaQBuAGEAdABvAHIAIABnAHIAYQBwAGgAIAByAGUAZAB1AGMAdABpAG8AbgAgACgAMQA5ADkAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAH9Vc2Vycy9qZXJlbXkvUGFwZXJzL1BoaWxpcCBKLiBLb29wbWFuL1BoaWxpcCBKLiBLb29wbWFuLUxlZS1TaWV3aW9yZWsgLSBDYWNoZSBiZWhhdmlvciBvZiBjb21iaW5hdG9yIGdyYXBoIHJlZHVjdGlvbiAoMTk5MikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgElASoBMgO2A7gDvQPGA9ED1QPjA+oD8wP4A/sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAECA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/128861.128867}}

@article{Shi:Virtual:2008,
	Address = {New York, NY, USA},
	Author = {Yunhe Shi and Kevin Casey and M. Anton Ertl and David Gregg},
	Date-Added = {2008-04-28 01:49:03 -0400},
	Date-Modified = {2008-04-28 01:49:06 -0400},
	Doi = {http://doi.acm.org/10.1145/1328195.1328197},
	Issn = {1544-3566},
	Journal = {ACM Trans. Archit. Code Optim.},
	Number = {4},
	Pages = {1--36},
	Publisher = {ACM},
	Title = {Virtual machine showdown: Stack versus registers},
	Volume = {4},
	Year = {2008},
	Abstract = {Virtual machines (VMs) enable the distribution of programs in an architecture-neutral format, which can easily be interpreted or compiled. A long-running question in the design of VMs is whether a stack architecture or register architecture can be implemented more efficiently with an interpreter. We extend existing work on comparing virtual stack and virtual register architectures in three ways. First, our translation from stack to register code and optimization are much more sophisticated. The result is that we eliminate an average of more than 46\% of executed VM instructions, with the bytecode size of the register machine being only 26\% larger than that of the corresponding stack one. Second, we present a fully functional virtual-register implementation of the Java virtual machine (JVM), which supports Intel, AMD64, PowerPC and Alpha processors. This register VM supports inline-threaded, direct-threaded, token-threaded, and switch dispatch. Third, we present experimental results on a range of additional optimizations such as register allocation and elimination of redundant heap loads. On the AMD64 architecture the register machine using switch dispatch achieves an average speedup of 1.48 over the corresponding stack machine. Even using the more efficient inline-threaded dispatch, the register VM achieves a speedup of 1.15 over the equivalent stack-based VM.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFMuLi8uLi9QYXBlcnMvU2hpL1NoaS1DYXNleS1FcnRsIC0gVmlydHVhbCBtYWNoaW5lIHNob3dkb3duOiBTdGFjayB2ZXJzdXMgKDIwMDgpLnBkZtIbDxwdV05TLmRhdGFPEQIQAAAAAAIQAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4R5QfU2hpLUNhc2V5LUVydGwgLSBWaXIjMzg0NzY3LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhHZ8Q63GBQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAA1NoaQAAEAAIAADBNH5dAAAAEQAIAADEOxSgAAAAAQAQADhHlAAtkT8AA0esAABr2AACADxPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6U2hpOlNoaS1DYXNleS1FcnRsIC0gVmlyIzM4NDc2Ny5wZGYADgCGAEIAUwBoAGkALQBDAGEAcwBlAHkALQBFAHIAdABsACAALQAgAFYAaQByAHQAdQBhAGwAIABtAGEAYwBoAGkAbgBlACAAcwBoAG8AdwBkAG8AdwBuAC8AIABTAHQAYQBjAGsAIAB2AGUAcgBzAHUAcwAgACgAMgAwADAAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFpVc2Vycy9qZXJlbXkvUGFwZXJzL1NoaS9TaGktQ2FzZXktRXJ0bCAtIFZpcnR1YWwgbWFjaGluZSBzaG93ZG93bjogU3RhY2sgdmVyc3VzICgyMDA4KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBAAEFAQ0DIQMjAygDMQM8A0ADTgNVA14DYwNmAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA3M=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1328195.1328197}}

@article{Zhuang:Allocating:2007,
	Address = {New York, NY, USA},
	Author = {Xiaotong Zhuang and Santosh Pande},
	Date-Added = {2008-04-28 01:49:03 -0400},
	Date-Modified = {2008-04-28 01:49:06 -0400},
	Doi = {http://doi.acm.org/10.1145/1216374.1216377},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Number = {2},
	Pages = {9},
	Publisher = {ACM},
	Title = {Allocating architected registers through differential encoding},
	Volume = {29},
	Year = {2007},
	Abstract = {Micro-architecture designers are very cautious about expanding the number of architected and exposed registers in the instruction set because increasing the register field adds to the code size, raises the I-cache and memory pressure, and may complicate the processor pipeline. Especially for low-end processors, encoding space could be extremely limited due to area and power considerations. On the other hand, the number of architected registers exposed to the compiler could directly affect the effectiveness of compiler analysis and optimization. For high-performance computers, register pressure can be higher than the available registers in some regions. This could be due to optimizations like aggressive function inlining, software pipelining, etc. The compiler cannot effectively perform compilation and optimization if only a small number of registers are exposed through the ISA. Therefore, it is crucial that more architected registers are available at the compiler's disposal, without expanding the code size significantly.

In this article, we devise a new register encoding scheme, called differential encoding, that allows more registers to be addressed in the operand field of instructions than the direct encoding currently being used. We show that this can be implemented with very low overhead. Based upon differential encoding, we apply it in several ways such that the extra architected registers can benefit the performance. Three schemes are devised to integrate differential encoding with register allocation. We demonstrate that differential register allocation is helpful in improving the performance of both high-end and low-end processors. Moreover, we can combine it with software pipelining to provide more registers and reduce spills.

Our results show that differential encoding significantly reduces the number of spills and speeds-up program execution. For a low-end configuration, we achieve over 14\% speedup while keeping code size almost unaffected. For a high-end VLIW in-order machine, it can significantly speed-up loops with high register pressure (about 80\% speedup) and the overall speedup is about 15\%. Moreover, our scheme can be applied in an adaptive manner, making its overhead much smaller.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGMuLi8uLi9QYXBlcnMvWmh1YW5nL1podWFuZy1QYW5kZSAtIEFsbG9jYXRpbmcgYXJjaGl0ZWN0ZWQgcmVnaXN0ZXJzIHRocm91Z2ggZGlmZmVyZW50aWFsICgyMDA3KS5wZGbSGw8cHVdOUy5kYXRhTxECQAAAAAACQAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOEeVH1podWFuZy1QYW5kZSAtIEFsbG9jIzM4NDc2Qi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4R2vEOtxxUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZaaHVhbmcAEAAIAADBNH5dAAAAEQAIAADEOxSxAAAAAQAQADhHlQAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6Wmh1YW5nOlpodWFuZy1QYW5kZSAtIEFsbG9jIzM4NDc2Qi5wZGYAAA4AoABPAFoAaAB1AGEAbgBnAC0AUABhAG4AZABlACAALQAgAEEAbABsAG8AYwBhAHQAaQBuAGcAIABhAHIAYwBoAGkAdABlAGMAdABlAGQAIAByAGUAZwBpAHMAdABlAHIAcwAgAHQAaAByAG8AdQBnAGgAIABkAGkAZgBmAGUAcgBlAG4AdABpAGEAbAAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGpVc2Vycy9qZXJlbXkvUGFwZXJzL1podWFuZy9aaHVhbmctUGFuZGUgLSBBbGxvY2F0aW5nIGFyY2hpdGVjdGVkIHJlZ2lzdGVycyB0aHJvdWdoIGRpZmZlcmVudGlhbCAoMjAwNykucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARABFQEdA2EDYwNoA3EDfAOAA44DlQOeA6MDpgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOz},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1216374.1216377}}

@inproceedings{Huang:Fast:2006,
	Address = {New York, NY, USA},
	Author = {Xianglong Huang and Stephen M. Blackburn and David Grove and Kathryn S. McKinley},
	Booktitle = {ISMM '06: Proceedings of the 5th international symposium on Memory management},
	Date-Added = {2008-04-28 01:49:03 -0400},
	Date-Modified = {2008-04-28 01:54:23 -0400},
	Doi = {http://doi.acm.org/10.1145/1133956.1133980},
	Isbn = {1-59593-221-6},
	Keywords = {optimization},
	Location = {Ottawa, Ontario, Canada},
	Pages = {184--192},
	Publisher = {ACM},
	Title = {Fast and efficient partial code reordering: taking advantage of dynamic recompilatior},
	Year = {2006},
	Abstract = { Poor instruction cache locality can degrade performance on modern architectures. For example, our simulation results show that eliminating all instruction cache misses improves performance by as much as 16\% for a modestly sized instruction cache. In this paper, we show how to take advantage of dynamic code generationin a Java Virtual Machine (VM) to improve instruction locality at run-time. We develop a dynamic code reordering (DCR) system; alow overhead, online approach for improving instruction locality. DCR has three optimizations: (1) Interprocedural method separation; (2) Intraprocedural code splitting; and (3) Code padding. DCR uses the dynamic call graph and an edge profile that most VMs already collect to separate hot/cold methods and hot/cold code within a method. It also puts padding between methods to minimize conflict misses between frequent caller/callee pairs. It incrementally performs these optimizations only when the VM is optimizing a method at a higher level. We implement DCR in Jikes RVM and show its overhead is negligible. Extensive simulation and run-time experiments show that a simple code space improves average performance on a Pentium 4 by around 6\% on SPEC and DaCapo Java benchmarks. These programs however have very small instruction cache footprints that limit opportunities for DCR to improve performance. Consequently, DCR optimizations on average show little effect, sometimes degrading performance and occasionally improving performance by up to 5\%. Our work shows that the VM has the potential to dynamically improve instruction locality incrementally by simply piggybacking on \textit{hotspot} recompilation.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGEuLi8uLi9QYXBlcnMvSHVhbmcvSHVhbmctQmxhY2tidXJuLUdyb3ZlIC0gRmFzdCBhbmQgZWZmaWNpZW50IHBhcnRpYWwgY29kZSByZW9yZGVyaW5nOiAoMjAwNikucGRm0hsPHB1XTlMuZGF0YU8RAjoAAAAAAjoAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADhHjB9IdWFuZy1CbGFja2J1cm4tR3JvdiMzODQ3NzMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOEdzxDrcw1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAFSHVhbmcAABAACAAAwTR+XQAAABEACAAAxDsVAwAAAAEAEAA4R4wALZE/AANHrAAAa9gAAgA+T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkh1YW5nOkh1YW5nLUJsYWNrYnVybi1Hcm92IzM4NDc3My5wZGYADgCeAE4ASAB1AGEAbgBnAC0AQgBsAGEAYwBrAGIAdQByAG4ALQBHAHIAbwB2AGUAIAAtACAARgBhAHMAdAAgAGEAbgBkACAAZQBmAGYAaQBjAGkAZQBuAHQAIABwAGEAcgB0AGkAYQBsACAAYwBvAGQAZQAgAHIAZQBvAHIAZABlAHIAaQBuAGcALwAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGhVc2Vycy9qZXJlbXkvUGFwZXJzL0h1YW5nL0h1YW5nLUJsYWNrYnVybi1Hcm92ZSAtIEZhc3QgYW5kIGVmZmljaWVudCBwYXJ0aWFsIGNvZGUgcmVvcmRlcmluZzogKDIwMDYpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEOARMBGwNZA1sDYANpA3QDeAOGA40DlgObA54AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1133956.1133980}}

@inproceedings{Reynolds:Definitional:1972,
	Address = {New York, NY, USA},
	Author = {John C. Reynolds},
	Booktitle = {ACM '72: Proceedings of the ACM annual conference},
	Date-Added = {2008-04-28 01:49:03 -0400},
	Date-Modified = {2008-04-28 01:49:06 -0400},
	Doi = {http://doi.acm.org/10.1145/800194.805852},
	Location = {Boston, Massachusetts, United States},
	Pages = {717--740},
	Publisher = {ACM},
	Title = {Definitional interpreters for higher-order programming languages},
	Year = {1972},
	Abstract = {Higher-order programming languages (i.e., languages in which procedures or labels can occur as values) are usually defined by interpreters which are themselves written in a programming language based on the lambda calculus (i.e., an applicative language such as pure LISP). Examples include McCarthy's definition of LISP, Landin's SECD machine, the Vienna definition of PL/I, Reynolds' definitions of GEDANKEN, and recent unpublished work by L. Morris and C. Wadsworth. Such definitions can be classified according to whether the interpreter contains higher-order functions, and whether the order of application (i.e., call-by-value versus call-by-name) in the defined language depends upon the order of application in the defining language. As an example, we consider the definition of a simple applicative programming language by means of an interpreter written in a similar language. Definitions in each of the above classifications are derived from one another by informal but constructive methods. The treatment of imperative features such as jumps and assignment is also discussed.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGwuLi8uLi9QYXBlcnMvUmV5bm9sZHMvUmV5bm9sZHMgLSBEZWZpbml0aW9uYWwgaW50ZXJwcmV0ZXJzIGZvciBoaWdoZXItb3JkZXIgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzICgxOTcyKS5wZGbSGw8cHVdOUy5kYXRhTxECXAAAAAACXAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOEeSH1JleW5vbGRzIC0gRGVmaW5pdGlvIzM4NDc3Qy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4R3zEOt0fUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAhSZXlub2xkcwAQAAgAAME0fl0AAAARAAgAAMQ7FV8AAAABABAAOEeSAC2RPwADR6wAAGvYAAIAQU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpSZXlub2xkczpSZXlub2xkcyAtIERlZmluaXRpbyMzODQ3N0MucGRmAAAOAK4AVgBSAGUAeQBuAG8AbABkAHMAIAAtACAARABlAGYAaQBuAGkAdABpAG8AbgBhAGwAIABpAG4AdABlAHIAcAByAGUAdABlAHIAcwAgAGYAbwByACAAaABpAGcAaABlAHIALQBvAHIAZABlAHIAIABwAHIAbwBnAHIAYQBtAG0AaQBuAGcAIABsAGEAbgBnAHUAYQBnAGUAcwAgACgAMQA5ADcAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHNVc2Vycy9qZXJlbXkvUGFwZXJzL1JleW5vbGRzL1JleW5vbGRzIC0gRGVmaW5pdGlvbmFsIGludGVycHJldGVycyBmb3IgaGlnaGVyLW9yZGVyIHByb2dyYW1taW5nIGxhbmd1YWdlcyAoMTk3MikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEZAR4BJgOGA4gDjQOWA6EDpQOzA7oDwwPIA8sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAD2A==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/800194.805852}}

@article{Reynolds:Definitional:1998,
	Address = {Hingham, MA, USA},
	Author = {John C. Reynolds},
	Date-Added = {2008-04-28 01:49:03 -0400},
	Date-Modified = {2008-04-28 01:49:06 -0400},
	Doi = {http://dx.doi.org/10.1023/A:1010075320153},
	Issn = {1388-3690},
	Journal = {Higher Order Symbol. Comput.},
	Number = {4},
	Pages = {355--361},
	Publisher = {Kluwer Academic Publishers},
	Title = {Definitional Interpreters Revisited},
	Volume = {11},
	Year = {1998},
	Abstract = {To introduce the republication of "Definitional Interpreters for Higher-Order Programming Languages", the author recounts the circumstances of its creation, clarifies several obscurities, corrects a few mistakes, and briefly summarizes some more recent developments.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE8uLi8uLi9QYXBlcnMvUmV5bm9sZHMvUmV5bm9sZHMgLSBEZWZpbml0aW9uYWwgSW50ZXJwcmV0ZXJzIFJldmlzaXRlZCAoMTk5OCkucGRm0hsPHB1XTlMuZGF0YU8RAgQAAAAAAgQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADhHkh9SZXlub2xkcyAtIERlZmluaXRpbyMzODQ3ODIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOEeCxDrdcVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIUmV5bm9sZHMAEAAIAADBNH5dAAAAEQAIAADEOxWxAAAAAQAQADhHkgAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6UmV5bm9sZHM6UmV5bm9sZHMgLSBEZWZpbml0aW8jMzg0NzgyLnBkZgAADgB0ADkAUgBlAHkAbgBvAGwAZABzACAALQAgAEQAZQBmAGkAbgBpAHQAaQBvAG4AYQBsACAASQBuAHQAZQByAHAAcgBlAHQAZQByAHMAIABSAGUAdgBpAHMAaQB0AGUAZAAgACgAMQA5ADkAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFZVc2Vycy9qZXJlbXkvUGFwZXJzL1JleW5vbGRzL1JleW5vbGRzIC0gRGVmaW5pdGlvbmFsIEludGVycHJldGVycyBSZXZpc2l0ZWQgKDE5OTgpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD8AQEBCQMRAxMDGAMhAywDMAM+A0UDTgNTA1YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADYw==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1023/A:1010075320153}}

@inproceedings{Bloss:Update:1989,
	Address = {New York, NY, USA},
	Author = {Adrienne Bloss},
	Booktitle = {FPCA '89: Proceedings of the fourth international conference on Functional programming languages and computer architecture},
	Date-Added = {2008-04-28 01:08:38 -0400},
	Date-Modified = {2008-04-28 01:12:36 -0400},
	Doi = {http://doi.acm.org/10.1145/99370.99373},
	Isbn = {0-89791-328-0},
	Keywords = {static analysis},
	Location = {Imperial College, London, United Kingdom},
	Pages = {26--38},
	Publisher = {ACM},
	Title = {Update analysis and the efficient implementation of functional aggregates},
	Year = {1989},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGQuLi8uLi9QYXBlcnMvQmxvc3MvQmxvc3MgLSBVcGRhdGUgYW5hbHlzaXMgYW5kIHRoZSBlZmZpY2llbnQgaW1wbGVtZW50YXRpb24gb2YgZnVuY3Rpb25hbCAoMTk4OSkucGRm0hsPHB1XTlMuZGF0YU8RAkQAAAAAAkQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADhFZx9CbG9zcyAtIFVwZGF0ZSBhbmFseSMzODQ1RDUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOEXVxDrPJ1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAFQmxvc3MAABAACAAAwTR+XQAAABEACAAAxDsHZwAAAAEAEAA4RWcALZE/AANHrAAAa9gAAgA+T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkJsb3NzOkJsb3NzIC0gVXBkYXRlIGFuYWx5IzM4NDVENS5wZGYADgCkAFEAQgBsAG8AcwBzACAALQAgAFUAcABkAGEAdABlACAAYQBuAGEAbAB5AHMAaQBzACAAYQBuAGQAIAB0AGgAZQAgAGUAZgBmAGkAYwBpAGUAbgB0ACAAaQBtAHAAbABlAG0AZQBuAHQAYQB0AGkAbwBuACAAbwBmACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgACgAMQA5ADgAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGtVc2Vycy9qZXJlbXkvUGFwZXJzL0Jsb3NzL0Jsb3NzIC0gVXBkYXRlIGFuYWx5c2lzIGFuZCB0aGUgZWZmaWNpZW50IGltcGxlbWVudGF0aW9uIG9mIGZ1bmN0aW9uYWwgKDE5ODkpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBEQEWAR4DZgNoA20DdgOBA4UDkwOaA6MDqAOrAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA7g=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/99370.99373}}

@inproceedings{Gopinath:Copy:1989,
	Address = {New York, NY, USA},
	Author = {K. Gopinath and J. L. Hennessy},
	Booktitle = {POPL '89: Proceedings of the 16th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
	Date-Added = {2008-04-28 01:08:38 -0400},
	Date-Modified = {2008-04-28 01:12:15 -0400},
	Doi = {http://doi.acm.org/10.1145/75277.75304},
	Isbn = {0-89791-294-2},
	Keywords = {static analysis},
	Location = {Austin, Texas, United States},
	Pages = {303--314},
	Publisher = {ACM},
	Title = {Copy elimination in functional languages},
	Year = {1989},
	Abstract = {Copy elimination is an important optimization for compiling functional languages. Copies arise because these languages lack the concepts of state and variable; hence updating an object involves a copy in a naive implementation. Copies are also possible if proper targeting has not been carried out inside functions and across function calls. Targeting is the proper selection of a storage area for evaluating an expression. By abstracting a collection of functions by a target operator, we compute targets of function bodies that can then be used to define an optimized interpreter to eliminate copies due to updates and copies across function calls. The language we consider is typed lambda calculus with higher-order functions and special constructs for array operations. Our approach can eliminate copies in divide and conquer problems like quicksort and bitonic sort that previous approaches could not handle. We also present some results of implementing a compiler for a single assignment language called SAL on some small but tough programs. Our results indicate that it is possible to approach a performance comparable to imperative languages like Pascal.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEF0uLi8uLi9QYXBlcnMvR29waW5hdGgvR29waW5hdGgtSGVubmVzc3kgLSBDb3B5IGVsaW1pbmF0aW9uIGluIGZ1bmN0aW9uYWwgbGFuZ3VhZ2VzICgxOTg5KS5wZGbSGw8cHVdOUy5kYXRhTxECLgAAAAACLgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOEaUH0dvcGluYXRoLUhlbm5lc3N5IC0gIzM4NDVEOS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4RdnEOs86UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAhHb3BpbmF0aAAQAAgAAME0fl0AAAARAAgAAMQ7B3oAAAABABAAOEaUAC2RPwADR6wAAGvYAAIAQU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpHb3BpbmF0aDpHb3BpbmF0aC1IZW5uZXNzeSAtICMzODQ1RDkucGRmAAAOAJAARwBHAG8AcABpAG4AYQB0AGgALQBIAGUAbgBuAGUAcwBzAHkAIAAtACAAQwBvAHAAeQAgAGUAbABpAG0AaQBuAGEAdABpAG8AbgAgAGkAbgAgAGYAdQBuAGMAdABpAG8AbgBhAGwAIABsAGEAbgBnAHUAYQBnAGUAcwAgACgAMQA5ADgAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGRVc2Vycy9qZXJlbXkvUGFwZXJzL0dvcGluYXRoL0dvcGluYXRoLUhlbm5lc3N5IC0gQ29weSBlbGltaW5hdGlvbiBpbiBmdW5jdGlvbmFsIGxhbmd1YWdlcyAoMTk4OSkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQoBDwEXA0kDSwNQA1kDZANoA3YDfQOGA4sDjgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOb},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/75277.75304}}

@article{Bloss:Path:1994,
	Address = {New York, NY, USA},
	Author = {Adrienne Bloss},
	Date-Added = {2008-04-28 01:08:38 -0400},
	Date-Modified = {2008-04-28 01:12:36 -0400},
	Doi = {http://doi.acm.org/10.1145/177492.177497},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Keywords = {static analysis},
	Number = {3},
	Pages = {328--369},
	Publisher = {ACM},
	Title = {Path analysis and the optimization of nonstrict functional languages},
	Volume = {16},
	Year = {1994},
	Abstract = {The functional programming style is increasingly popular in the research world, but functional languages still execute slowly relative to imperative languages. This is largely because the power and flexibility of functional languages restrict the amount of information readily available to the compiler, hindering its ability to generate good code. This article demonstrates that information about order of evaluation of expressions can be statically inferred for nonstrict functional programs and that optimizations based on this information can provide substantial speedups at runtime. We present an exact, nonstandard semantics called path semantics that models order of evaluation in a nonstrict, sequential functional language, and its computable abstraction, path analysis. We show how the information inferred by path analysis can be used to implement destructive aggregate updating, in which updates on functional aggregates that are provably not live are done destructively. We also demonstrate a new approach to strictness analysis and show that strictness analysis is subsumed by path analysis. Benchmarks are presented.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGAuLi8uLi9QYXBlcnMvQmxvc3MvQmxvc3MgLSBQYXRoIGFuYWx5c2lzIGFuZCB0aGUgb3B0aW1pemF0aW9uIG9mIG5vbnN0cmljdCBmdW5jdGlvbmFsICgxOTk0KS5wZGbSGw8cHVdOUy5kYXRhTxECOAAAAAACOAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOEVnH0Jsb3NzIC0gUGF0aCBhbmFseXNpIzM4NDVFQS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4RerEOs/bUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVCbG9zcwAAEAAIAADBNH5dAAAAEQAIAADEOwgbAAAAAQAQADhFZwAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6Qmxvc3M6Qmxvc3MgLSBQYXRoIGFuYWx5c2kjMzg0NUVBLnBkZgAOAJwATQBCAGwAbwBzAHMAIAAtACAAUABhAHQAaAAgAGEAbgBhAGwAeQBzAGkAcwAgAGEAbgBkACAAdABoAGUAIABvAHAAdABpAG0AaQB6AGEAdABpAG8AbgAgAG8AZgAgAG4AbwBuAHMAdAByAGkAYwB0ACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgACgAMQA5ADkANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGdVc2Vycy9qZXJlbXkvUGFwZXJzL0Jsb3NzL0Jsb3NzIC0gUGF0aCBhbmFseXNpcyBhbmQgdGhlIG9wdGltaXphdGlvbiBvZiBub25zdHJpY3QgZnVuY3Rpb25hbCAoMTk5NCkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgENARIBGgNWA1gDXQNmA3EDdQODA4oDkwOYA5sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/177492.177497}}

@inproceedings{Sastry:Parallel:1994,
	Address = {New York, NY, USA},
	Author = {A. V. S. Sastry and William Clinger},
	Booktitle = {LFP '94: Proceedings of the 1994 ACM conference on LISP and functional programming},
	Date-Added = {2008-04-28 01:08:38 -0400},
	Date-Modified = {2008-04-28 01:12:04 -0400},
	Doi = {http://doi.acm.org/10.1145/182409.182486},
	Isbn = {0-89791-643-3},
	Keywords = {static analysis},
	Location = {Orlando, Florida, United States},
	Pages = {263--272},
	Publisher = {ACM},
	Title = {Parallel destructive updating in strict functional languages},
	Year = {1994},
	Abstract = {In our recent paper, we gave an efficient interprocedural update analysis algorithm for strict functional languages with flat arrays and sequential evaluation. In this paper, we show that the same algorithm extends to a parallel functional language with additional constructs for partitioning and combining arrays. Even with parallel evaluation, the complexity of the analysis remains polynomial. The analysis has been implemented and the results show that several numerical algorithms such as direct and iterative methods for solving linear equations, LU, Cholesky, and QR factorizations, multigrid methods for solving partial differential equations, and non-numeric algorithms such as sorting can be implemented functionally with all updates made destructive. We describe a new array construct to specify a collection of updates on an array and show that problems like histogram, inverse permutation, and polynomial multiplication have efficient parallel functional solutions. Monolithic array operators can be considered as a special case of this new construct.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGIuLi8uLi9QYXBlcnMvU2FzdHJ5L1Nhc3RyeS1DbGluZ2VyIC0gUGFyYWxsZWwgZGVzdHJ1Y3RpdmUgdXBkYXRpbmcgaW4gc3RyaWN0IGZ1bmN0aW9uYWwgKDE5OTQpLnBkZtIbDxwdV05TLmRhdGFPEQI+AAAAAAI+AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4RpUfU2FzdHJ5LUNsaW5nZXIgLSBQYXIjMzg0NUZCLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhF+8Q60BVQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABlNhc3RyeQAQAAgAAME0fl0AAAARAAgAAMQ7CFUAAAABABAAOEaVAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpTYXN0cnk6U2FzdHJ5LUNsaW5nZXIgLSBQYXIjMzg0NUZCLnBkZgAADgCeAE4AUwBhAHMAdAByAHkALQBDAGwAaQBuAGcAZQByACAALQAgAFAAYQByAGEAbABsAGUAbAAgAGQAZQBzAHQAcgB1AGMAdABpAHYAZQAgAHUAcABkAGEAdABpAG4AZwAgAGkAbgAgAHMAdAByAGkAYwB0ACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgACgAMQA5ADkANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGlVc2Vycy9qZXJlbXkvUGFwZXJzL1Nhc3RyeS9TYXN0cnktQ2xpbmdlciAtIFBhcmFsbGVsIGRlc3RydWN0aXZlIHVwZGF0aW5nIGluIHN0cmljdCBmdW5jdGlvbmFsICgxOTk0KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQ8BFAEcA14DYANlA24DeQN9A4sDkgObA6ADowAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOw},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/182409.182486}}

@article{Wand:Analysis-based:2000,
	Address = {New York, NY, USA},
	Author = {Mitchell Wand},
	Date-Added = {2008-04-28 01:08:38 -0400},
	Date-Modified = {2008-04-28 01:12:04 -0400},
	Doi = {http://doi.acm.org/10.1145/340855.341041},
	Issn = {0163-5948},
	Journal = {SIGSOFT Softw. Eng. Notes},
	Keywords = {static analysis},
	Number = {1},
	Pages = {91--92},
	Publisher = {ACM},
	Title = {Analysis-based program transformations},
	Volume = {25},
	Year = {2000},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEouLi8uLi9QYXBlcnMvV2FuZC9XYW5kIC0gQW5hbHlzaXMtYmFzZWQgcHJvZ3JhbSB0cmFuc2Zvcm1hdGlvbnMgKDIwMDApLnBkZtIbDxwdV05TLmRhdGFPEQH2AAAAAAH2AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4RpYfV2FuZCAtIEFuYWx5c2lzLWJhc2UjMzg0NUZFLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhF/sQ60CRQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABFdhbmQAEAAIAADBNH5dAAAAEQAIAADEOwhkAAAAAQAQADhGlgAtkT8AA0esAABr2AACAD1PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6V2FuZDpXYW5kIC0gQW5hbHlzaXMtYmFzZSMzODQ1RkUucGRmAAAOAHIAOABXAGEAbgBkACAALQAgAEEAbgBhAGwAeQBzAGkAcwAtAGIAYQBzAGUAZAAgAHAAcgBvAGcAcgBhAG0AIAB0AHIAYQBuAHMAZgBvAHIAbQBhAHQAaQBvAG4AcwAgACgAMgAwADAAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFFVc2Vycy9qZXJlbXkvUGFwZXJzL1dhbmQvV2FuZCAtIEFuYWx5c2lzLWJhc2VkIHByb2dyYW0gdHJhbnNmb3JtYXRpb25zICgyMDAwKS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPcA/AEEAv4DAAMFAw4DGQMdAysDMgM7A0ADQwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANQ},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/340855.341041}}

@inproceedings{Draghicescu:A-compositional:1990,
	Address = {New York, NY, USA},
	Author = {M. Draghicescu and S. Purushothaman},
	Booktitle = {LFP '90: Proceedings of the 1990 ACM conference on LISP and functional programming},
	Date-Added = {2008-04-28 01:08:38 -0400},
	Date-Modified = {2008-04-28 01:12:15 -0400},
	Doi = {http://doi.acm.org/10.1145/91556.91658},
	Isbn = {0-89791-368-X},
	Keywords = {static analysis},
	Location = {Nice, France},
	Pages = {242--250},
	Publisher = {ACM},
	Title = {A compositional analysis of evaluation-order and its application},
	Year = {1990},
	Abstract = { We present a compositional definition of the order of evaluation of variables in a lazy first-order functional language. Unlike other published work, our analysis applies to all evaluation strategies which may use strictness information to change the normal (lazy) order of evaluation. At the same time it can be adapted to pure lazy evaluation yielding a sharper analysis in this case. It can also be adapted to take advantage of any information about the order in which primitive functions evaluate their arguments. The time complexity of the method is that of strictness analysis. We also present a compositional definition of the set of variables which denote locations where the result of an expression might be stored. This analysis yields a simple solution to the aliasing problem. Using these two analyses we develop a new algorithm for the destructive update problem.
},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEIAuLi8uLi9QYXBlcnMvRHJhZ2hpY2VzY3UvRHJhZ2hpY2VzY3UtUHVydXNob3RoYW1hbiAtIEEgY29tcG9zaXRpb25hbCBhbmFseXNpcyBvZiBldmFsdWF0aW9uLW9yZGVyIGFuZCBpdHMgYXBwbGljYXRpb24gKDE5OTApLnBkZtIbDxwdV05TLmRhdGFPEQKYAAAAAAKYAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4RpIfRHJhZ2hpY2VzY3UtUHVydXNob3QjMzg0NjBCLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhGC8Q60G1QREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAC0RyYWdoaWNlc2N1AAAQAAgAAME0fl0AAAARAAgAAMQ7CK0AAAABABAAOEaSAC2RPwADR6wAAGvYAAIARE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpEcmFnaGljZXNjdTpEcmFnaGljZXNjdS1QdXJ1c2hvdCMzODQ2MEIucGRmAA4A0ABnAEQAcgBhAGcAaABpAGMAZQBzAGMAdQAtAFAAdQByAHUAcwBoAG8AdABoAGEAbQBhAG4AIAAtACAAQQAgAGMAbwBtAHAAbwBzAGkAdABpAG8AbgBhAGwAIABhAG4AYQBsAHkAcwBpAHMAIABvAGYAIABlAHYAYQBsAHUAYQB0AGkAbwBuAC0AbwByAGQAZQByACAAYQBuAGQAIABpAHQAcwAgAGEAcABwAGwAaQBjAGEAdABpAG8AbgAgACgAMQA5ADkAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAIdVc2Vycy9qZXJlbXkvUGFwZXJzL0RyYWdoaWNlc2N1L0RyYWdoaWNlc2N1LVB1cnVzaG90aGFtYW4gLSBBIGNvbXBvc2l0aW9uYWwgYW5hbHlzaXMgb2YgZXZhbHVhdGlvbi1vcmRlciBhbmQgaXRzIGFwcGxpY2F0aW9uICgxOTkwKS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAS0BMgE6A9YD2APdA+YD8QP1BAMECgQTBBgEGwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAQo},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/91556.91658}}

@inproceedings{Hudak:A-semantic:1986,
	Address = {New York, NY, USA},
	Author = {Paul Hudak},
	Booktitle = {LFP '86: Proceedings of the 1986 ACM conference on LISP and functional programming},
	Date-Added = {2008-04-28 01:08:38 -0400},
	Date-Modified = {2008-04-28 01:11:56 -0400},
	Doi = {http://doi.acm.org/10.1145/319838.319876},
	Isbn = {0-89791-200-4},
	Keywords = {static analysis},
	Location = {Cambridge, Massachusetts, United States},
	Pages = {351--363},
	Publisher = {ACM},
	Title = {A semantic model of reference counting and its abstraction (detailed summary)},
	Year = {1986},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGAuLi8uLi9QYXBlcnMvSHVkYWsvSHVkYWsgLSBBIHNlbWFudGljIG1vZGVsIG9mIHJlZmVyZW5jZSBjb3VudGluZyBhbmQgaXRzIGFic3RyYWN0aW9uICgxOTg2KS5wZGbSGw8cHVdOUy5kYXRhTxECOAAAAAACOAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZF5H0h1ZGFrIC0gQSBzZW1hbnRpYyBtIzM4NDYwRS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4Rg7EOtB8UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVIdWRhawAAEAAIAADBNH5dAAAAEQAIAADEOwi8AAAAAQAQAC2ReQAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6SHVkYWs6SHVkYWsgLSBBIHNlbWFudGljIG0jMzg0NjBFLnBkZgAOAJwATQBIAHUAZABhAGsAIAAtACAAQQAgAHMAZQBtAGEAbgB0AGkAYwAgAG0AbwBkAGUAbAAgAG8AZgAgAHIAZQBmAGUAcgBlAG4AYwBlACAAYwBvAHUAbgB0AGkAbgBnACAAYQBuAGQAIABpAHQAcwAgAGEAYgBzAHQAcgBhAGMAdABpAG8AbgAgACgAMQA5ADgANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGdVc2Vycy9qZXJlbXkvUGFwZXJzL0h1ZGFrL0h1ZGFrIC0gQSBzZW1hbnRpYyBtb2RlbCBvZiByZWZlcmVuY2UgY291bnRpbmcgYW5kIGl0cyBhYnN0cmFjdGlvbiAoMTk4NikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgENARIBGgNWA1gDXQNmA3EDdQODA4oDkwOYA5sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/319838.319876}}

@inproceedings{Sastry:Order-of-evaluation:1993,
	Address = {New York, NY, USA},
	Author = {A. V. S. Sastry and William Clinger and Zena Ariola},
	Booktitle = {FPCA '93: Proceedings of the conference on Functional programming languages and computer architecture},
	Date-Added = {2008-04-28 01:08:38 -0400},
	Date-Modified = {2008-04-30 21:19:14 -0400},
	Doi = {http://doi.acm.org/10.1145/165180.165222},
	Isbn = {0-89791-595-X},
	Keywords = {static analysis, update analysis},
	Location = {Copenhagen, Denmark},
	Pages = {266--275},
	Publisher = {ACM},
	Title = {Order-of-evaluation analysis for destructive updates in strict functional languages with flat aggregates},
	Year = {1993},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHUuLi8uLi9QYXBlcnMvU2FzdHJ5L1Nhc3RyeS1DbGluZ2VyLUFyaW9sYSAtIE9yZGVyLW9mLWV2YWx1YXRpb24gYW5hbHlzaXMgZm9yIGRlc3RydWN0aXZlIHVwZGF0ZXMgaW4gc3RyaWN0ICgxOTkzKS5wZGbSGw8cHVdOUy5kYXRhTxECdgAAAAACdgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOEaVH1Nhc3RyeS1DbGluZ2VyLUFyaW9sIzM4NDYxNy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4RhfEOtC1UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZTYXN0cnkAEAAIAADBNH5dAAAAEQAIAADEOwj1AAAAAQAQADhGlQAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6U2FzdHJ5OlNhc3RyeS1DbGluZ2VyLUFyaW9sIzM4NDYxNy5wZGYAAA4AxABhAFMAYQBzAHQAcgB5AC0AQwBsAGkAbgBnAGUAcgAtAEEAcgBpAG8AbABhACAALQAgAE8AcgBkAGUAcgAtAG8AZgAtAGUAdgBhAGwAdQBhAHQAaQBvAG4AIABhAG4AYQBsAHkAcwBpAHMAIABmAG8AcgAgAGQAZQBzAHQAcgB1AGMAdABpAHYAZQAgAHUAcABkAGEAdABlAHMAIABpAG4AIABzAHQAcgBpAGMAdAAgACgAMQA5ADkAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHxVc2Vycy9qZXJlbXkvUGFwZXJzL1Nhc3RyeS9TYXN0cnktQ2xpbmdlci1BcmlvbGEgLSBPcmRlci1vZi1ldmFsdWF0aW9uIGFuYWx5c2lzIGZvciBkZXN0cnVjdGl2ZSB1cGRhdGVzIGluIHN0cmljdCAoMTk5MykucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqASIBJwEvA6kDqwOwA7kDxAPIA9YD3QPmA+sD7gAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAP7},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/165180.165222}}

@inproceedings{Wadler:Comprehending:1990,
	Address = {New York, NY, USA},
	Author = {Philip Wadler},
	Booktitle = {LFP '90: Proceedings of the 1990 ACM conference on LISP and functional programming},
	Date-Added = {2008-04-28 01:08:38 -0400},
	Date-Modified = {2008-04-28 01:08:40 -0400},
	Doi = {http://doi.acm.org/10.1145/91556.91592},
	Isbn = {0-89791-368-X},
	Location = {Nice, France},
	Pages = {61--78},
	Publisher = {ACM},
	Title = {Comprehending monads},
	Year = {1990},
	Abstract = {Category theorists invented monads in the 1960's to concisely express certain aspects of universal algebra. Functional programmers invented list comprehensions in the 1970's to concisely express certain programs involving lists. This paper shows how list comprehensions may be generalised to an arbitrary monad, and how the resulting programming feature can concisely express in a pure functional language some programs that manipulate state, handle exceptions, parse text, or invoke continuations. A new solution to the old problem of destructive array update is also presented. No knowledge of category theory is assumed.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEDwuLi8uLi9QYXBlcnMvV2FkbGVyL1dhZGxlciAtIENvbXByZWhlbmRpbmcgbW9uYWRzICgxOTkwKS5wZGbSGw8cHVdOUy5kYXRhTxEBzAAAAAABzAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZF4H1dhZGxlciAtIENvbXByZWhlbmRpIzM4NDYxRC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4Rh3EOtDTUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZXYWRsZXIAEAAIAADBNH5dAAAAEQAIAADEOwkTAAAAAQAQAC2ReAAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6V2FkbGVyOldhZGxlciAtIENvbXByZWhlbmRpIzM4NDYxRC5wZGYAAA4AUgAoAFcAYQBkAGwAZQByACAALQAgAEMAbwBtAHAAcgBlAGgAZQBuAGQAaQBuAGcAIABtAG8AbgBhAGQAcwAgACgAMQA5ADkAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAENVc2Vycy9qZXJlbXkvUGFwZXJzL1dhZGxlci9XYWRsZXIgLSBDb21wcmVoZW5kaW5nIG1vbmFkcyAoMTk5MCkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgDpAO4A9gLGAsgCzQLWAuEC5QLzAvoDAwMIAwsAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADGA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/91556.91592}}

@inproceedings{Debray:Abstract:1995,
	Address = {New York, NY, USA},
	Author = {Saumya Debray},
	Booktitle = {PEPM '95: Proceedings of the 1995 ACM SIGPLAN symposium on Partial evaluation and semantics-based program manipulation},
	Date-Added = {2008-04-28 01:08:38 -0400},
	Date-Modified = {2008-04-28 01:12:22 -0400},
	Doi = {http://doi.acm.org/10.1145/215465.215571},
	Isbn = {0-89791-720-0},
	Keywords = {optimization},
	Location = {La Jolla, California, United States},
	Pages = {111--121},
	Publisher = {ACM},
	Title = {Abstract interpretation and low-level code optimization},
	Year = {1995},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEF8uLi8uLi9QYXBlcnMvRGVicmF5L0RlYnJheSAtIEFic3RyYWN0IGludGVycHJldGF0aW9uIGFuZCBsb3ctbGV2ZWwgY29kZSBvcHRpbWl6YXRpb24gKDE5OTUpLnBkZtIbDxwdV05TLmRhdGFPEQI0AAAAAAI0AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4RpEfRGVicmF5IC0gQWJzdHJhY3QgaW4jMzg0NjI2LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhGJsQ60PdQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABkRlYnJheQAQAAgAAME0fl0AAAARAAgAAMQ7CTcAAAABABAAOEaRAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpEZWJyYXk6RGVicmF5IC0gQWJzdHJhY3QgaW4jMzg0NjI2LnBkZgAADgCYAEsARABlAGIAcgBhAHkAIAAtACAAQQBiAHMAdAByAGEAYwB0ACAAaQBuAHQAZQByAHAAcgBlAHQAYQB0AGkAbwBuACAAYQBuAGQAIABsAG8AdwAtAGwAZQB2AGUAbAAgAGMAbwBkAGUAIABvAHAAdABpAG0AaQB6AGEAdABpAG8AbgAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGZVc2Vycy9qZXJlbXkvUGFwZXJzL0RlYnJheS9EZWJyYXkgLSBBYnN0cmFjdCBpbnRlcnByZXRhdGlvbiBhbmQgbG93LWxldmVsIGNvZGUgb3B0aW1pemF0aW9uICgxOTk1KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBDAERARkDUQNTA1gDYQNsA3ADfgOFA44DkwOWAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA6M=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/215465.215571}}

@inproceedings{Futamura:Automatic:2002,
	Address = {New York, NY, USA},
	Author = {Yoshihiko Futamura and Zenjiro Konishi and Robert Gl\"{u}ck},
	Booktitle = {ASIA-PEPM '02: Proceedings of the ASIAN symposium on Partial evaluation and semantics-based program manipulation},
	Date-Added = {2008-04-28 01:08:38 -0400},
	Date-Modified = {2008-04-28 01:08:40 -0400},
	Doi = {http://doi.acm.org/10.1145/568173.568174},
	Isbn = {1-58113-458-4},
	Location = {Aizu, Japan},
	Pages = {1--8},
	Publisher = {ACM},
	Title = {Automatic generation of efficient string matching algorithms by generalized partial computation},
	Year = {2002},
	Abstract = { This paper shows that Generalized Partial Computation (GPC) can automatically generate efficient string matching algorithms. GPC is a program transformation method utilizing partial information about input data and auxiliary functions as well as the logical structure of a source program. GPC uses both a classical partial evaluator and an inference engine such as a theorem prover to optimize programs. First, we show that a Boyer-Moore (BM) type pattern matcher without the bad-character heuristic can be generated from a simple non-linear backward matcher by GPC. This sort of problems has already been discussed in the literature using offline partial evaluators. However, there was no proof that every generated matcher runs in the same way as the BM. In this paper we prove that the problem can be solved starting from a simple non-linear pattern matcher as a source program. We also prove that a Knuth-Morris-Pratt (KMP) type linear string matcher can be generated from a naive non-linear forward matcher by GPC.
},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGsuLi8uLi9QYXBlcnMvRnV0YW11cmEvRnV0YW11cmEtS29uaXNoaS1HbHVjayAtIEF1dG9tYXRpYyBnZW5lcmF0aW9uIG9mIGVmZmljaWVudCBzdHJpbmcgbWF0Y2hpbmcgKDIwMDIpLnBkZtIbDxwdV05TLmRhdGFPEQJYAAAAAAJYAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4RpMfRnV0YW11cmEtS29uaXNoaS1HbHUjMzg0NjJBLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhGKsQ60Q5QREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAACEZ1dGFtdXJhABAACAAAwTR+XQAAABEACAAAxDsJTgAAAAEAEAA4RpMALZE/AANHrAAAa9gAAgBBT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkZ1dGFtdXJhOkZ1dGFtdXJhLUtvbmlzaGktR2x1IzM4NDYyQS5wZGYAAA4ArABVAEYAdQB0AGEAbQB1AHIAYQAtAEsAbwBuAGkAcwBoAGkALQBHAGwAdQBjAGsAIAAtACAAQQB1AHQAbwBtAGEAdABpAGMAIABnAGUAbgBlAHIAYQB0AGkAbwBuACAAbwBmACAAZQBmAGYAaQBjAGkAZQBuAHQAIABzAHQAcgBpAG4AZwAgAG0AYQB0AGMAaABpAG4AZwAgACgAMgAwADAAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHJVc2Vycy9qZXJlbXkvUGFwZXJzL0Z1dGFtdXJhL0Z1dGFtdXJhLUtvbmlzaGktR2x1Y2sgLSBBdXRvbWF0aWMgZ2VuZXJhdGlvbiBvZiBlZmZpY2llbnQgc3RyaW5nIG1hdGNoaW5nICgyMDAyKS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBGAEdASUDgQODA4gDkQOcA6ADrgO1A74DwwPGAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA9M=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/568173.568174}}

@inproceedings{Bird:Polymorphic:2005,
	Address = {New York, NY, USA},
	Author = {Richard S. Bird},
	Booktitle = {Haskell '05: Proceedings of the 2005 ACM SIGPLAN workshop on Haskell},
	Date-Added = {2008-04-28 01:08:38 -0400},
	Date-Modified = {2008-04-28 01:08:40 -0400},
	Doi = {http://doi.acm.org/10.1145/1088348.1088359},
	Isbn = {1-59593-071-X},
	Location = {Tallinn, Estonia},
	Pages = {110--115},
	Publisher = {ACM},
	Title = {Polymorphic string matching},
	Year = {2005},
	Abstract = {Calculational developments of functional programs have been likened to conjuring tricks: enjoyable to watch but often a mystery as to how they are done. This pearl explains the trick. The aim is to give new calculations of two famous algorithms in string matching, the Knuth-Morris-Pratt algorithm and the Boyer-Moore algorithm. The string matching problem is formulated polymorphically, so the only available property of elements of the alphabet is an equality test.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfED8uLi8uLi9QYXBlcnMvQmlyZC9CaXJkIC0gUG9seW1vcnBoaWMgc3RyaW5nIG1hdGNoaW5nICgyMDA1KS5wZGbSGw8cHVdOUy5kYXRhTxEB1AAAAAAB1AACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOEaQH0JpcmQgLSBQb2x5bW9ycGhpYyBzIzM4NDYzMS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4RjHEOtEzUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAARCaXJkABAACAAAwTR+XQAAABEACAAAxDsJcwAAAAEAEAA4RpAALZE/AANHrAAAa9gAAgA9T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkJpcmQ6QmlyZCAtIFBvbHltb3JwaGljIHMjMzg0NjMxLnBkZgAADgBcAC0AQgBpAHIAZAAgAC0AIABQAG8AbAB5AG0AbwByAHAAaABpAGMAIABzAHQAcgBpAG4AZwAgAG0AYQB0AGMAaABpAG4AZwAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAEZVc2Vycy9qZXJlbXkvUGFwZXJzL0JpcmQvQmlyZCAtIFBvbHltb3JwaGljIHN0cmluZyBtYXRjaGluZyAoMjAwNSkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAOwA8QD5AtEC0wLYAuEC7ALwAv4DBQMOAxMDFgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAMj},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1088348.1088359}}

@article{Ager:Fast:2006,
	Address = {New York, NY, USA},
	Author = {Mads Sig Ager and Olivier Danvy and Henning Korsholm Rohde},
	Date-Added = {2008-04-28 01:08:38 -0400},
	Date-Modified = {2008-04-29 03:32:03 -0400},
	Doi = {http://doi.acm.org/10.1145/1146809.1146812},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Keywords = {static analysis},
	Number = {4},
	Pages = {696--714},
	Publisher = {ACM},
	Title = {Fast partial evaluation of pattern matching in strings},
	Volume = {28},
	Year = {2006},
	Abstract = {We show to obtain all of Knuth, Morris, and Pratt's linear-time string matcher by specializing a quadratic-time string matcher with respect to a pattern string. Although it has been known for fifteen years how to obtain this linear matcher by partial evaluation of a quadratic one, how to obtain it \textit{in linear time} has remained an open problem.Obtaining a linear matcher by the partial evaluation of a quadratic one is achieved by performing its backtracking at specialization time and memoizing its results. We show (1) how to rewrite the source matcher such that its static intermediate computations can be shared at specialization time and (2) how to extend the memoization capabilities of a partial evaluator to static functions. Such an extended partial evaluator, if its memoization is implemented efficiently, specializes the rewritten source matcher in linear time. Finally, we show that the method also applies to a variant of Boyer and Moore's string matcher.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFsuLi8uLi9QYXBlcnMvQWdlci9BZ2VyLURhbnZ5LVJvaGRlIC0gRmFzdCBwYXJ0aWFsIGV2YWx1YXRpb24gb2YgcGF0dGVybiBtYXRjaGluZyAoMjAwNikucGRm0hsPHB1XTlMuZGF0YU8RAigAAAAAAigAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADhGjB9BZ2VyLURhbnZ5LVJvaGRlIC0gRiMzODQ2NDEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOEZBxDrSUVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAEQWdlcgAQAAgAAME0fl0AAAARAAgAAMQ7CpEAAAABABAAOEaMAC2RPwADR6wAAGvYAAIAPU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpBZ2VyOkFnZXItRGFudnktUm9oZGUgLSBGIzM4NDY0MS5wZGYAAA4AlABJAEEAZwBlAHIALQBEAGEAbgB2AHkALQBSAG8AaABkAGUAIAAtACAARgBhAHMAdAAgAHAAYQByAHQAaQBhAGwAIABlAHYAYQBsAHUAYQB0AGkAbwBuACAAbwBmACAAcABhAHQAdABlAHIAbgAgAG0AYQB0AGMAaABpAG4AZwAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGJVc2Vycy9qZXJlbXkvUGFwZXJzL0FnZXIvQWdlci1EYW52eS1Sb2hkZSAtIEZhc3QgcGFydGlhbCBldmFsdWF0aW9uIG9mIHBhdHRlcm4gbWF0Y2hpbmcgKDIwMDYpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEIAQ0BFQNBA0MDSANRA1wDYANuA3UDfgODA4YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1146809.1146812}}

@article{Alpuente:Partial:1998,
	Address = {New York, NY, USA},
	Author = {Mar\'{\i}a Alpuente and Moreno Falaschi and Germ\'{a}n Vidal},
	Date-Added = {2008-04-28 01:08:38 -0400},
	Date-Modified = {2008-04-28 01:12:36 -0400},
	Doi = {http://doi.acm.org/10.1145/291891.291896},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Keywords = {static analysis},
	Number = {4},
	Pages = {768--844},
	Publisher = {ACM},
	Title = {Partial evaluation of functional logic programs},
	Volume = {20},
	Year = {1998},
	Abstract = {Languages that integrate functional and logic programming with a complete operational semantics are based on narrowing, a unification-based goal-solving mechanism which subsumes the reduction principle of functional languages and the resolution principle of logic languages. In this article, we present a partial evaluation scheme for functional logic languages based on an automatic unfolding algorithm which builds narrowing trees. The method is formalized within the theoretical framework established by Lloyd and Shepherdson for the partial deduction of logic programs, which we have generalized for dealing with functional computations. A generic specialization algorithm is proposed which does not depend on the eager or lazy nature of the narrower being used. To the best of our knowledge, this is the first generic algorithm for the specialization of functional logic programs. We also discuss the relation to work on partial evaluation in functional programming, term-rewriting systems, and logic programming. Finally, we present some experimental results with an implementation of the algorithm which show in practice that the narrowing-driven partial evaluator effectively combines the propagation of partial data structures (by means of logical variables and unification) with better opportunities for optimization (thanks to the functional dimension).},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGouLi8uLi9QYXBlcnMvQWxwdWVudGUvQWxwdWVudGUtRmFsYXNjaGktVmlkYWwgLSBQYXJ0aWFsIGV2YWx1YXRpb24gb2YgZnVuY3Rpb25hbCBsb2dpYyBwcm9ncmFtcyAoMTk5OCkucGRm0hsPHB1XTlMuZGF0YU8RAlYAAAAAAlYAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADhGjR9BbHB1ZW50ZS1GYWxhc2NoaS1WaSMzODQ2NDQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOEZExDrSYVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIQWxwdWVudGUAEAAIAADBNH5dAAAAEQAIAADEOwqhAAAAAQAQADhGjQAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QWxwdWVudGU6QWxwdWVudGUtRmFsYXNjaGktVmkjMzg0NjQ0LnBkZgAADgCqAFQAQQBsAHAAdQBlAG4AdABlAC0ARgBhAGwAYQBzAGMAaABpAC0AVgBpAGQAYQBsACAALQAgAFAAYQByAHQAaQBhAGwAIABlAHYAYQBsAHUAYQB0AGkAbwBuACAAbwBmACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgAGwAbwBnAGkAYwAgAHAAcgBvAGcAcgBhAG0AcwAgACgAMQA5ADkAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHFVc2Vycy9qZXJlbXkvUGFwZXJzL0FscHVlbnRlL0FscHVlbnRlLUZhbGFzY2hpLVZpZGFsIC0gUGFydGlhbCBldmFsdWF0aW9uIG9mIGZ1bmN0aW9uYWwgbG9naWMgcHJvZ3JhbXMgKDE5OTgpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBFwEcASQDfgOAA4UDjgOZA50DqwOyA7sDwAPDAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA9A=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/291891.291896}}

@article{Baker:Shallow:1991,
	Address = {New York, NY, USA},
	Author = {Henry G. Baker},
	Date-Added = {2008-04-28 01:08:38 -0400},
	Date-Modified = {2008-04-28 01:12:36 -0400},
	Doi = {http://doi.acm.org/10.1145/122598.122614},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Keywords = {static analysis},
	Number = {8},
	Pages = {145--147},
	Publisher = {ACM},
	Title = {Shallow binding makes functional arrays fast},
	Volume = {26},
	Year = {1991},
	Abstract = { Access and update for random elements of arrays in imperative programming languages are O(1) operations. Implementing functional programming languages to achieve equivalent efficiency has proved difficult. We show how the straight-forward application of shallow binding to functional arrays automatically achieves O(1) update for single-threaded usage.
},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE0uLi8uLi9QYXBlcnMvQmFrZXIvQmFrZXIgLSBTaGFsbG93IGJpbmRpbmcgbWFrZXMgZnVuY3Rpb25hbCBhcnJheXMgKDE5OTEpLnBkZtIbDxwdV05TLmRhdGFPEQH+AAAAAAH+AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4Ro4fQmFrZXIgLSBTaGFsbG93IGJpbmQjMzg0NjRGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhGT8Q60pZQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABUJha2VyAAAQAAgAAME0fl0AAAARAAgAAMQ7CtYAAAABABAAOEaOAC2RPwADR6wAAGvYAAIAPk9kaW46VXNlcnM6amVyZW15OlBhcGVyczpCYWtlcjpCYWtlciAtIFNoYWxsb3cgYmluZCMzODQ2NEYucGRmAA4AdgA6AEIAYQBrAGUAcgAgAC0AIABTAGgAYQBsAGwAbwB3ACAAYgBpAG4AZABpAG4AZwAgAG0AYQBrAGUAcwAgAGYAdQBuAGMAdABpAG8AbgBhAGwAIABhAHIAcgBhAHkAcwAgACgAMQA5ADkAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFRVc2Vycy9qZXJlbXkvUGFwZXJzL0Jha2VyL0Jha2VyIC0gU2hhbGxvdyBiaW5kaW5nIG1ha2VzIGZ1bmN0aW9uYWwgYXJyYXlzICgxOTkxKS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA+gD/AQcDCQMLAxADGQMkAygDNgM9A0YDSwNOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA1s=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/122598.122614}}

@inproceedings{Choi:Compiling:2001,
	Address = {London, UK},
	Author = {Kwanghoon Choi and Hyun-il Lim and Taisook Han},
	Booktitle = {FLOPS '01: Proceedings of the 5th International Symposium on Functional and Logic Programming},
	Date-Added = {2008-04-28 01:06:12 -0400},
	Date-Modified = {2008-04-30 21:12:14 -0400},
	Isbn = {3-540-41739-7},
	Pages = {92--107},
	Publisher = {Springer-Verlag},
	Title = {Compiling Lazy Functional Programs Based on the Spineless Tagless G-Machine for the Java Virtual Machine},
	Year = {2001},
	Annote = {See also the slides presented at FLOPS 2001 (Choi:STG-JVM:2001).}}

@article{Mogensen-Ed.:Glossary:2000,
	Address = {Hingham, MA, USA},
	Author = {Mogensen (Ed.), Torben \Ae.},
	Date-Added = {2008-04-28 00:42:44 -0400},
	Date-Modified = {2008-04-28 00:50:01 -0400},
	Doi = {http://dx.doi.org/10.1023/A:1026551132647},
	Issn = {1388-3690},
	Journal = {Higher Order Symbol. Comput.},
	Number = {4},
	Pages = {355--368},
	Publisher = {Kluwer Academic Publishers},
	Title = {Glossary for Partial Evaluation and Related Topics},
	Volume = {13},
	Year = {2000},
	Abstract = {Most areas of research or work use their own set of words and phrases and gives specific technical meaning to terms that in everyday speech may mean something less specific or something else entirely. The area of partial evaluation and program transformation is no different, which may make it hard for the uninitiated to grasp some parts of technical papers or discussions. This list of words and terms is intended as a help to people new in the subject area, but may also be of help to experienced researchers, as different research groups tend to develop different terminology.},
	Bdsk-Url-1 = {http://dx.doi.org/10.1023/A:1026551132647}}

@phdthesis{Bloss:Path:1989,
	Address = {New Haven, Conn., USA},
	Author = {Bloss, Adrienne Gael},
	Date-Added = {2008-04-28 00:27:37 -0400},
	Date-Modified = {2008-04-28 00:34:55 -0400},
	Month = {May},
	Order_No = {AAI9012293},
	School = {Yale University},
	Title = {Path Analysis and the Optimization of Nonstrict Functional Languages},
	Year = {1989},
	Abstract = {The functional programming style is increasingly popular in the research world, but functional languages still execute slowly relative to imperative languages. This is largely because the power and flexibility of functional languages restrict the amount of information readily available to the compiler, hindering its ability to generate good code. This dissertation demonstrates that information about the order of evaluation of expressions can be statically inferred for non-strict functional programs, and that optimizations based on this information can provide substantial speedups at runtime.

We present an exact, non-standard semantics called path semantics that models order of evaluation in a non-strict sequential functional language, and its computable abstraction, path analysis. We show how the information inferred by path analysis can be used for two important optimizations: destructive aggregate updating, in which updates on functional aggregates that are provably not live are done destructively; and more efficient thunks, in which the evaluation status of delayed objects is determined statically whenever possible, eliminating the need for runtime tests. Benchmarks for these optimizations are presented, along with benchmarks for the analyses themselves. Although the full analysis is found to be impractical for large programs, it should serve as the basis for further abstraction.

Alternative models of order of evaluation are also discussed, including a less expensive but less general model for a sequential system, and the extensions that would be required to apply path analysis to a parallel system.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGAuLi8uLi9QYXBlcnMvQmxvc3MvQmxvc3MgLSBQYXRoIEFuYWx5c2lzIGFuZCB0aGUgT3B0aW1pemF0aW9uIG9mIE5vbnN0cmljdCBGdW5jdGlvbmFsICgxOTg5KS5wZGbSGw8cHVdOUy5kYXRhTxECOAAAAAACOAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOEVnH0Jsb3NzIC0gUGF0aCBBbmFseXNpIzM4NDU1OC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4RVjEOsswUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVCbG9zcwAAEAAIAADBNH5dAAAAEQAIAADEOwNwAAAAAQAQADhFZwAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6Qmxvc3M6Qmxvc3MgLSBQYXRoIEFuYWx5c2kjMzg0NTU4LnBkZgAOAJwATQBCAGwAbwBzAHMAIAAtACAAUABhAHQAaAAgAEEAbgBhAGwAeQBzAGkAcwAgAGEAbgBkACAAdABoAGUAIABPAHAAdABpAG0AaQB6AGEAdABpAG8AbgAgAG8AZgAgAE4AbwBuAHMAdAByAGkAYwB0ACAARgB1AG4AYwB0AGkAbwBuAGEAbAAgACgAMQA5ADgAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGdVc2Vycy9qZXJlbXkvUGFwZXJzL0Jsb3NzL0Jsb3NzIC0gUGF0aCBBbmFseXNpcyBhbmQgdGhlIE9wdGltaXphdGlvbiBvZiBOb25zdHJpY3QgRnVuY3Rpb25hbCAoMTk4OSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgENARIBGgNWA1gDXQNmA3EDdQODA4oDkwOYA5sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqA==}}

@article{Reps:Maximal-munch:1998,
	Address = {New York, NY, USA},
	Author = {Thomas Reps},
	Date-Added = {2008-04-27 11:57:15 -0400},
	Date-Modified = {2008-04-27 11:57:38 -0400},
	Doi = {http://doi.acm.org/10.1145/276393.276394},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Number = {2},
	Pages = {259--273},
	Publisher = {ACM},
	Title = {\"Maximal-munch\" tokenization in linear time},
	Volume = {20},
	Year = {1998},
	Abstract = {The lexical-analysis (or scanning) phase of a compiler attempts to partition an input string into a sequence of tokens. The convention in most languages is that the input is scanned left to right, and each token identified is a ``maximal munch'' of the remaining input---the longest prefix of the remaining input that is a token of the language. Although most of the standard compiler textbooks present a way to perform maximal-munch tokenization, the algorithm they describe is one that, for certain sets of token definitions, can cause the scanner to exhibit quadratic behavior in the worst case. In the article, we show that maximal-munch tokenization can always be performed in time linear in the size of the input.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFEuLi8uLi9QYXBlcnMvUmVwcy9SZXBzIC0gXCJNYXhpbWFsLW11bmNoXCIgdG9rZW5pemF0aW9uIGluIGxpbmVhciB0aW1lICgxOTk4KS5wZGbSGw8cHVdOUy5kYXRhTxECCgAAAAACCgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOCvcH1JlcHMgLSBcIk1heGltYWwtbXVuIzM4MkJEOS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4K9nEOhrQUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAARSZXBzABAACAAAwTR+XQAAABEACAAAxDpTEAAAAAEAEAA4K9wALZE/AANHrAAAa9gAAgA9T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlJlcHM6UmVwcyAtIFwiTWF4aW1hbC1tdW4jMzgyQkQ5LnBkZgAADgCAAD8AUgBlAHAAcwAgAC0AIABcACIATQBhAHgAaQBtAGEAbAAtAG0AdQBuAGMAaABcACIAIAB0AG8AawBlAG4AaQB6AGEAdABpAG8AbgAgAGkAbgAgAGwAaQBuAGUAYQByACAAdABpAG0AZQAgACgAMQA5ADkAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFhVc2Vycy9qZXJlbXkvUGFwZXJzL1JlcHMvUmVwcyAtIFwiTWF4aW1hbC1tdW5jaFwiIHRva2VuaXphdGlvbiBpbiBsaW5lYXIgdGltZSAoMTk5OCkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAP4BAwELAxkDGwMgAykDNAM4A0YDTQNWA1sDXgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANr},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/276393.276394}}

@inproceedings{Wadler:The-essence:1992,
	Address = {New York, NY, USA},
	Author = {Philip Wadler},
	Booktitle = {POPL '92: Proceedings of the 19th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
	Date-Added = {2008-04-27 10:43:45 -0400},
	Date-Modified = {2008-04-27 10:43:47 -0400},
	Doi = {http://doi.acm.org/10.1145/143165.143169},
	Isbn = {0-89791-453-8},
	Location = {Albuquerque, New Mexico, United States},
	Pages = {1--14},
	Publisher = {ACM},
	Title = {The essence of functional programming},
	Year = {1992},
	Abstract = {This paper explores the use monads to structure functional programs. No prior knowledge of monads or category theory is required.

Monads increase the ease with which programs may be modified. They can mimic the effect of impure features such as exceptions, state, and continuations; and also provide effects not easily achieved with such features. The types of a program reflect which effects occur.

The first section is an extended example of the use of monads. A simple interpreter is modified to support various extra features: error messages, state, output, and non-deterministic choice. The second section describes the relation between monads and the continuation-passing style. The third section sketches how monads are used in a compiler for Haskell that is written in Haskell.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE0uLi8uLi9QYXBlcnMvV2FkbGVyL1dhZGxlciAtIFRoZSBlc3NlbmNlIG9mIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgKDE5OTIpLnBkZtIbDxwdV05TLmRhdGFPEQH+AAAAAAH+AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtkXgfV2FkbGVyIC0gVGhlIGVzc2VuY2UjMzgyQUVCLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgq68Q6CJpQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABldhZGxlcgAQAAgAAME0fl0AAAARAAgAAMQ6QNoAAAABABAALZF4AC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpXYWRsZXI6V2FkbGVyIC0gVGhlIGVzc2VuY2UjMzgyQUVCLnBkZgAADgB0ADkAVwBhAGQAbABlAHIAIAAtACAAVABoAGUAIABlAHMAcwBlAG4AYwBlACAAbwBmACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMQA5ADkAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFRVc2Vycy9qZXJlbXkvUGFwZXJzL1dhZGxlci9XYWRsZXIgLSBUaGUgZXNzZW5jZSBvZiBmdW5jdGlvbmFsIHByb2dyYW1taW5nICgxOTkyKS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA+gD/AQcDCQMLAxADGQMkAygDNgM9A0YDSwNOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA1s=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/143165.143169}}

@article{Tofte:A-region:1998,
	Address = {New York, NY, USA},
	Author = {Mads Tofte and Lars Birkedal},
	Date-Added = {2008-04-27 10:43:45 -0400},
	Date-Modified = {2008-04-27 10:43:48 -0400},
	Doi = {http://doi.acm.org/10.1145/291891.291894},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Number = {4},
	Pages = {724--767},
	Publisher = {ACM},
	Title = {A region inference algorithm},
	Volume = {20},
	Year = {1998},
	Abstract = {Region Inference is a program analysis which infers lifetimes of values. It is targeted at a runtime model in which the store consists of a stack of regions and memory management predominantly consists of pushing and popping regions, rather than performing garbage collection. Region Inference has previously been specified by a set of inference rules which formalize when regions may be allocated and deallocated. This article presents an algorithm which implements the specification. We prove that the algorithm is sound with respect to the region inference rules and that it always terminates even though the region inference rules permit polymorphic recursion in regions. The algorithm is the result of several years of experiments with region inference algorithms in the ML Kit, a compiler from Standard ML to assembly language. We report on practical experience with the algorithm and give hints on how to implement it.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEsuLi8uLi9QYXBlcnMvVG9mdGUvVG9mdGUtQmlya2VkYWwgLSBBIHJlZ2lvbiBpbmZlcmVuY2UgYWxnb3JpdGhtICgxOTk4KS5wZGbSGw8cHVdOUy5kYXRhTxEB+AAAAAAB+AACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOCsQH1RvZnRlLUJpcmtlZGFsIC0gQSByIzM4MkIwRS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4Kw7EOglOUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVUb2Z0ZQAAEAAIAADBNH5dAAAAEQAIAADEOkGOAAAAAQAQADgrEAAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6VG9mdGU6VG9mdGUtQmlya2VkYWwgLSBBIHIjMzgyQjBFLnBkZgAOAHIAOABUAG8AZgB0AGUALQBCAGkAcgBrAGUAZABhAGwAIAAtACAAQQAgAHIAZQBnAGkAbwBuACAAaQBuAGYAZQByAGUAbgBjAGUAIABhAGwAZwBvAHIAaQB0AGgAbQAgACgAMQA5ADkAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFJVc2Vycy9qZXJlbXkvUGFwZXJzL1RvZnRlL1RvZnRlLUJpcmtlZGFsIC0gQSByZWdpb24gaW5mZXJlbmNlIGFsZ29yaXRobSAoMTk5OCkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPgA/QEFAwEDAwMIAxEDHAMgAy4DNQM+A0MDRgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANT},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/291891.291894}}

@article{Butterworth:The-GemStone:1991,
	Address = {New York, NY, USA},
	Author = {Paul Butterworth and Allen Otis and Jacob Stein},
	Date-Added = {2008-04-27 10:43:45 -0400},
	Date-Modified = {2008-04-27 10:43:47 -0400},
	Doi = {http://doi.acm.org/10.1145/125223.125254},
	Issn = {0001-0782},
	Journal = {Commun. ACM},
	Number = {10},
	Pages = {64--77},
	Publisher = {ACM},
	Title = {The GemStone object database management system},
	Volume = {34},
	Year = {1991},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGsuLi8uLi9QYXBlcnMvQnV0dGVyd29ydGgvQnV0dGVyd29ydGgtT3Rpcy1TdGVpbiAtIFRoZSBHZW1TdG9uZSBvYmplY3QgZGF0YWJhc2UgbWFuYWdlbWVudCBzeXN0ZW0gKDE5OTEpLnBkZtIbDxwdV05TLmRhdGFPEQJYAAAAAAJYAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4KxEfQnV0dGVyd29ydGgtT3Rpcy1TdGUjMzgyQUYwLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgq8MQ6CMNQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAC0J1dHRlcndvcnRoAAAQAAgAAME0fl0AAAARAAgAAMQ6QQMAAAABABAAOCsRAC2RPwADR6wAAGvYAAIARE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpCdXR0ZXJ3b3J0aDpCdXR0ZXJ3b3J0aC1PdGlzLVN0ZSMzODJBRjAucGRmAA4ApgBSAEIAdQB0AHQAZQByAHcAbwByAHQAaAAtAE8AdABpAHMALQBTAHQAZQBpAG4AIAAtACAAVABoAGUAIABHAGUAbQBTAHQAbwBuAGUAIABvAGIAagBlAGMAdAAgAGQAYQB0AGEAYgBhAHMAZQAgAG0AYQBuAGEAZwBlAG0AZQBuAHQAIABzAHkAcwB0AGUAbQAgACgAMQA5ADkAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHJVc2Vycy9qZXJlbXkvUGFwZXJzL0J1dHRlcndvcnRoL0J1dHRlcndvcnRoLU90aXMtU3RlaW4gLSBUaGUgR2VtU3RvbmUgb2JqZWN0IGRhdGFiYXNlIG1hbmFnZW1lbnQgc3lzdGVtICgxOTkxKS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBGAEdASUDgQODA4gDkQOcA6ADrgO1A74DwwPGAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA9M=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/125223.125254}}

@techreport{Douence:A-Taxonomy:1995,
	Address = {Rennes, France},
	Author = {R\'{e}mi Douence and Pascal Fradet},
	Date-Added = {2008-04-27 02:39:01 -0400},
	Date-Modified = {2008-04-27 02:40:38 -0400},
	Institution = {INRIA},
	Number = {2783},
	Title = {A Taxonomy of Functional Language Implementations. {P}art {I}: Call-by-value},
	Type = {Research Report},
	Year = {1995},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGguLi8uLi9QYXBlcnMvRG91ZW5jZS9Eb3VlbmNlLUZyYWRldCAtIEEgVGF4b25vbXkgb2YgRnVuY3Rpb25hbCBMYW5ndWFnZSBJbXBsZW1lbnRhdGlvbnMuIFBhcnQgKDE5OTUpLnBkZtIbDxwdV05TLmRhdGFPEQJQAAAAAAJQAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtk0kfRG91ZW5jZS1GcmFkZXQgLSBBIFQjMzgyOEZCLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgo+8Q5lvcAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAB0RvdWVuY2UAABAACAAAwTR+XQAAABEACAAAxDnPNwAAAAEAEAAtk0kALZE/AANHrAAAa9gAAgBAT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkRvdWVuY2U6RG91ZW5jZS1GcmFkZXQgLSBBIFQjMzgyOEZCLnBkZgAOAKgAUwBEAG8AdQBlAG4AYwBlAC0ARgByAGEAZABlAHQAIAAtACAAQQAgAFQAYQB4AG8AbgBvAG0AeQAgAG8AZgAgAEYAdQBuAGMAdABpAG8AbgBhAGwAIABMAGEAbgBnAHUAYQBnAGUAIABJAG0AcABsAGUAbQBlAG4AdABhAHQAaQBvAG4AcwAuACAAUABhAHIAdAAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG9Vc2Vycy9qZXJlbXkvUGFwZXJzL0RvdWVuY2UvRG91ZW5jZS1GcmFkZXQgLSBBIFRheG9ub215IG9mIEZ1bmN0aW9uYWwgTGFuZ3VhZ2UgSW1wbGVtZW50YXRpb25zLiBQYXJ0ICgxOTk1KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARUBGgEiA3YDeAN9A4YDkQOVA6MDqgOzA7gDuwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAPI}}

@techreport{Douence:A-Taxonomy:1995b,
	Address = {Rennes, France},
	Author = {R\'{e}mi Douence and Pascal Fradet},
	Date-Added = {2008-04-27 02:35:04 -0400},
	Date-Modified = {2008-04-27 02:41:19 -0400},
	Institution = {INRIA},
	Number = {3050},
	Title = {A Taxonomy of Functional Language Implementations. {P}art {II}: Call-by-name, call-by-need, and graph reduction},
	Type = {Research Report},
	Year = {1995},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGkuLi8uLi9QYXBlcnMvRG91ZW5jZS9Eb3VlbmNlLUZyYWRldCAtIEEgVGF4b25vbXkgb2YgRnVuY3Rpb25hbCBMYW5ndWFnZSBJbXBsZW1lbnRhdGlvbnMuIFBhcnQgKDE5OTVhKS5wZGbSGw8cHVdOUy5kYXRhTxECUgAAAAACUgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZNJH0RvdWVuY2UtRnJhZGV0IC0gQSBUIzM4MjkwMS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4KQHEOZcAAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdEb3VlbmNlAAAQAAgAAME0fl0AAAARAAgAAMQ5z0AAAAABABAALZNJAC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpEb3VlbmNlOkRvdWVuY2UtRnJhZGV0IC0gQSBUIzM4MjkwMS5wZGYADgCqAFQARABvAHUAZQBuAGMAZQAtAEYAcgBhAGQAZQB0ACAALQAgAEEAIABUAGEAeABvAG4AbwBtAHkAIABvAGYAIABGAHUAbgBjAHQAaQBvAG4AYQBsACAATABhAG4AZwB1AGEAZwBlACAASQBtAHAAbABlAG0AZQBuAHQAYQB0AGkAbwBuAHMALgAgAFAAYQByAHQAIAAoADEAOQA5ADUAYQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHBVc2Vycy9qZXJlbXkvUGFwZXJzL0RvdWVuY2UvRG91ZW5jZS1GcmFkZXQgLSBBIFRheG9ub215IG9mIEZ1bmN0aW9uYWwgTGFuZ3VhZ2UgSW1wbGVtZW50YXRpb25zLiBQYXJ0ICgxOTk1YSkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARYBGwEjA3kDewOAA4kDlAOYA6YDrQO2A7sDvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAPL}}

@article{Frenger:Ten-years:2005,
	Address = {New York, NY, USA},
	Author = {Paul Frenger},
	Date-Added = {2008-04-27 01:29:17 -0400},
	Date-Modified = {2008-04-27 01:29:27 -0400},
	Doi = {http://doi.acm.org/10.1145/1107541.1107543},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {11},
	Pages = {4--16},
	Publisher = {ACM},
	Title = {Ten years of Forth in ACM Sigplan Notices: part 1},
	Volume = {40},
	Year = {2005},
	Abstract = {So here we are: ten years of the \textit{ACM Sigplan Notices Forth Report} is behind us. How amazing it is that we have reached this milestone! I hope that this column's longevity is a reflection of its popularity and perceived value to our readers.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFkuLi8uLi9QYXBlcnMvRnJlbmdlci9GcmVuZ2VyIC0gVGVuIHllYXJzIG9mIEZvcnRoIGluIEFDTSBTaWdwbGFuIE5vdGljZXM6IHBhcnQgKDIwMDUpLnBkZtIbDxwdV05TLmRhdGFPEQIiAAAAAAIiAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4KIsfRnJlbmdlciAtIFRlbiB5ZWFycyAjMzgyODE0LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgoFMQ5gnJQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAB0ZyZW5nZXIAABAACAAAwTR+XQAAABEACAAAxDm6sgAAAAEAEAA4KIsALZE/AANHrAAAa9gAAgBAT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkZyZW5nZXI6RnJlbmdlciAtIFRlbiB5ZWFycyAjMzgyODE0LnBkZgAOAIoARABGAHIAZQBuAGcAZQByACAALQAgAFQAZQBuACAAeQBlAGEAcgBzACAAbwBmACAARgBvAHIAdABoACAAaQBuACAAQQBDAE0AIABTAGkAZwBwAGwAYQBuACAATgBvAHQAaQBjAGUAcwAvACAAcABhAHIAdAAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGBVc2Vycy9qZXJlbXkvUGFwZXJzL0ZyZW5nZXIvRnJlbmdlciAtIFRlbiB5ZWFycyBvZiBGb3J0aCBpbiBBQ00gU2lncGxhbiBOb3RpY2VzOiBwYXJ0ICgyMDA1KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBBgELARMDOQM7A0ADSQNUA1gDZgNtA3YDewN+AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA4s=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1107541.1107543}}

@inproceedings{Altenkirch:Observational:2007,
	Address = {New York, NY, USA},
	Author = {Thorsten Altenkirch and Conor McBride and Wouter Swierstra},
	Booktitle = {PLPV '07: Proceedings of the 2007 workshop on Programming languages meets program verification},
	Date-Added = {2008-04-27 01:29:17 -0400},
	Date-Modified = {2008-04-27 01:31:29 -0400},
	Doi = {http://doi.acm.org/10.1145/1292597.1292608},
	Isbn = {978-1-59593-677-6},
	Location = {Freiburg, Germany},
	Pages = {57--68},
	Publisher = {ACM},
	Title = {Observational equality, now!},
	Year = {2007},
	Abstract = {


This paper has something new and positive to say about propositional equality in programming and proof systems based on the Curry--Howard correspondence between propositions and types. We have found a way to present a propositional equality type

\begin{itemize}
    \item which is \textit{substitutive,} allowing us to reason by replacing equal for equal in propositions;
    \item which reflects the \textit{observable} behaviour of values rather than their construction: in particular, we have extensionality-- functions are equal if they take equal inputs to equal outputs;
    \item which retains \textit{strong} normalisation, \textit{decidable} typechecking and \textit{canonicity} -- the property that closed normal forms inhabiting datatypes have canonical constructors;
    \item which allows inductive data structures to be expressed in terms of a standard characterisation of \textit{well-founded trees};
    \item which is presented \textit{syntactically} -- you can implement it directly, and we are doing so this approach stands at the core of Epigram 2;
    \item which you can play with now: we have simulated our system by a shallow embedding in Agda 2, shipping as part of the standard examples package for that system [21].
\end{itemize}

Until now, it has always been necessary to sacrifice some of these aspects. The closest attempt in the literature is Altenkirch's construction of a setoid-model for a system with canonicity and extensionality on top of an intensional type theory with proof-irrelevant propositions [4]. Our new proposal simplifies Altenkirch's construction by adopting McBride's heterogeneous approach to equality [19].},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEF4uLi8uLi9QYXBlcnMvQWx0ZW5raXJjaC9BbHRlbmtpcmNoLU1jQnJpZGUtU3dpZXJzdHJhIC0gT2JzZXJ2YXRpb25hbCBlcXVhbGl0eSwgbm93ISAoMjAwNykucGRm0hsPHB1XTlMuZGF0YU8RAjIAAAAAAjIAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADH2KB9BbHRlbmtpcmNoLU1jQnJpZGUtUyMzODI4NjEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOChhxDmF7FBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAKQWx0ZW5raXJjaAAQAAgAAME0fl0AAAARAAgAAMQ5viwAAAABABAAMfYoAC2RPwADR6wAAGvYAAIAQ09kaW46VXNlcnM6amVyZW15OlBhcGVyczpBbHRlbmtpcmNoOkFsdGVua2lyY2gtTWNCcmlkZS1TIzM4Mjg2MS5wZGYAAA4AjgBGAEEAbAB0AGUAbgBrAGkAcgBjAGgALQBNAGMAQgByAGkAZABlAC0AUwB3AGkAZQByAHMAdAByAGEAIAAtACAATwBiAHMAZQByAHYAYQB0AGkAbwBuAGEAbAAgAGUAcQB1AGEAbABpAHQAeQAsACAAbgBvAHcAIQAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGVVc2Vycy9qZXJlbXkvUGFwZXJzL0FsdGVua2lyY2gvQWx0ZW5raXJjaC1NY0JyaWRlLVN3aWVyc3RyYSAtIE9ic2VydmF0aW9uYWwgZXF1YWxpdHksIG5vdyEgKDIwMDcpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBCwEQARgDTgNQA1UDXgNpA20DewOCA4sDkAOTAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA6A=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1292597.1292608}}

@article{Abbott:partial:2005,
	Address = {Amsterdam, The Netherlands, The Netherlands},
	Author = {Michael Abbott and Thorsten Altenkirch and Conor McBride and Neil Ghani},
	Date-Added = {2008-04-27 01:29:17 -0400},
	Date-Modified = {2008-04-27 01:29:27 -0400},
	Issn = {0169-2968},
	Journal = {Fundam. Inf.},
	Number = {1-2},
	Pages = {1--28},
	Publisher = {IOS Press},
	Title = {$\partial$ for Data: Differentiating Data Structures},
	Url = {http://strictlypositive.org/publications.html},
	Volume = {65},
	Year = {2005},
	Abstract = {This paper and our conference paper (Abbott, Altenkirch, Ghani, and McBride, 2003b) explain and analyse the notion of the derivative of a data structure as the type of its one-hole contexts based on the central observation made by McBride (2001). To make the idea precise we need a generic notion of a data type, which leads to the notion of a container, introduced in (Abbott, Altenkirch, and Ghani, 2003a) and investigated extensively in (Abbott, 2003). Using containers we can provide a notion of linear map which is the concept missing from McBride's first analysis. We verify the usual laws of differential calculus including the chain rule and establish laws for initial algebras and terminal coalgebras.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEG8uLi8uLi9QYXBlcnMvQWJib3R0L0FiYm90dC1BbHRlbmtpcmNoLU1jQnJpZGUgLSAkXHBhcnRpYWwkIGZvciBEYXRhOiBEaWZmZXJlbnRpYXRpbmcgRGF0YSBTdHJ1Y3R1cmVzICgyMDA1KS5wZGbSGw8cHVdOUy5kYXRhTxECZAAAAAACZAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOCiJH0FiYm90dC1BbHRlbmtpcmNoLU1jIzM4MjgyRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4KC/EOYQ/AAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZBYmJvdHQAEAAIAADBNH5dAAAAEQAIAADEObx/AAAAAQAQADgoiQAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QWJib3R0OkFiYm90dC1BbHRlbmtpcmNoLU1jIzM4MjgyRi5wZGYAAA4AuABbAEEAYgBiAG8AdAB0AC0AQQBsAHQAZQBuAGsAaQByAGMAaAAtAE0AYwBCAHIAaQBkAGUAIAAtACAAJABcAHAAYQByAHQAaQBhAGwAJAAgAGYAbwByACAARABhAHQAYQAvACAARABpAGYAZgBlAHIAZQBuAHQAaQBhAHQAaQBuAGcAIABEAGEAdABhACAAUwB0AHIAdQBjAHQAdQByAGUAcwAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHZVc2Vycy9qZXJlbXkvUGFwZXJzL0FiYm90dC9BYmJvdHQtQWx0ZW5raXJjaC1NY0JyaWRlIC0gJFxwYXJ0aWFsJCBmb3IgRGF0YTogRGlmZmVyZW50aWF0aW5nIERhdGEgU3RydWN0dXJlcyAoMjAwNSkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARwBIQEpA5EDkwOYA6EDrAOwA74DxQPOA9MD1gAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAPj},
	Bdsk-Url-1 = {http://strictlypositive.org/publications.html}}

@article{Peyton-Jones:Call-pattern:2007,
	Address = {New York, NY, USA},
	Author = {Peyton Jones, Simon},
	Date-Added = {2008-04-27 01:29:17 -0400},
	Date-Modified = {2008-04-29 03:34:21 -0400},
	Doi = {http://doi.acm.org/10.1145/1291220.1291200},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {9},
	Pages = {327--337},
	Publisher = {ACM},
	Title = {Call-pattern specialisation for Haskell programs},
	Volume = {42},
	Year = {2007},
	Abstract = {User-defined data types, pattern-matching, and recursion are ubiquitous features of Haskell programs. Sometimes a function is called with arguments that are statically known to be in constructor form, so that the work of pattern-matching is wasted. Even worse, the argument is sometimes freshly-allocated, only to be immediately decomposed by the function.

In this paper we describe a simple, modular transformation that specialises recursive functions according to their argument "shapes". We describe our implementation of this transformation in the Glasgow Haskell Compiler, and give measurements that demonstrate substantial performance improvements: a worthwhile 10\% on average, with a factor of 10 in particular cases.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFYuLi8uLi9QYXBlcnMvSm9uZXMvSm9uZXMgLSBDYWxsLXBhdHRlcm4gc3BlY2lhbGlzYXRpb24gZm9yIEhhc2tlbGwgcHJvZ3JhbXMgKDIwMDcpLnBkZtIbDxwdV05TLmRhdGFPEQIaAAAAAAIaAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4KAQfSm9uZXMgLSBDYWxsLXBhdHRlcm4jMjlGOEEwLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACn4oAAAAAAAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABUpvbmVzAAAQAAgAAME0fl0AAAARAAgAAAAAAAAAAAABABAAOCgEAC2RPwADR6wAAGvYAAIAPk9kaW46VXNlcnM6amVyZW15OlBhcGVyczpKb25lczpKb25lcyAtIENhbGwtcGF0dGVybiMyOUY4QTAucGRmAA4AiABDAEoAbwBuAGUAcwAgAC0AIABDAGEAbABsAC0AcABhAHQAdABlAHIAbgAgAHMAcABlAGMAaQBhAGwAaQBzAGEAdABpAG8AbgAgAGYAbwByACAASABhAHMAawBlAGwAbAAgAHAAcgBvAGcAcgBhAG0AcwAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF1Vc2Vycy9qZXJlbXkvUGFwZXJzL0pvbmVzL0pvbmVzIC0gQ2FsbC1wYXR0ZXJuIHNwZWNpYWxpc2F0aW9uIGZvciBIYXNrZWxsIHByb2dyYW1zICgyMDA3KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQMBCAEQAy4DMAM1Az4DSQNNA1sDYgNrA3ADcwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOA},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1291220.1291200}}

@article{Le-Fessant:Optimizing:2001,
	Address = {New York, NY, USA},
	Author = {Le Fessant, Fabrice and Luc Maranget},
	Date-Added = {2008-04-27 01:29:17 -0400},
	Date-Modified = {2008-04-27 01:29:27 -0400},
	Doi = {http://doi.acm.org/10.1145/507546.507641},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {10},
	Pages = {26--37},
	Publisher = {ACM},
	Title = {Optimizing pattern matching},
	Volume = {36},
	Year = {2001},
	Abstract = {We present improvements to the backtracking technique of pattern-matching compilation. Several optimizations are introduced, such as commutation of patterns, use of exhaustiveness information, and control flow optimization through the use of labeled static exceptions and context information. These optimizations have been integrated in the Objective-Caml compiler. They have shown good results in increasing the speed of pattern-matching intensive programs, without increasing final code size.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFQuLi8uLi9QYXBlcnMvTGUgRmVzc2FudC9MZSBGZXNzYW50LU1hcmFuZ2V0IC0gT3B0aW1pemluZyBwYXR0ZXJuIG1hdGNoaW5nICgyMDAxKS5wZGbSGw8cHVdOUy5kYXRhTxECFAAAAAACFAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOCiMH0xlIEZlc3NhbnQtTWFyYW5nZXQgIzM4Mjg3OC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4KHjEOYcyUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAApMZSBGZXNzYW50ABAACAAAwTR+XQAAABEACAAAxDm/cgAAAAEAEAA4KIwALZE/AANHrAAAa9gAAgBDT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkxlIEZlc3NhbnQ6TGUgRmVzc2FudC1NYXJhbmdldCAjMzgyODc4LnBkZgAADgB6ADwATABlACAARgBlAHMAcwBhAG4AdAAtAE0AYQByAGEAbgBnAGUAdAAgAC0AIABPAHAAdABpAG0AaQB6AGkAbgBnACAAcABhAHQAdABlAHIAbgAgAG0AYQB0AGMAaABpAG4AZwAgACgAMgAwADAAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFtVc2Vycy9qZXJlbXkvUGFwZXJzL0xlIEZlc3NhbnQvTGUgRmVzc2FudC1NYXJhbmdldCAtIE9wdGltaXppbmcgcGF0dGVybiBtYXRjaGluZyAoMjAwMSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEBAQYBDgMmAygDLQM2A0EDRQNTA1oDYwNoA2sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADeA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/507546.507641}}

@incollection{Restall:Relevant:2006,
	Author = {Greg Restall},
	Date-Added = {2008-04-27 01:29:17 -0400},
	Date-Modified = {2008-04-27 01:29:27 -0400},
	Editor = {Dov Gabbay and John Woods},
	Inbook = {Handbook of the History of Logic},
	Pages = {289--398},
	Publisher = {Elsevier},
	Series = {Logic and the Modalities in the Twentieth Century},
	Title = {Relevant and Substructural Logics},
	Url = {http://consequently.org/writing/hpplrssl/},
	Volume = {7},
	Year = {2006},
	Abstract = {An historical essay, sketching the development of relevant and substructural logics throughout the 20th Century and into the 21st.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEsuLi8uLi9QYXBlcnMvUmVzdGFsbC9SZXN0YWxsIC0gUmVsZXZhbnQgYW5kIFN1YnN0cnVjdHVyYWwgTG9naWNzICgyMDA2KS5wZGbSGw8cHVdOUy5kYXRhTxEB+AAAAAAB+AACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOCiKH1Jlc3RhbGwgLSBSZWxldmFudCBhIzM4Mjg3MC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4KHDEOYcYAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdSZXN0YWxsAAAQAAgAAME0fl0AAAARAAgAAMQ5v1gAAAABABAAOCiKAC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpSZXN0YWxsOlJlc3RhbGwgLSBSZWxldmFudCBhIzM4Mjg3MC5wZGYADgBuADYAUgBlAHMAdABhAGwAbAAgAC0AIABSAGUAbABlAHYAYQBuAHQAIABhAG4AZAAgAFMAdQBiAHMAdAByAHUAYwB0AHUAcgBhAGwAIABMAG8AZwBpAGMAcwAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFJVc2Vycy9qZXJlbXkvUGFwZXJzL1Jlc3RhbGwvUmVzdGFsbCAtIFJlbGV2YW50IGFuZCBTdWJzdHJ1Y3R1cmFsIExvZ2ljcyAoMjAwNikucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPgA/QEFAwEDAwMIAxEDHAMgAy4DNQM+A0MDRgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANT},
	Bdsk-Url-1 = {http://consequently.org/writing/hpplrssl/}}

@article{Peyton-Jones:Implementing:1992,
	Author = {Peyton Jones, Simon},
	Date-Added = {2008-04-27 01:05:30 -0400},
	Date-Modified = {2008-05-02 05:04:59 -0400},
	Journal = {Journal of Functional Programming},
	Month = {April},
	Number = {2},
	Pages = {127-202},
	Title = {Implementing lazy functional languages on stock hardware: {T}he {S}pineless {T}agless {G}-machine},
	Url = {http://research.microsoft.com/copyright/accept.asp?path=/users/simonpj/papers/spineless-tagless-gmachine.ps.gz&pub=34},
	Volume = {2},
	Year = {1992},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFUuLi8uLi9QYXBlcnMvSm9uZXMvSm9uZXMgLSBJbXBsZW1lbnRpbmcgbGF6eSBmdW5jdGlvbmFsIGxhbmd1YWdlcyBvbiBzdG9jayAoMTk5MikucGRm0hsPHB1XTlMuZGF0YU8RAhYAAAAAAhYAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADgoBB9Kb25lcyAtIEltcGxlbWVudGluZyMyOUY4QTIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKfiiAAAAAAAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAFSm9uZXMAABAACAAAwTR+XQAAABEACAAAAAAAAAAAAAEAEAA4KAQALZE/AANHrAAAa9gAAgA+T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkpvbmVzOkpvbmVzIC0gSW1wbGVtZW50aW5nIzI5RjhBMi5wZGYADgCGAEIASgBvAG4AZQBzACAALQAgAEkAbQBwAGwAZQBtAGUAbgB0AGkAbgBnACAAbABhAHoAeQAgAGYAdQBuAGMAdABpAG8AbgBhAGwAIABsAGEAbgBnAHUAYQBnAGUAcwAgAG8AbgAgAHMAdABvAGMAawAgACgAMQA5ADkAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFxVc2Vycy9qZXJlbXkvUGFwZXJzL0pvbmVzL0pvbmVzIC0gSW1wbGVtZW50aW5nIGxhenkgZnVuY3Rpb25hbCBsYW5ndWFnZXMgb24gc3RvY2sgKDE5OTIpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgECAQcBDwMpAysDMAM5A0QDSANWA10DZgNrA24AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADew==},
	Bdsk-Url-1 = {http://research.microsoft.com/copyright/accept.asp?path=/users/simonpj/papers/spineless-tagless-gmachine.ps.gz&pub=34}}

@article{Coutts:Stream:2007,
	Address = {New York, NY, USA},
	Author = {Duncan Coutts and Roman Leshchinskiy and Don Stewart},
	Date-Added = {2008-04-27 01:05:30 -0400},
	Date-Modified = {2008-04-27 01:05:37 -0400},
	Doi = {http://doi.acm.org/10.1145/1291220.1291199},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {9},
	Pages = {315--326},
	Publisher = {ACM},
	Title = {Stream fusion: from lists to streams to nothing at all},
	Volume = {42},
	Year = {2007},
	Abstract = {This paper presents an automatic deforestation system, \textit{stream fusion,} based on equational transformations, that fuses a wider range of functions than existing short-cut fusion systems. In particular, stream fusion is able to fuse zips, left folds and functions over nested lists, including list comprehensions. A distinguishing feature of the framework is its simplicity: by transforming list functions to expose their structure, intermediate values are eliminated by general purpose compiler optimisations.

We have reimplemented the Haskell standard List library on top of our framework, providing stream fusion for Haskell lists. By allowing a wider range of functions to fuse, we see an increase in the number of occurrences of fusion in typical Haskell programs. We present benchmarks documenting time and space improvements.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGEuLi8uLi9QYXBlcnMvQ291dHRzL0NvdXR0cy1MZXNoY2hpbnNraXktU3Rld2FydCAtIFN0cmVhbSBmdXNpb246IGZyb20gbGlzdHMgdG8gc3RyZWFtcyAoMjAwNykucGRm0hsPHB1XTlMuZGF0YU8RAjoAAAAAAjoAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADgoCR9Db3V0dHMtTGVzaGNoaW5za2l5LSMyOUY4OUYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKfifAAAAAAAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGQ291dHRzABAACAAAwTR+XQAAABEACAAAAAAAAAAAAAEAEAA4KAkALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkNvdXR0czpDb3V0dHMtTGVzaGNoaW5za2l5LSMyOUY4OUYucGRmAAAOAJwATQBDAG8AdQB0AHQAcwAtAEwAZQBzAGgAYwBoAGkAbgBzAGsAaQB5AC0AUwB0AGUAdwBhAHIAdAAgAC0AIABTAHQAcgBlAGEAbQAgAGYAdQBzAGkAbwBuAC8AIABmAHIAbwBtACAAbABpAHMAdABzACAAdABvACAAcwB0AHIAZQBhAG0AcwAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGhVc2Vycy9qZXJlbXkvUGFwZXJzL0NvdXR0cy9Db3V0dHMtTGVzaGNoaW5za2l5LVN0ZXdhcnQgLSBTdHJlYW0gZnVzaW9uOiBmcm9tIGxpc3RzIHRvIHN0cmVhbXMgKDIwMDcpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEOARMBGwNZA1sDYANpA3QDeAOGA40DlgObA54AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1291220.1291199}}

@article{Marlow:Faster:2007,
	Address = {New York, NY, USA},
	Author = {Simon Marlow and Alexey Rodriguez Yakushev and Simon Peyton Jones},
	Date-Added = {2008-04-27 01:05:30 -0400},
	Date-Modified = {2008-04-27 01:05:37 -0400},
	Doi = {http://doi.acm.org/10.1145/1291220.1291194},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {9},
	Pages = {277--288},
	Publisher = {ACM},
	Title = {Faster laziness using dynamic pointer tagging},
	Volume = {42},
	Year = {2007},
	Abstract = {In the light of evidence that Haskell programs compiled by GHC exhibit large numbers of mispredicted branches on modern processors, we re-examine the "tagless" aspect of the STG-machine that GHC uses as its evaluation model.

We propose two tagging strategies: a simple strategy called semi-tagging that seeks to avoid one common source of unpredictable indirect jumps, and a more complex strategy called dynamic pointer-tagging that uses the spare low bits in a pointer to encode information about the pointed-to object. Both of these strategies have been implemented and exhaustively measured in the context of a production compiler, GHC, and the paper contains detailed descriptions of the implementations. Our measurements demonstrate significant performance improvements (14% for dynamic pointer-tagging with only a 2% increase in code size), and we further demonstrate that much of the improvement can be attributed to the elimination of mispredicted branch instructions.

As part of our investigations we also discovered that one optimisation in the STG-machine, vectored-returns, is no longer worthwhile and we explain why.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFwuLi8uLi9QYXBlcnMvTWFybG93L01hcmxvdy1ZYWt1c2hldi1Kb25lcyAtIEZhc3RlciBsYXppbmVzcyB1c2luZyBkeW5hbWljIHBvaW50ZXIgKDIwMDcpLnBkZtIbDxwdV05TLmRhdGFPEQIsAAAAAAIsAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtk1QfTWFybG93LVlha3VzaGV2LUpvbmUjMjlGOEExLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACn4oQAAAAAAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABk1hcmxvdwAQAAgAAME0fl0AAAARAAgAAAAAAAAAAAABABAALZNUAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpNYXJsb3c6TWFybG93LVlha3VzaGV2LUpvbmUjMjlGOEExLnBkZgAADgCSAEgATQBhAHIAbABvAHcALQBZAGEAawB1AHMAaABlAHYALQBKAG8AbgBlAHMAIAAtACAARgBhAHMAdABlAHIAIABsAGEAegBpAG4AZQBzAHMAIAB1AHMAaQBuAGcAIABkAHkAbgBhAG0AaQBjACAAcABvAGkAbgB0AGUAcgAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGNVc2Vycy9qZXJlbXkvUGFwZXJzL01hcmxvdy9NYXJsb3ctWWFrdXNoZXYtSm9uZXMgLSBGYXN0ZXIgbGF6aW5lc3MgdXNpbmcgZHluYW1pYyBwb2ludGVyICgyMDA3KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQkBDgEWA0YDSANNA1YDYQNlA3MDegODA4gDiwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOY},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1291220.1291194}}

@article{Bunder:Variants:2004,
	Author = {Bunder, M. W. and Seldin, Jonathan P.},
	Date-Added = {2008-04-27 00:52:06 -0400},
	Date-Modified = {2008-04-27 00:52:53 -0400},
	Journal = {Journal of Applied Logic},
	Keywords = {calculus of constructions; typed lambda calculus; pure type systems},
	Number = {2},
	Pages = {191--217},
	Title = {Variants of the basic calculus of constructions},
	Title1 = {Variants of Logics: from HOL to the calculus of constructions to teaching mathematical proofs on computers  },
	Url = {http://www.sciencedirect.com/science/article/B758H-4C5HS0K-1/1/950b844502e73368538606462a7a6b62  },
	Volume = {2},
	Year = {2004},
	Abstract = { In this paper, a number of different versions of the basic calculus of constructions that have appeared in the literature are compared and the exact relationships between them are determined. The biggest differences between versions are those between the original version of Coquand and the version in early papers on the subject by Seldin. None of these results is very deep, but it seems useful to collect them in one place.  },
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEF4uLi8uLi9QYXBlcnMvQnVuZGVyL0J1bmRlci1TZWxkaW4gLSBWYXJpYW50cyBvZiB0aGUgYmFzaWMgY2FsY3VsdXMgb2YgY29uc3RydWN0aW9ucyAoMjAwNCkucGRm0hsPHB1XTlMuZGF0YU8RAjIAAAAAAjIAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADgnxR9CdW5kZXItU2VsZGluIC0gVmFyaSMzODI3QTUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOCelxDlTFAAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGQnVuZGVyABAACAAAwTR+XQAAABEACAAAxDmLVAAAAAEAEAA4J8UALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkJ1bmRlcjpCdW5kZXItU2VsZGluIC0gVmFyaSMzODI3QTUucGRmAAAOAJYASgBCAHUAbgBkAGUAcgAtAFMAZQBsAGQAaQBuACAALQAgAFYAYQByAGkAYQBuAHQAcwAgAG8AZgAgAHQAaABlACAAYgBhAHMAaQBjACAAYwBhAGwAYwB1AGwAdQBzACAAbwBmACAAYwBvAG4AcwB0AHIAdQBjAHQAaQBvAG4AcwAgACgAMgAwADAANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGVVc2Vycy9qZXJlbXkvUGFwZXJzL0J1bmRlci9CdW5kZXItU2VsZGluIC0gVmFyaWFudHMgb2YgdGhlIGJhc2ljIGNhbGN1bHVzIG9mIGNvbnN0cnVjdGlvbnMgKDIwMDQpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBCwEQARgDTgNQA1UDXgNpA20DewOCA4sDkAOTAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA6A=},
	Bdsk-Url-1 = {http://www.sciencedirect.com/science/article/B758H-4C5HS0K-1/1/950b844502e73368538606462a7a6b62%20%20}}

@misc{Mehnert:STG-slides:2004,
	Author = {Hannes Mehnert},
	Date-Added = {2008-04-27 00:50:21 -0400},
	Date-Modified = {2008-04-27 00:50:25 -0400},
	Howpublished = {Lecture slides, available online},
	Title = {STG slides},
	Url = {http://uebb.cs.tu-berlin.de/lehre/2004WScompilerbau/ergebnisse/stg.pdf},
	Year = {2004},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEDQuLi8uLi9QYXBlcnMvTWVobmVydC9NZWhuZXJ0IC0gU1RHIHNsaWRlcyAoMjAwNCkucGRm0hsPHB1XTlMuZGF0YU8RAbQAAAAAAbQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADgnsx9NZWhuZXJ0IC0gU1RHIHNsaWRlcyAoMjAwNCkucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOCehxDlTEgAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAHTWVobmVydAAAEAAIAADBNH5dAAAAEQAIAADEOYtSAAAAAQAQADgnswAtkT8AA0esAABr2AACAEBPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6TWVobmVydDpNZWhuZXJ0IC0gU1RHIHNsaWRlcyAoMjAwNCkucGRmAA4AQAAfAE0AZQBoAG4AZQByAHQAIAAtACAAUwBUAEcAIABzAGwAaQBkAGUAcwAgACgAMgAwADAANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASADtVc2Vycy9qZXJlbXkvUGFwZXJzL01laG5lcnQvTWVobmVydCAtIFNURyBzbGlkZXMgKDIwMDQpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA4QDmAO4CpgKoAq0CtgLBAsUC0wLaAuMC6ALrAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAvg=},
	Bdsk-Url-1 = {http://uebb.cs.tu-berlin.de/lehre/2004WScompilerbau/ergebnisse/stg.pdf}}

@misc{Choi:STG-JVM:2001,
	Author = {Choi and Kaist},
	Date-Added = {2008-04-27 00:50:21 -0400},
	Date-Modified = {2008-04-28 01:07:53 -0400},
	Howpublished = {Slides from presentation at FLOPS 2001, available online},
	Title = {STG->JVM slides},
	Url = {www.jaist.ac.jp/~khchoi/doc/flops2001slide.pdf},
	Year = {2001},
	Annote = {Slides accompanying Choi:Compiling:2001.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEDkuLi8uLi9QYXBlcnMvQ2hvaS9DaG9pLUthaXN0IC0gU1RHLT5KVk0gc2xpZGVzICgyMDAxKS5wZGbSGw8cHVdOUy5kYXRhTxEBwgAAAAABwgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOCe0H0Nob2ktS2Fpc3QgLSBTVEctPkpWIzM4MjdBMi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4J6LEOVMSAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAARDaG9pABAACAAAwTR+XQAAABEACAAAxDmLUgAAAAEAEAA4J7QALZE/AANHrAAAa9gAAgA9T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkNob2k6Q2hvaS1LYWlzdCAtIFNURy0+SlYjMzgyN0EyLnBkZgAADgBQACcAQwBoAG8AaQAtAEsAYQBpAHMAdAAgAC0AIABTAFQARwAtAD4ASgBWAE0AIABzAGwAaQBkAGUAcwAgACgAMgAwADAAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAEBVc2Vycy9qZXJlbXkvUGFwZXJzL0Nob2kvQ2hvaS1LYWlzdCAtIFNURy0+SlZNIHNsaWRlcyAoMjAwMSkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAOYA6wDzArkCuwLAAskC1ALYAuYC7QL2AvsC/gAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAML},
	Bdsk-Url-1 = {www.jaist.ac.jp/~khchoi/doc/flops2001slide.pdf}}

@article{Mountjoy:The-Spineless:1999,
	Address = {New York, NY, USA},
	Author = {Jon Mountjoy},
	Date-Added = {2008-04-27 00:50:21 -0400},
	Date-Modified = {2008-04-30 21:12:14 -0400},
	Doi = {http://doi.acm.org/10.1145/291251.289439},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {1},
	Pages = {163--173},
	Publisher = {ACM},
	Title = {The {S}pineless {T}agless {G}-machine, naturally},
	Volume = {34},
	Year = {1999},
	Abstract = {The application of natural semantic specifications of lazy evaluation to areas such as usage analysis, formal profiling and abstract machine construction has shown it to be a useful formalism. This paper introduces several variants and extensions of this specification.The first variant is derived from observations of the Spineless Tagless G-machine (STG), used in the Glasgow Haskell compiler. We present a modified natural semantic specification which can be formally manipulated to derive an STG-like machine.The second variant is the development of a natural semantic specification which allows functions to be applied to more than one argument at once. The STG and TIM abstract machines both allow this kind of behaviour, and we illustrate a use of this semantics by again modifying this semantics following observations of the STG machine. The resulting semantics can be used to formally derive the STG machine. This effectively proves the STG machine correct with respect to Launchbury's semantics.En route, we also show that update markers in the STG machine are necessary for termination, and show how well-known abstract machine instructions, such as the squeeze operation, appear quite naturally as optimisations of the derived abstract machine.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFYuLi8uLi9QYXBlcnMvTW91bnRqb3kvTW91bnRqb3kgLSBUaGUgc3BpbmVsZXNzIHRhZ2xlc3MgRy1tYWNoaW5lLCBuYXR1cmFsbHkgKDE5OTkpLnBkZtIbDxwdV05TLmRhdGFPEQIaAAAAAAIaAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4J68fTW91bnRqb3kgLSBUaGUgc3BpbmUjMzgyN0EzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgno8Q5UxIAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAACE1vdW50am95ABAACAAAwTR+XQAAABEACAAAxDmLUgAAAAEAEAA4J68ALZE/AANHrAAAa9gAAgBBT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOk1vdW50am95Ok1vdW50am95IC0gVGhlIHNwaW5lIzM4MjdBMy5wZGYAAA4AggBAAE0AbwB1AG4AdABqAG8AeQAgAC0AIABUAGgAZQAgAHMAcABpAG4AZQBsAGUAcwBzACAAdABhAGcAbABlAHMAcwAgAEcALQBtAGEAYwBoAGkAbgBlACwAIABuAGEAdAB1AHIAYQBsAGwAeQAgACgAMQA5ADkAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF1Vc2Vycy9qZXJlbXkvUGFwZXJzL01vdW50am95L01vdW50am95IC0gVGhlIHNwaW5lbGVzcyB0YWdsZXNzIEctbWFjaGluZSwgbmF0dXJhbGx5ICgxOTk5KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQMBCAEQAy4DMAM1Az4DSQNNA1sDYgNrA3ADcwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOA},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/291251.289439}}

@techreport{Coquand:The-calculus:1986,
	Author = {Coquand, T. and Huet, G.},
	Date-Added = {2008-04-27 00:50:21 -0400},
	Date-Modified = {2008-04-27 00:53:35 -0400},
	Institution = {INRIA -- Rocquencourt},
	Keywords = {calculus of constructions},
	Month = {May},
	Number = {RR-0530},
	Title = {The calculus of constructions},
	Year = {1986},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEwuLi8uLi9QYXBlcnMvQ29xdWFuZC9Db3F1YW5kLUh1ZXQgLSBUaGUgY2FsY3VsdXMgb2YgY29uc3RydWN0aW9ucyAoMTk4NikucGRm0hsPHB1XTlMuZGF0YU8RAfwAAAAAAfwAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADgnsB9Db3F1YW5kLUh1ZXQgLSBUaGUgYyMzODI3QTQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOCekxDlTFAAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAHQ29xdWFuZAAAEAAIAADBNH5dAAAAEQAIAADEOYtUAAAAAQAQADgnsAAtkT8AA0esAABr2AACAEBPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6Q29xdWFuZDpDb3F1YW5kLUh1ZXQgLSBUaGUgYyMzODI3QTQucGRmAA4AcAA3AEMAbwBxAHUAYQBuAGQALQBIAHUAZQB0ACAALQAgAFQAaABlACAAYwBhAGwAYwB1AGwAdQBzACAAbwBmACAAYwBvAG4AcwB0AHIAdQBjAHQAaQBvAG4AcwAgACgAMQA5ADgANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFNVc2Vycy9qZXJlbXkvUGFwZXJzL0NvcXVhbmQvQ29xdWFuZC1IdWV0IC0gVGhlIGNhbGN1bHVzIG9mIGNvbnN0cnVjdGlvbnMgKDE5ODYpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA+QD+AQYDBgMIAw0DFgMhAyUDMwM6A0MDSANLAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA1g=}}

@inproceedings{Peyton-Jones:The-Spineless:1989,
	Address = {New York, NY, USA},
	Author = {Peyton Jones, Simon L. and Jon Salkild},
	Booktitle = {FPCA '89: Proceedings of the fourth international conference on Functional programming languages and computer architecture},
	Date-Added = {2008-04-27 00:45:26 -0400},
	Date-Modified = {2008-04-30 21:12:14 -0400},
	Doi = {http://doi.acm.org/10.1145/99370.99385},
	Isbn = {0-89791-328-0},
	Location = {Imperial College, London, United Kingdom},
	Note = {A much longer version is available from the website of Peyton Jones},
	Pages = {184--201},
	Publisher = {ACM},
	Title = {The {S}pineless {T}agless {G}-machine},
	Year = {1989},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFsuLi8uLi9QYXBlcnMvUGV5dG9uIEpvbmVzL1BleXRvbiBKb25lcy1TYWxraWxkIC0gVGhlIHNwaW5lbGVzcyB0YWdsZXNzIEctbWFjaGluZSAoMTk4OSkucGRm0hsPHB1XTlMuZGF0YU8RAigAAAAAAigAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2Reh9QZXl0b24gSm9uZXMtU2Fsa2lsZCMzODI3OUQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOCedxDlTDgAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAMUGV5dG9uIEpvbmVzABAACAAAwTR+XQAAABEACAAAxDmLTgAAAAEAEAAtkXoALZE/AANHrAAAa9gAAgBFT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlBleXRvbiBKb25lczpQZXl0b24gSm9uZXMtU2Fsa2lsZCMzODI3OUQucGRmAAAOAIQAQQBQAGUAeQB0AG8AbgAgAEoAbwBuAGUAcwAtAFMAYQBsAGsAaQBsAGQAIAAtACAAVABoAGUAIABzAHAAaQBuAGUAbABlAHMAcwAgAHQAYQBnAGwAZQBzAHMAIABHAC0AbQBhAGMAaABpAG4AZQAgACgAMQA5ADgAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGJVc2Vycy9qZXJlbXkvUGFwZXJzL1BleXRvbiBKb25lcy9QZXl0b24gSm9uZXMtU2Fsa2lsZCAtIFRoZSBzcGluZWxlc3MgdGFnbGVzcyBHLW1hY2hpbmUgKDE5ODkpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEIAQ0BFQNBA0MDSANRA1wDYANuA3UDfgODA4YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/99370.99385}}

@inproceedings{Peyton-Jones:Unboxed:1991,
	Address = {New York, NY, USA},
	Author = {Peyton Jones, Simon L. and John Launchbury},
	Booktitle = {Proceedings of the 5th ACM conference on Functional programming languages and computer architecture},
	Date-Added = {2008-04-27 00:45:26 -0400},
	Date-Modified = {2008-04-29 03:29:38 -0400},
	Isbn = {0-387-54396-1},
	Location = {Cambridge, Massachusetts, United States},
	Pages = {636--666},
	Publisher = {Springer-Verlag New York, Inc.},
	Title = {Unboxed values as first class citizens in a non-strict functional language},
	Year = {1991},
	Abstract = {The code compiled from a non-strict functional program usually manipulates heap-allocated \textit{boxed} numbers. Compilers for such languages often go to considerable trouble to optimise operations on boxed numbers into simpler operations on their unboxed forms. These optimisations are usually handled in an \textit{ad hoc} manner in the code generator, because earlier phases of the compiler have no way to talk about unboxed values.

We present a new approach, which makes unboxed values into (nearly) first-class citizens. The language, including its type system, is extended to handle unboxed values. The optimisation of boxing and unboxing operations can now be reinterpreted as a set of correctness-preserving program transformations. Indeed the particular transformations required are ones which a compiler would want to implement anyway. The compiler becomes both simpler and more modular.

Two other benefits accrue. Firstly, the results of strictness analysis can be exploited within the same uniform transformational framework. Secondly, new algebraic data types with unboxed components can be declared. Values of these types can be manipulated much more efficiently than the corresponding boxed versions.

Both a static and a dynamic semantics are given for the augmented language. The denotational dynamic semantics is notable for its use of \textit{unpointed domains.}},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGUuLi8uLi9QYXBlcnMvUGV5dG9uIEpvbmVzL1BleXRvbiBKb25lcy1MYXVuY2hidXJ5IC0gVW5ib3hlZCB2YWx1ZXMgYXMgZmlyc3QgY2xhc3MgY2l0aXplbnMgKDE5OTEpLnBkZtIbDxwdV05TLmRhdGFPEQJGAAAAAAJGAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtkXofUGV5dG9uIEpvbmVzLUxhdW5jaGIjMzgyNzlFLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgnnsQ5Uw4AAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAADFBleXRvbiBKb25lcwAQAAgAAME0fl0AAAARAAgAAMQ5i04AAAABABAALZF6AC2RPwADR6wAAGvYAAIARU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpQZXl0b24gSm9uZXM6UGV5dG9uIEpvbmVzLUxhdW5jaGIjMzgyNzlFLnBkZgAADgCYAEsAUABlAHkAdABvAG4AIABKAG8AbgBlAHMALQBMAGEAdQBuAGMAaABiAHUAcgB5ACAALQAgAFUAbgBiAG8AeABlAGQAIAB2AGEAbAB1AGUAcwAgAGEAcwAgAGYAaQByAHMAdAAgAGMAbABhAHMAcwAgAGMAaQB0AGkAegBlAG4AcwAgACgAMQA5ADkAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGxVc2Vycy9qZXJlbXkvUGFwZXJzL1BleXRvbiBKb25lcy9QZXl0b24gSm9uZXMtTGF1bmNoYnVyeSAtIFVuYm94ZWQgdmFsdWVzIGFzIGZpcnN0IGNsYXNzIGNpdGl6ZW5zICgxOTkxKS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBEgEXAR8DaQNrA3ADeQOEA4gDlgOdA6YDqwOuAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA7s=}}

@inproceedings{Reid:Putting:1999,
	Address = {London, UK},
	Author = {Alastair Reid},
	Booktitle = {IFL '98: Selected Papers from the 10th International Workshop on 10th International Workshop},
	Date-Added = {2008-04-27 00:45:26 -0400},
	Date-Modified = {2008-04-30 21:12:14 -0400},
	Isbn = {3-540-66229-4},
	Pages = {186--199},
	Publisher = {Springer-Verlag},
	Title = {Putting the Spine Back in the {S}pineless {T}agless {G}-Machine: An Implementation of Resumable Black-Holes},
	Year = {1999},
	Abstract = {Interrupt handling is a tricky business in lazy functional languages: we have to make sure that thunks that are being evaluated can be halted and later restarted if and when they are required. This is a particular problem for implementations which use black-holing. Black-Holing deliberately makes it impossible to revert such thunks to their original state to avoid a serious space leak. Interactive Haskell implementations such as Hugs and hbi catch interrupts and avoid the problem by omitting or disabling black-holing. Batch mode Haskell implementations such as HBC and the Glasgow Haskell Compiler (GHC) avoid this problem by disabling black-holing or by providing no way to catch interrupts. This paper describes a modification to GHC's abstract machine (the Spineless Tagless G-Machine) which simultaneously supports both interrupts and black-holing.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFMuLi8uLi9QYXBlcnMvUmVpZC9SZWlkIC0gUHV0dGluZyB0aGUgU3BpbmUgQmFjayBpbiB0aGUgU3BpbmVsZXNzIFRhZ2xlc3MgKDE5OTkpLnBkZtIbDxwdV05TLmRhdGFPEQIQAAAAAAIQAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4J64fUmVpZCAtIFB1dHRpbmcgdGhlIFMjMzgyNzlGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgnn8Q5UxAAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABFJlaWQAEAAIAADBNH5dAAAAEQAIAADEOYtQAAAAAQAQADgnrgAtkT8AA0esAABr2AACAD1PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6UmVpZDpSZWlkIC0gUHV0dGluZyB0aGUgUyMzODI3OUYucGRmAAAOAIQAQQBSAGUAaQBkACAALQAgAFAAdQB0AHQAaQBuAGcAIAB0AGgAZQAgAFMAcABpAG4AZQAgAEIAYQBjAGsAIABpAG4AIAB0AGgAZQAgAFMAcABpAG4AZQBsAGUAcwBzACAAVABhAGcAbABlAHMAcwAgACgAMQA5ADkAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFpVc2Vycy9qZXJlbXkvUGFwZXJzL1JlaWQvUmVpZCAtIFB1dHRpbmcgdGhlIFNwaW5lIEJhY2sgaW4gdGhlIFNwaW5lbGVzcyBUYWdsZXNzICgxOTk5KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBAAEFAQ0DIQMjAygDMQM8A0ADTgNVA14DYwNmAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA3M=}}

@misc{Hammond:The-Spineless:1993,
	Author = {K. Hammond},
	Date-Added = {2008-04-27 00:45:26 -0400},
	Date-Modified = {2008-04-30 21:12:14 -0400},
	Text = {Kevin Hammond. The spineless tagless G-Machine --- NOT!. Technical Report       (not yet published), Department of Computer Science, Glasgow University,     1993.},
	Title = {The {S}pineless {T}agless {G}-Machine --- NOT},
	Url = {citeseer.ist.psu.edu/hammond93spineless.html},
	Year = {1993},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFEuLi8uLi9QYXBlcnMvSGFtbW9uZC9IYW1tb25kIC0gVGhlIHNwaW5lbGVzcyB0YWdsZXNzIEctTWFjaGluZSAtLS0gTk9UICgxOTkzKS5wZGbSGw8cHVdOUy5kYXRhTxECCgAAAAACCgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOCerH0hhbW1vbmQgLSBUaGUgc3BpbmVsIzM4MjdBMC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4J6DEOVMQAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdIYW1tb25kAAAQAAgAAME0fl0AAAARAAgAAMQ5i1AAAAABABAAOCerAC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpIYW1tb25kOkhhbW1vbmQgLSBUaGUgc3BpbmVsIzM4MjdBMC5wZGYADgB6ADwASABhAG0AbQBvAG4AZAAgAC0AIABUAGgAZQAgAHMAcABpAG4AZQBsAGUAcwBzACAAdABhAGcAbABlAHMAcwAgAEcALQBNAGEAYwBoAGkAbgBlACAALQAtAC0AIABOAE8AVAAgACgAMQA5ADkAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFhVc2Vycy9qZXJlbXkvUGFwZXJzL0hhbW1vbmQvSGFtbW9uZCAtIFRoZSBzcGluZWxlc3MgdGFnbGVzcyBHLU1hY2hpbmUgLS0tIE5PVCAoMTk5MykucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAP4BAwELAxkDGwMgAykDNAM4A0YDTQNWA1sDXgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANr},
	Bdsk-Url-1 = {citeseer.ist.psu.edu/hammond93spineless.html}}

@inproceedings{Gill:A-short:1993,
	Address = {New York, NY, USA},
	Author = {Andrew Gill and John Launchbury and Simon L. Peyton Jones},
	Booktitle = {FPCA '93: Proceedings of the conference on Functional programming languages and computer architecture},
	Date-Added = {2008-04-27 00:40:53 -0400},
	Date-Modified = {2008-04-27 00:44:43 -0400},
	Doi = {http://doi.acm.org/10.1145/165180.165214},
	Isbn = {0-89791-595-X},
	Location = {Copenhagen, Denmark},
	Pages = {223--232},
	Publisher = {ACM},
	Title = {A short cut to deforestation},
	Year = {1993},
	Abstract = {Lists are often used as "glue" to connect separate parts of a program together. We propose an automatic technique for improving the efficiency of such programs, by removing many of these intermediate lists, based on a single, simple, local transformation. We have implemented the method in the Glasgow Haskell compiler.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFEuLi8uLi9QYXBlcnMvR2lsbC9HaWxsLUxhdW5jaGJ1cnktSm9uZXMgLSBBIHNob3J0IGN1dCB0byBkZWZvcmVzdGF0aW9uICgxOTkzKS5wZGbSGw8cHVdOUy5kYXRhTxECCgAAAAACCgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOCeUH0dpbGwtTGF1bmNoYnVyeS1Kb25lIzM4Mjc4Qi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4J4vEOVIIAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAARHaWxsABAACAAAwTR+XQAAABEACAAAxDmKSAAAAAEAEAA4J5QALZE/AANHrAAAa9gAAgA9T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkdpbGw6R2lsbC1MYXVuY2hidXJ5LUpvbmUjMzgyNzhCLnBkZgAADgCAAD8ARwBpAGwAbAAtAEwAYQB1AG4AYwBoAGIAdQByAHkALQBKAG8AbgBlAHMAIAAtACAAQQAgAHMAaABvAHIAdAAgAGMAdQB0ACAAdABvACAAZABlAGYAbwByAGUAcwB0AGEAdABpAG8AbgAgACgAMQA5ADkAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFhVc2Vycy9qZXJlbXkvUGFwZXJzL0dpbGwvR2lsbC1MYXVuY2hidXJ5LUpvbmVzIC0gQSBzaG9ydCBjdXQgdG8gZGVmb3Jlc3RhdGlvbiAoMTk5MykucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAP4BAwELAxkDGwMgAykDNAM4A0YDTQNWA1sDXgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANr},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/165180.165214}}

@article{Chitil:Type:1999,
	Address = {New York, NY, USA},
	Author = {Olaf Chitil},
	Date-Added = {2008-04-27 00:40:53 -0400},
	Date-Modified = {2008-04-27 00:44:43 -0400},
	Doi = {http://doi.acm.org/10.1145/317765.317907},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {9},
	Pages = {249--260},
	Publisher = {ACM},
	Title = {Type inference builds a short cut to deforestation},
	Volume = {34},
	Year = {1999},
	Abstract = {Deforestation optimises a functional program by transforming it into another one that does not create certain intermediate data structures. Short cut deforestation is a deforestation method which is based on a single, local transformation rule. In return, short cut deforestation expects both producer and consumer of the intermediate structure in a certain form. Warm fusion was proposed to automatically transform functions into this form. Unfortunately, it is costly and hard to implement. Starting from the fact that short cut deforestation is based on a parametricity theorem of the second-order typed $\lambda$-calculus, we show how the required form of a list producer can be derived by the use of type inference. Typability for the second-order typed $\lambda$-calculus is undecidable. However, we present a linear-time algorithm that solves a partial type inference problem and that, together with controlled inlining and polymorphic type instantiation, suffices for deforestation. The resulting new short cut deforestation algorithm is efficient and removes more intermediate lists than the original.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFouLi8uLi9QYXBlcnMvQ2hpdGlsL0NoaXRpbCAtIFR5cGUgaW5mZXJlbmNlIGJ1aWxkcyBhIHNob3J0IGN1dCB0byBkZWZvcmVzdGF0aW9uICgxOTk5KS5wZGbSGw8cHVdOUy5kYXRhTxECJgAAAAACJgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOCeSH0NoaXRpbCAtIFR5cGUgaW5mZXJlIzM4Mjc4Qy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4J4zEOVIIAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZDaGl0aWwAEAAIAADBNH5dAAAAEQAIAADEOYpIAAAAAQAQADgnkgAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6Q2hpdGlsOkNoaXRpbCAtIFR5cGUgaW5mZXJlIzM4Mjc4Qy5wZGYAAA4AjgBGAEMAaABpAHQAaQBsACAALQAgAFQAeQBwAGUAIABpAG4AZgBlAHIAZQBuAGMAZQAgAGIAdQBpAGwAZABzACAAYQAgAHMAaABvAHIAdAAgAGMAdQB0ACAAdABvACAAZABlAGYAbwByAGUAcwB0AGEAdABpAG8AbgAgACgAMQA5ADkAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGFVc2Vycy9qZXJlbXkvUGFwZXJzL0NoaXRpbC9DaGl0aWwgLSBUeXBlIGluZmVyZW5jZSBidWlsZHMgYSBzaG9ydCBjdXQgdG8gZGVmb3Jlc3RhdGlvbiAoMTk5OSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEHAQwBFAM+A0ADRQNOA1kDXQNrA3IDewOAA4MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/317765.317907}}

@inproceedings{Mu:Algebra:2008,
	Author = {Shin-Cheng Mu and Hsiang-Shang Ko and Patrik Jansson},
	Booktitle = {Mathematics of Program Construction 2008},
	Date-Added = {2008-04-27 00:40:53 -0400},
	Date-Modified = {2008-04-27 00:44:43 -0400},
	Homepage = {http://www.iis.sinica.edu.tw/~scm/},
	Location = {CIRM, Marseille (Luminy), France},
	Month = {July},
	Title = {Algebra of programming using dependent types},
	Url = {http://www.iis.sinica.edu.tw/~scm/pub/mpc08.pdf},
	Year = {2008},
	Abstract = {Dependent type theory is rich enough to express that a program satisfies an input/output relational specification, but it could be hard to construct the proof term. On the other hand, squiggolists know very well how to show that one relation is included in another by algebraic reasoning. We demonstrate how to encode functional and relational derivations in a dependently typed programming language. A program is coupled with an algebraic derivation from a specification, whose correctness is guaranteed by the type system.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFcuLi8uLi9QYXBlcnMvTXUvTXUtS28tSmFuc3NvbiAtIEFsZ2VicmEgb2YgcHJvZ3JhbW1pbmcgdXNpbmcgZGVwZW5kZW50IHR5cGVzICgyMDA4KS5wZGbSGw8cHVdOUy5kYXRhTxECHAAAAAACHAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOCeVH011LUtvLUphbnNzb24gLSBBbGdlIzM4Mjc4RC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4J43EOVIKAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAJNdQAQAAgAAME0fl0AAAARAAgAAMQ5ikoAAAABABAAOCeVAC2RPwADR6wAAGvYAAIAO09kaW46VXNlcnM6amVyZW15OlBhcGVyczpNdTpNdS1Lby1KYW5zc29uIC0gQWxnZSMzODI3OEQucGRmAAAOAJAARwBNAHUALQBLAG8ALQBKAGEAbgBzAHMAbwBuACAALQAgAEEAbABnAGUAYgByAGEAIABvAGYAIABwAHIAbwBnAHIAYQBtAG0AaQBuAGcAIAB1AHMAaQBuAGcAIABkAGUAcABlAG4AZABlAG4AdAAgAHQAeQBwAGUAcwAgACgAMgAwADAAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF5Vc2Vycy9qZXJlbXkvUGFwZXJzL011L011LUtvLUphbnNzb24gLSBBbGdlYnJhIG9mIHByb2dyYW1taW5nIHVzaW5nIGRlcGVuZGVudCB0eXBlcyAoMjAwOCkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQQBCQERAzEDMwM4A0EDTANQA14DZQNuA3MDdgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOD},
	Bdsk-Url-1 = {http://www.iis.sinica.edu.tw/~scm/pub/mpc08.pdf}}

@misc{Elliott:Simply:2008,
	Author = {Conal Elliott},
	Date-Added = {2008-04-27 00:40:53 -0400},
	Date-Modified = {2008-04-27 00:44:43 -0400},
	Homepage = {http://conal.net/papers/simply-reactive/},
	Howpublished = {Manuscript submitted to ICFP 2008, published online},
	Month = {April},
	Note = {Errata available from \url{http://conal.net/papers/simply-reactive/}},
	Title = {Simply efficient functional reactivity},
	Year = 2008,
	Abstract = {Functional reactive programming (FRP) has simple and powerful semantics, but has resisted efficient implementation. In particular, most past implementations have used demand-driven sampling, which accommodates FRP's continuous time semantics and fits well with the nature of functional programming. Consequently, values are wastefully recomputed even when inputs don't change, and reaction latency can be as high as the sampling period.

This paper presents a way to implement FRP that combines data- and demand-driven evaluation, in which values are recomputed only when necessary, and reactions are nearly instantaneous. The implementation is rooted in a new simple formulation of FRP and its semantics and so is easy to understand and reason about.

On the road to efficiency and simplicity, we'll meet some old friends (monoids, functors, applicative functors, monads, morphisms, and improving values) and make some new friends (functional future values, reactive normal form, and concurrent "unambiguous choice").},
	Annote = {Errata to date (17 Apr 2008)

    * Page 3, section 2.2.1: in the semantic Monoid instance definition for Event, drop the "O" constructor.
    * Page 4, top left (section 2.3): In the definition of before, the parameters are swapped.
    * Page 5, section 4.5, second bullet: "oo" -> "-oo" (oo = $\infty$)
    * Page 5, section 4.5: "FTime t" -> "FTime"
    * Page 6, section 5.2: "Applicative Behavior" should be "Applicative Reactive"
    * Page 7, section 6, second-to-last sentence: "will have to block the" -> "will have to block until the"
    * Page 8, section 7.1.2, last sentence: "do some work based partial applications" -> "do some work based upon partial applications"
    * Page 8, section 7.2.2: "instance Monad Reactive" -> "instance Monad Event"
    * Page 8, bottom right (section 7.2.2), in the definition of adjustTop, the constructors should be named "Ev" resp. "Fut", not "Event" resp. "Future".
    * Page 9, section 8: "image to display window" -> "image to a display window"
    * Page 12, conclusion, last paragraph, "paper allows retains" -> "paper retains"

Thanks to Cale Gibbard, Max Bolingbroke, Kenn Knowles, and an anonymous reader for pointing out these mistakes.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFAuLi8uLi9QYXBlcnMvRWxsaW90dC9FbGxpb3R0IC0gU2ltcGx5IGVmZmljaWVudCBmdW5jdGlvbmFsIHJlYWN0aXZpdHkgKDIwMDgpLnBkZtIbDxwdV05TLmRhdGFPEQIIAAAAAAIIAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4J5MfRWxsaW90dCAtIFNpbXBseSBlZmYjMzgyNzhFLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgnjsQ5UgoAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAB0VsbGlvdHQAABAACAAAwTR+XQAAABEACAAAxDmKSgAAAAEAEAA4J5MALZE/AANHrAAAa9gAAgBAT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkVsbGlvdHQ6RWxsaW90dCAtIFNpbXBseSBlZmYjMzgyNzhFLnBkZgAOAHgAOwBFAGwAbABpAG8AdAB0ACAALQAgAFMAaQBtAHAAbAB5ACAAZQBmAGYAaQBjAGkAZQBuAHQAIABmAHUAbgBjAHQAaQBvAG4AYQBsACAAcgBlAGEAYwB0AGkAdgBpAHQAeQAgACgAMgAwADAAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFdVc2Vycy9qZXJlbXkvUGFwZXJzL0VsbGlvdHQvRWxsaW90dCAtIFNpbXBseSBlZmZpY2llbnQgZnVuY3Rpb25hbCByZWFjdGl2aXR5ICgyMDA4KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAP0BAgEKAxYDGAMdAyYDMQM1A0MDSgNTA1gDWwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANo}}

@unpublished{Meijer:Down:1993,
	Author = {Erik Meijer and Ross Paterson},
	Date-Added = {2008-04-26 19:36:44 -0400},
	Date-Modified = {2008-04-30 21:12:14 -0400},
	Keywords = {abstract machines},
	Note = {Unfinished draft, published online},
	Title = {Down with $\lambda$-lifting},
	Url = {http://research.microsoft.com/~emeijer/Papers/down.pdf},
	Year = {c.~1993},
	Abstract = {Simplifications of the Spineless Tagless G-Machine and TIM are presented, which like the classic SECD machine or the Krivine machine reduce $\lambda$-expressions to weak head normal form -- no prior $\lambda$-lifting is necessary. The machines are at least as efficient as their combinator forebears but more importantly they are simpler due to the elimination of a translation step that obfuscates programs without improving their efficiency.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEkuLi8uLi9QYXBlcnMvTWVpamVyL01laWplci1QYXRlcnNvbiAtIERvd24gV2l0aCBMYW1iZGEtTGlmdGluZyAoMTk5MykucGRm0hsPHB1XTlMuZGF0YU8RAfIAAAAAAfIAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADaBIB9NZWlqZXItUGF0ZXJzb24gLSBEbyMzODI1RTgucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOCXoxDk1BFBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGTWVpamVyABAACAAAwTR+XQAAABEACAAAxDltRAAAAAEAEAA2gSAALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOk1laWplcjpNZWlqZXItUGF0ZXJzb24gLSBEbyMzODI1RTgucGRmAAAOAGwANQBNAGUAaQBqAGUAcgAtAFAAYQB0AGUAcgBzAG8AbgAgAC0AIABEAG8AdwBuACAAVwBpAHQAaAAgAEwAYQBtAGIAZABhAC0ATABpAGYAdABpAG4AZwAgACgAMQA5ADkAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFBVc2Vycy9qZXJlbXkvUGFwZXJzL01laWplci9NZWlqZXItUGF0ZXJzb24gLSBEb3duIFdpdGggTGFtYmRhLUxpZnRpbmcgKDE5OTMpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD2APsBAwL5AvsDAAMJAxQDGAMmAy0DNgM7Az4AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADSw==},
	Bdsk-Url-1 = {http://research.microsoft.com/~emeijer/Papers/down.pdf}}

@book{Peyton-Jones:Haskell:2003,
	Date-Added = {2008-04-25 22:38:57 -0400},
	Date-Modified = {2008-04-25 22:43:18 -0400},
	Doi = {http://dx.doi.org/10.2277/0521826144},
	Editor = {Peyton Jones, Simon},
	Isbn = {9780521826143},
	Month = {April},
	Note = {Also available online from \url{http://haskell.org/}},
	Publisher = {Cambridge University Press},
	Title = {Haskell 98 Language and Libraries: The Revised Report},
	Year = {2003},
	Abstract = {Haskell is the world's leading lazy functional programming language, widely used for teaching, research, and applications. The language continues to develop rapidly, but in 1998 the community decided to capture a stable snapshot of the language: Haskell 98. All Haskell compilers support Haskell 98, so practitioners and educators alike have a stable base for their work. This book constitutes the agreed definition of the Haskell 98, both the language itself and its supporting libraries. It has been considerably revised and refined since the original definition, and appears in print for the first time. It should be a standard reference work for anyone involved in research, teaching, or application of Haskell.},
	Bdsk-Url-1 = {http://dx.doi.org/10.2277/0521826144}}

@article{Washburn:Boxes:2008,
	Author = {Washburn, Geoffrey and Weirich, Stephanie},
	Date-Added = {2008-04-25 22:35:50 -0400},
	Date-Modified = {2008-04-25 22:37:32 -0400},
	Doi = {10.1017/S0956796807006557},
	Journal = {J. Funct. Program.},
	Month = {Jan},
	Pages = {87--140},
	Title = {Boxes go bananas: Encoding higher-order abstract syntax with parametric polymorphism},
	Volume = {18},
	Year = {2008},
	Abstract = {Higher-order abstract syntax is a simple technique for implementing languages with functional programming. Object variables and binders are implemented by variables and binders in the host language. By using this technique, one can avoid implementing common and tricky routines dealing with variables, such as capture-avoiding substitution. However, despite the advantages this technique provides, it is not commonly used because it is difficult to write sound elimination forms (such as folds or catamorphisms) for higher-order abstract syntax. To fold over such a data type, one must either simultaneously define an inverse operation (which may not exist) or show that all functions embedded in the data type are parametric. In this paper, we show how first-class polymorphism can be used to guarantee the parametricity of functions embedded in higher-order abstract syntax. With this restriction, we implement a library of iteration operators over data structures containing functionals. From this implementation, we derive ``fusion laws'' that functional programmers may use to reason about the iteration operator. Finally, we show how this use of parametric polymorphism corresponds to the Sch{\"u}rmann, Despeyroux and Pfenning method of enforcing parametricity through modal types. We do so by using this library to give a sound and complete encoding of their calculus into System $\mathbb{F}_{\omega}$. This encoding can serve as a starting point for reasoning about higher-order structures in polymorphic languages.

* This is an extended version of the paper that appeared in The 8th ACM SIGPLAN International Conference on Functional Programming (Washburn & Weirich, 2003).},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGQuLi8uLi9QYXBlcnMvV2FzaGJ1cm4vV2FzaGJ1cm4tV2VpcmljaCAtIEJveGVzIGdvIGJhbmFuYXM6IEVuY29kaW5nIGhpZ2hlci1vcmRlciBhYnN0cmFjdCAoMjAwOCkucGRm0hsPHB1XTlMuZGF0YU8RAkQAAAAAAkQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADgekh9XYXNoYnVybi1XZWlyaWNoIC0gQiMzODFFODcucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOB6HxDgNHlBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIV2FzaGJ1cm4AEAAIAADBNH5dAAAAEQAIAADEOEVeAAAAAQAQADgekgAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6V2FzaGJ1cm46V2FzaGJ1cm4tV2VpcmljaCAtIEIjMzgxRTg3LnBkZgAADgCeAE4AVwBhAHMAaABiAHUAcgBuAC0AVwBlAGkAcgBpAGMAaAAgAC0AIABCAG8AeABlAHMAIABnAG8AIABiAGEAbgBhAG4AYQBzAC8AIABFAG4AYwBvAGQAaQBuAGcAIABoAGkAZwBoAGUAcgAtAG8AcgBkAGUAcgAgAGEAYgBzAHQAcgBhAGMAdAAgACgAMgAwADAAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGtVc2Vycy9qZXJlbXkvUGFwZXJzL1dhc2hidXJuL1dhc2hidXJuLVdlaXJpY2ggLSBCb3hlcyBnbyBiYW5hbmFzOiBFbmNvZGluZyBoaWdoZXItb3JkZXIgYWJzdHJhY3QgKDIwMDgpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBEQEWAR4DZgNoA20DdgOBA4UDkwOaA6MDqAOrAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA7g=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1017/S0956796807006557}}

@inproceedings{Turner:Miranda:1985,
	Address = {New York, NY, USA},
	Author = {D. A. Turner},
	Booktitle = {Proc. of a conference on Functional programming languages and computer architecture},
	Date-Added = {2008-04-25 20:17:10 -0400},
	Date-Modified = {2008-04-25 20:20:58 -0400},
	Isbn = {3-387-15975-4},
	Location = {Nancy, France},
	Pages = {1--16},
	Publisher = {Springer-Verlag New York, Inc.},
	Title = {Miranda: a non-strict functional language with polymorphic types},
	Year = {1985},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFYuLi8uLi9QYXBlcnMvVHVybmVyL1R1cm5lciAtIE1pcmFuZGE6IGEgbm9uLXN0cmljdCBmdW5jdGlvbmFsIGxhbmd1YWdlIHdpdGggKDE5ODUpLnBkZtIbDxwdV05TLmRhdGFPEQIaAAAAAAIaAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA2gVQfVHVybmVyIC0gTWlyYW5kYS8gYSAjMzgxRDU2LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgdVsQ37YwAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABlR1cm5lcgAQAAgAAME0fl0AAAARAAgAAMQ4JcwAAAABABAANoFUAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpUdXJuZXI6VHVybmVyIC0gTWlyYW5kYS8gYSAjMzgxRDU2LnBkZgAADgCGAEIAVAB1AHIAbgBlAHIAIAAtACAATQBpAHIAYQBuAGQAYQAvACAAYQAgAG4AbwBuAC0AcwB0AHIAaQBjAHQAIABmAHUAbgBjAHQAaQBvAG4AYQBsACAAbABhAG4AZwB1AGEAZwBlACAAdwBpAHQAaAAgACgAMQA5ADgANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF1Vc2Vycy9qZXJlbXkvUGFwZXJzL1R1cm5lci9UdXJuZXIgLSBNaXJhbmRhOiBhIG5vbi1zdHJpY3QgZnVuY3Rpb25hbCBsYW5ndWFnZSB3aXRoICgxOTg1KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQMBCAEQAy4DMAM1Az4DSQNNA1sDYgNrA3ADcwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOA}}

@inproceedings{Turner:The-semantic:1981,
	Address = {New York, NY, USA},
	Author = {D. A. Turner},
	Booktitle = {FPCA '81: Proceedings of the 1981 conference on Functional programming languages and computer architecture},
	Date-Added = {2008-04-25 20:12:50 -0400},
	Date-Modified = {2008-04-25 22:19:22 -0400},
	Doi = {http://doi.acm.org/10.1145/800223.806766},
	Isbn = {0-89791-060-5},
	Location = {Portsmouth, New Hampshire, United States},
	Pages = {85--92},
	Publisher = {ACM},
	Title = {The semantic elegance of applicative languages},
	Year = {1981},
	Abstract = { In what does the alleged superiority of applicative languages consist? In the last analysis the answer must be in terms of the reduction in the time required to produce a correct program to solve a given problem. On reflection I decided that the best way to demonstrate this would be to take some reasonably non-trivial problem and show how, by proceeding within a certain kind of applicative language framework it was possible to develop a working solution with a fraction of the effort that would have been necessary in a conventional imperative language. The particular problem I have chosen also brings out a number of general points of interest which I shall discuss briefly afterwards.

Before proceeding it will be necessary for me to quickly outline the language framework within which we shall be working. Very briefly it can be summarised as (non-strict, higher order) recursion equations + set abstraction. Obviously what matters are the underlying semantic concepts, not the particular syntax that is used to express them, but for the sake of definiteness I shall use the notation of KRC (= ``Kent Recursive Calculator''), an applicative programming system implemented at the University of Kent [Turner 81]. KRC is fairly closely based on the earlier language SASL, [Turner 763, but I have added a facility for set abstraction.  },
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFYuLi8uLi9QYXBlcnMvVHVybmVyL1R1cm5lciAtIFRoZSBzZW1hbnRpYyBlbGVnYW5jZSBvZiBhcHBsaWNhdGl2ZSBsYW5ndWFnZXMgKDE5ODEpLnBkZtIbDxwdV05TLmRhdGFPEQIaAAAAAAIaAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA2gVQfVHVybmVyIC0gVGhlIHNlbWFudGkjMzgxRDJFLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgdLsQ37DRQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABlR1cm5lcgAQAAgAAME0fl0AAAARAAgAAMQ4JHQAAAABABAANoFUAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpUdXJuZXI6VHVybmVyIC0gVGhlIHNlbWFudGkjMzgxRDJFLnBkZgAADgCGAEIAVAB1AHIAbgBlAHIAIAAtACAAVABoAGUAIABzAGUAbQBhAG4AdABpAGMAIABlAGwAZQBnAGEAbgBjAGUAIABvAGYAIABhAHAAcABsAGkAYwBhAHQAaQB2AGUAIABsAGEAbgBnAHUAYQBnAGUAcwAgACgAMQA5ADgAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF1Vc2Vycy9qZXJlbXkvUGFwZXJzL1R1cm5lci9UdXJuZXIgLSBUaGUgc2VtYW50aWMgZWxlZ2FuY2Ugb2YgYXBwbGljYXRpdmUgbGFuZ3VhZ2VzICgxOTgxKS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQMBCAEQAy4DMAM1Az4DSQNNA1sDYgNrA3ADcwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOA},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/800223.806766}}

@techreport{Turner:SASL:1976,
	Author = {Turner, David A.},
	Date-Added = {2008-04-25 18:27:32 -0400},
	Date-Modified = {2008-04-25 18:30:11 -0400},
	Institution = {University of St. Andrews},
	Note = {Available from the author's website \url{http://www.cs.mdx.ac.uk/staffpages/dat/}},
	Title = {SASL Language Manual},
	Year = {1976 (revised 1983)},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEDwuLi8uLi9QYXBlcnMvVHVybmVyL1R1cm5lciAtIFNBU0wgTGFuZ3VhZ2UgTWFudWFsICgxOTc2KS5wZGbSGw8cHVdOUy5kYXRhTxEBzAAAAAABzAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAANoFUH1R1cm5lciAtIFNBU0wgTGFuZ3VhIzM4MUM1Ny5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4HFfEN9MCAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZUdXJuZXIAEAAIAADBNH5dAAAAEQAIAADEOAtCAAAAAQAQADaBVAAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6VHVybmVyOlR1cm5lciAtIFNBU0wgTGFuZ3VhIzM4MUM1Ny5wZGYAAA4AUgAoAFQAdQByAG4AZQByACAALQAgAFMAQQBTAEwAIABMAGEAbgBnAHUAYQBnAGUAIABNAGEAbgB1AGEAbAAgACgAMQA5ADcANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAENVc2Vycy9qZXJlbXkvUGFwZXJzL1R1cm5lci9UdXJuZXIgLSBTQVNMIExhbmd1YWdlIE1hbnVhbCAoMTk3NikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgDpAO4A9gLGAsgCzQLWAuEC5QLzAvoDAwMIAwsAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADGA==}}

@article{Richards:An-overview:1984,
	Address = {New York, NY, USA},
	Author = {H. Richards},
	Date-Added = {2008-04-25 18:15:30 -0400},
	Date-Modified = {2008-04-25 22:12:37 -0400},
	Doi = {http://doi.acm.org/10.1145/948290.948294},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {10},
	Pages = {40--45},
	Publisher = {ACM},
	Title = {An overview of {ARC} {SASL}},
	Volume = {19},
	Year = {1984},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEMuLi8uLi9QYXBlcnMvUmljaGFyZHMvUmljaGFyZHMgLSBBbiBvdmVydmlldyBvZiBBUkMgU0FTTCAoMTk4NCkucGRm0hsPHB1XTlMuZGF0YU8RAeAAAAAAAeAAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADgcPx9SaWNoYXJkcyAtIEFuIG92ZXJ2aSMzODFDM0UucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOBw+xDfQXFBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIUmljaGFyZHMAEAAIAADBNH5dAAAAEQAIAADEOAicAAAAAQAQADgcPwAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6UmljaGFyZHM6UmljaGFyZHMgLSBBbiBvdmVydmkjMzgxQzNFLnBkZgAADgBcAC0AUgBpAGMAaABhAHIAZABzACAALQAgAEEAbgAgAG8AdgBlAHIAdgBpAGUAdwAgAG8AZgAgAEEAUgBDACAAUwBBAFMATAAgACgAMQA5ADgANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAEpVc2Vycy9qZXJlbXkvUGFwZXJzL1JpY2hhcmRzL1JpY2hhcmRzIC0gQW4gb3ZlcnZpZXcgb2YgQVJDIFNBU0wgKDE5ODQpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgDwAPUA/QLhAuMC6ALxAvwDAAMOAxUDHgMjAyYAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADMw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/948290.948294}}

@inproceedings{Pottier:Towards:2006,
	Author = {Fran{\c c}ois Pottier and Yann {R{\'e}gis-Gianas}},
	Booktitle = {ACM Workshop on ML},
	Date-Added = {2008-04-25 03:53:59 -0400},
	Date-Modified = {2008-04-25 03:57:02 -0400},
	Month = MAR,
	Number = {2},
	Off = {http://dx.doi.org/10.1016/j.entcs.2005.11.044},
	Pages = {155--180},
	Pdf = {http://cristal.inria.fr/~fpottier/publis/fpottier-regis-gianas-typed-lr.pdf},
	Series = {Electronic Notes in Theoretical Computer Science},
	Title = {Towards efficient, typed {LR} parsers},
	Url = {http://cristal.inria.fr/~fpottier/publis/fpottier-regis-gianas-typed-lr.ps.gz},
	Volume = {148},
	Year = {2006},
	Abstract = {The LR parser generators that are bundled with many functional programming language implementations produce code that is untyped, needlessly inefficient, or both. We show that, using generalized algebraic data types, it is possible to produce parsers that are well-typed (so they cannot unexpectedly crash or fail) and nevertheless efficient. This is a pleasing result as well as an illustration of the new expressiveness offered by generalized algebraic data types.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFvEFsALgAuAC8ALgAuAC8AUABhAHAAZQByAHMALwBQAG8AdAB0AGkAZQByAC8AUABvAHQAdABpAGUAcgAtAFIAZQMBAGcAaQBzAC0ARwBpAGEAbgBhAHMAIAAtACAAVABvAHcAYQByAGQAcwAgAGUAZgBmAGkAYwBpAGUAbgB0ACwAIAB0AHkAcABlAGQAIABMAFIAIABwAGEAcgBzAGUAcgBzACAAKAAyADAAMAA2ACkALgBwAGQAZtIbDxwdV05TLmRhdGFPEQIqAAAAAAIqAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4GEcfUG90dGllci1Sjmdpcy1HaWFuYXMjMzgxODY4LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgYaMQ3BypQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAB1BvdHRpZXIAABAACAAAwTR+XQAAABEACAAAxDc/agAAAAEAEAA4GEcALZE/AANHrAAAa9gAAgBAT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlBvdHRpZXI6UG90dGllci1Sjmdpcy1HaWFuYXMjMzgxODY4LnBkZgAOAI4ARgBQAG8AdAB0AGkAZQByAC0AUgBlAwEAZwBpAHMALQBHAGkAYQBuAGEAcwAgAC0AIABUAG8AdwBhAHIAZABzACAAZQBmAGYAaQBjAGkAZQBuAHQALAAgAHQAeQBwAGUAZAAgAEwAUgAgAHAAYQByAHMAZQByAHMAIAAoADIAMAAwADYAKQAuAHAAZABmAA8ACgAEAE8AZABpAG4AEgBjVXNlcnMvamVyZW15L1BhcGVycy9Qb3R0aWVyL1BvdHRpZXItUmXMgWdpcy1HaWFuYXMgLSBUb3dhcmRzIGVmZmljaWVudCwgdHlwZWQgTFIgcGFyc2VycyAoMjAwNikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgFjAWgBcAOeA6ADpQOuA7kDvQPLA9ID2wPgA+MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAD8A==},
	Bdsk-Url-1 = {http://cristal.inria.fr/~fpottier/publis/fpottier-regis-gianas-typed-lr.ps.gz}}

@unpublished{Pottier:A-modern:2005,
	Author = {Fran{\c c}ois Pottier},
	Date-Added = {2008-04-25 03:52:20 -0400},
	Date-Modified = {2008-04-25 03:52:21 -0400},
	Month = SEP,
	Note = {Lecture notes for the {APPSEM} Summer School},
	Pdf = {http://cristal.inria.fr/~fpottier/publis/fpottier-appsem-2005.pdf},
	Title = {A modern eye on {ML} type inference: old techniques                  and recent developments},
	Url = {http://cristal.inria.fr/~fpottier/publis/fpottier-appsem-2005.ps.gz},
	Year = {2005},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGYuLi8uLi9QYXBlcnMvUG90dGllci9Qb3R0aWVyIC0gQSBtb2Rlcm4gZXllIG9uIE1MIHR5cGUgaW5mZXJlbmNlOiBvbGQgdGVjaG5pcXVlcyBhbmQgcmVjZW50ICgyMDA1KS5wZGbSGw8cHVdOUy5kYXRhTxECSgAAAAACSgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOBhHH1BvdHRpZXIgLSBBIG1vZGVybiBlIzM4MTU1RS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4FV7ENuBVUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdQb3R0aWVyAAAQAAgAAME0fl0AAAARAAgAAMQ3GJUAAAABABAAOBhHAC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpQb3R0aWVyOlBvdHRpZXIgLSBBIG1vZGVybiBlIzM4MTU1RS5wZGYADgCkAFEAUABvAHQAdABpAGUAcgAgAC0AIABBACAAbQBvAGQAZQByAG4AIABlAHkAZQAgAG8AbgAgAE0ATAAgAHQAeQBwAGUAIABpAG4AZgBlAHIAZQBuAGMAZQAvACAAbwBsAGQAIAB0AGUAYwBoAG4AaQBxAHUAZQBzACAAYQBuAGQAIAByAGUAYwBlAG4AdAAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG1Vc2Vycy9qZXJlbXkvUGFwZXJzL1BvdHRpZXIvUG90dGllciAtIEEgbW9kZXJuIGV5ZSBvbiBNTCB0eXBlIGluZmVyZW5jZTogb2xkIHRlY2huaXF1ZXMgYW5kIHJlY2VudCAoMjAwNSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgETARgBIANuA3ADdQN+A4kDjQObA6IDqwOwA7MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADwA==},
	Bdsk-Url-1 = {http://cristal.inria.fr/~fpottier/publis/fpottier-appsem-2005.ps.gz}}

@inproceedings{MacQueen:Structure:1981,
	Address = {Gothenburg, Sweden},
	Author = {MacQueen, David B.},
	Booktitle = {Symp. on Functional Languages and Computer Architecture},
	Date-Added = {2008-04-25 03:07:43 -0400},
	Date-Modified = {2008-04-25 03:39:47 -0400},
	Month = {June},
	Pages = {525--537},
	Title = {Structure and Parameterization in a Typed Functional Language},
	Year = {1981}}

@article{Milner:A-Theory:1978,
	Author = {Robin Milner},
	Checked = {Not checked},
	Date-Added = {2008-04-25 03:01:17 -0400},
	Date-Modified = {2008-04-25 03:01:17 -0400},
	Journal = {Journal of Computer and System Sciences},
	Key = {Milner78},
	Month = AUG,
	Pages = {348--375},
	Source = {ergobib},
	Title = {A Theory of Type Polymorphism in Programming},
	Volume = {17},
	Year = {1978},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFQuLi8uLi9QYXBlcnMvTWlsbmVyL01pbG5lciAtIEEgVGhlb3J5IG9mIFR5cGUgUG9seW1vcnBoaXNtIGluIFByb2dyYW1taW5nICgxOTc4KS5wZGbSGw8cHVdOUy5kYXRhTxECFAAAAAACFAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOE4RH01pbG5lciAtIEEgVGhlb3J5IG9mIzM4NEUwNS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4TgXEO7BKUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZNaWxuZXIAEAAIAADBNH5dAAAAEQAIAADEO+iKAAAAAQAQADhOEQAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6TWlsbmVyOk1pbG5lciAtIEEgVGhlb3J5IG9mIzM4NEUwNS5wZGYAAA4AggBAAE0AaQBsAG4AZQByACAALQAgAEEAIABUAGgAZQBvAHIAeQAgAG8AZgAgAFQAeQBwAGUAIABQAG8AbAB5AG0AbwByAHAAaABpAHMAbQAgAGkAbgAgAFAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMQA5ADcAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFtVc2Vycy9qZXJlbXkvUGFwZXJzL01pbG5lci9NaWxuZXIgLSBBIFRoZW9yeSBvZiBUeXBlIFBvbHltb3JwaGlzbSBpbiBQcm9ncmFtbWluZyAoMTk3OCkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEBAQYBDgMmAygDLQM2A0EDRQNTA1oDYwNoA2sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADeA==}}

@inproceedings{Duba:Typing:1991,
	Address = {New York, NY, USA},
	Author = {Bruce Duba and Robert Harper and David MacQueen},
	Booktitle = {POPL '91: Proceedings of the 18th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
	Date-Added = {2008-04-25 02:14:20 -0400},
	Date-Modified = {2008-04-25 02:14:21 -0400},
	Doi = {http://doi.acm.org/10.1145/99583.99608},
	Isbn = {0-89791-419-8},
	Location = {Orlando, Florida, United States},
	Pages = {163--173},
	Publisher = {ACM},
	Title = {Typing first-class continuations in ML},
	Year = {1991},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFouLi8uLi9QYXBlcnMvRHViYS9EdWJhLUhhcnBlci1NYWNRdWVlbiAtIFR5cGluZyBmaXJzdC1jbGFzcyBjb250aW51YXRpb25zIGluIE1MICgxOTkxKS5wZGbSGw8cHVdOUy5kYXRhTxECJgAAAAACJgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOBcKH0R1YmEtSGFycGVyLU1hY1F1ZWVuIzM4MTcwOC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4FwjENu8KUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAREdWJhABAACAAAwTR+XQAAABEACAAAxDcnSgAAAAEAEAA4FwoALZE/AANHrAAAa9gAAgA9T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkR1YmE6RHViYS1IYXJwZXItTWFjUXVlZW4jMzgxNzA4LnBkZgAADgCSAEgARAB1AGIAYQAtAEgAYQByAHAAZQByAC0ATQBhAGMAUQB1AGUAZQBuACAALQAgAFQAeQBwAGkAbgBnACAAZgBpAHIAcwB0AC0AYwBsAGEAcwBzACAAYwBvAG4AdABpAG4AdQBhAHQAaQBvAG4AcwAgAGkAbgAgAE0ATAAgACgAMQA5ADkAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGFVc2Vycy9qZXJlbXkvUGFwZXJzL0R1YmEvRHViYS1IYXJwZXItTWFjUXVlZW4gLSBUeXBpbmcgZmlyc3QtY2xhc3MgY29udGludWF0aW9ucyBpbiBNTCAoMTk5MSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEHAQwBFAM+A0ADRQNOA1kDXQNrA3IDewOAA4MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/99583.99608}}

@inproceedings{Burstall:HOPE:1980,
	Address = {New York, NY, USA},
	Author = {R. M. Burstall and D. B. MacQueen and D. T. Sannella},
	Booktitle = {LFP '80: Proceedings of the 1980 ACM conference on LISP and functional programming},
	Date-Added = {2008-04-25 02:13:03 -0400},
	Date-Modified = {2008-04-25 02:13:22 -0400},
	Doi = {http://doi.acm.org/10.1145/800087.802799},
	Location = {Stanford University, California, United States},
	Pages = {136--143},
	Publisher = {ACM},
	Title = {HOPE: An experimental applicative language},
	Year = {1980},
	Abstract = {An applicative language called HOPE is described and discussed. The underlying goal of the design and implementation effort was to produce a very simple programming language which encourages the construction of clear and manipulable programs. HOPE does not include an assignment statement; this is felt to be an important simplification. The user may freely define his own data types, without the need to devise a complicated encoding in terms of low-level types. The language is very strongly typed, and as implemented it incorporates a typechecker which handles polymorphic types and overloaded operators. Functions are defined by a set of recursion equations; the left-hand side of each equation includes a pattern used to determine which equation to use for a given argument. The availability of arbitrary higher-order types allows functions to be defined which 'package' recursion. Lazily-evaluated lists are provided, allowing the use of infinite lists which could be used to provide interactive input/output and concurrency. HOPE also includes a simple modularisation facility which may be used to protect the implementation of an abstract data type.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGguLi8uLi9QYXBlcnMvQnVyc3RhbGwvQnVyc3RhbGwtTWFjUXVlZW4tU2FubmVsbGEgLSBIT1BFOiBBbiBleHBlcmltZW50YWwgYXBwbGljYXRpdmUgbGFuZ3VhZ2UgKDE5ODApLnBkZtIbDxwdV05TLmRhdGFPEQJQAAAAAAJQAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4IB0fQnVyc3RhbGwtTWFjUXVlZW4tU2EjMzgxNkZBLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgW+sQ27tBQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAACEJ1cnN0YWxsABAACAAAwTR+XQAAABEACAAAxDcnEAAAAAEAEAA4IB0ALZE/AANHrAAAa9gAAgBBT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkJ1cnN0YWxsOkJ1cnN0YWxsLU1hY1F1ZWVuLVNhIzM4MTZGQS5wZGYAAA4ApgBSAEIAdQByAHMAdABhAGwAbAAtAE0AYQBjAFEAdQBlAGUAbgAtAFMAYQBuAG4AZQBsAGwAYQAgAC0AIABIAE8AUABFAC8AIABBAG4AIABlAHgAcABlAHIAaQBtAGUAbgB0AGEAbAAgAGEAcABwAGwAaQBjAGEAdABpAHYAZQAgAGwAYQBuAGcAdQBhAGcAZQAgACgAMQA5ADgAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG9Vc2Vycy9qZXJlbXkvUGFwZXJzL0J1cnN0YWxsL0J1cnN0YWxsLU1hY1F1ZWVuLVNhbm5lbGxhIC0gSE9QRTogQW4gZXhwZXJpbWVudGFsIGFwcGxpY2F0aXZlIGxhbmd1YWdlICgxOTgwKS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARUBGgEiA3YDeAN9A4YDkQOVA6MDqgOzA7gDuwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAPI},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/800087.802799}}

@article{Appel:Separate:1994,
	Address = {New York, NY, USA},
	Author = {Andrew W. Appel and David B. MacQueen},
	Date-Added = {2008-04-25 02:11:47 -0400},
	Date-Modified = {2008-04-25 02:12:12 -0400},
	Doi = {http://doi.acm.org/10.1145/773473.178245},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {6},
	Pages = {13--23},
	Publisher = {ACM},
	Title = {Separate compilation for {S}tandard {ML}},
	Volume = {29},
	Year = {1994},
	Abstract = {Languages that support abstraction and modular structure, such as Standard ML, Modula, Ada, and (more or less) C++, may have deeply nested dependency hierarchies among source files. In ML the problem is particularly severe because ML's powerful parameterized module (functor) facility entails dependencies among implementation modules, not just among interfaces.To efficiently compile individual modules in such languages, it is useful (in ML, necessary) to infer, digest, and cache the static environment resulting from the compilation of each module. Our system provides a simple model of compilation and linkage that supports incremental recompilation (a restricted form of separate compilation) with type-safe linkage. This model is made available to user programs in the form of a set of internal compiler modules, a feature that we call the ``visible compiler''. The chief client of this interface is the IRM incremental recompilation manager from CMU.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFMuLi8uLi9QYXBlcnMvQXBwZWwvQXBwZWwtTWFjUXVlZW4gLSBTZXBhcmF0ZSBjb21waWxhdGlvbiBmb3IgU3RhbmRhcmQgTUwgKDE5OTQpLnBkZtIbDxwdV05TLmRhdGFPEQIQAAAAAAIQAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtmhsfQXBwZWwtTWFjUXVlZW4gLSBTZXAjMzgxNkZFLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgW/sQ27uBQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABUFwcGVsAAAQAAgAAME0fl0AAAARAAgAAMQ3JyAAAAABABAALZobAC2RPwADR6wAAGvYAAIAPk9kaW46VXNlcnM6amVyZW15OlBhcGVyczpBcHBlbDpBcHBlbC1NYWNRdWVlbiAtIFNlcCMzODE2RkUucGRmAA4AggBAAEEAcABwAGUAbAAtAE0AYQBjAFEAdQBlAGUAbgAgAC0AIABTAGUAcABhAHIAYQB0AGUAIABjAG8AbQBwAGkAbABhAHQAaQBvAG4AIABmAG8AcgAgAFMAdABhAG4AZABhAHIAZAAgAE0ATAAgACgAMQA5ADkANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFpVc2Vycy9qZXJlbXkvUGFwZXJzL0FwcGVsL0FwcGVsLU1hY1F1ZWVuIC0gU2VwYXJhdGUgY29tcGlsYXRpb24gZm9yIFN0YW5kYXJkIE1MICgxOTk0KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBAAEFAQ0DIQMjAygDMQM8A0ADTgNVA14DYwNmAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA3M=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/773473.178245}}

@inproceedings{Kuan:Efficient:2007,
	Address = {New York, NY, USA},
	Author = {George Kuan and David MacQueen},
	Booktitle = {ML '07: Proceedings of the 2007 workshop on Workshop on ML},
	Date-Added = {2008-04-25 02:08:37 -0400},
	Date-Modified = {2008-04-28 01:56:02 -0400},
	Doi = {http://doi.acm.org/10.1145/1292535.1292538},
	Isbn = {978-1-59593-676-9},
	Keywords = {optimization},
	Location = {Freiburg, Germany},
	Pages = {3--14},
	Publisher = {ACM},
	Title = {Efficient type inference using ranked type variables},
	Year = {2007},
	Abstract = {The Damas-Milner type inference algorithm (commonly known as algorithm $W$) is at the core of all ML type checkers. Although the algorithm is known to have poor worst-case behavior [8], in practice well-engineered type checkers will run in approximately linear time. To achieve this efficiency, implementations need to improve on algorithm W's method of scanning the complete type environment to determine whether a type variable can be generalized at a let binding. Following a suggestion of Damas, most ML type checkers use an alternative method based on ranking unification variables to track their position in the type environment.

Here we formalize two such ranking systems, one based on lambda depth (used in the SML/NJ compiler), and the other based on let depth (used in OCaml, for instance). Each of these systems is formalized both with and without the value restriction, and they are proved correct relative to the classic algorithm $W$. Our formalizations of the various algorithms use simple abstract machines that are similar to small-step evaluation semantics.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFIuLi8uLi9QYXBlcnMvS3Vhbi9LdWFuLU1hY1F1ZWVuIC0gRWZmaWNpZW50IHR5cGUgaW5mZXJlbmNlIHVzaW5nIHJhbmtlZCAoMjAwNykucGRm0hsPHB1XTlMuZGF0YU8RAg4AAAAAAg4AAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADgWyB9LdWFuLU1hY1F1ZWVuIC0gRWZmaSMzODE2QzcucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOBbHxDbtylBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAES3VhbgAQAAgAAME0fl0AAAARAAgAAMQ3JgoAAAABABAAOBbIAC2RPwADR6wAAGvYAAIAPU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpLdWFuOkt1YW4tTWFjUXVlZW4gLSBFZmZpIzM4MTZDNy5wZGYAAA4AggBAAEsAdQBhAG4ALQBNAGEAYwBRAHUAZQBlAG4AIAAtACAARQBmAGYAaQBjAGkAZQBuAHQAIAB0AHkAcABlACAAaQBuAGYAZQByAGUAbgBjAGUAIAB1AHMAaQBuAGcAIAByAGEAbgBrAGUAZAAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFlVc2Vycy9qZXJlbXkvUGFwZXJzL0t1YW4vS3Vhbi1NYWNRdWVlbiAtIEVmZmljaWVudCB0eXBlIGluZmVyZW5jZSB1c2luZyByYW5rZWQgKDIwMDcpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA/wEEAQwDHgMgAyUDLgM5Az0DSwNSA1sDYANjAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA3A=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1292535.1292538}}

@inproceedings{MacQueen:An-implementation:1988,
	Address = {New York, NY, USA},
	Author = {David MacQueen},
	Booktitle = {LFP '88: Proceedings of the 1988 ACM conference on LISP and functional programming},
	Date-Added = {2008-04-25 02:04:00 -0400},
	Date-Modified = {2008-04-25 02:04:37 -0400},
	Doi = {http://doi.acm.org/10.1145/62678.62704},
	Isbn = {0-89791-273-X},
	Location = {Snowbird, Utah, United States},
	Pages = {212--223},
	Publisher = {ACM},
	Title = {An implementation of standard ML modules},
	Year = {1988},
	Abstract = {Standard ML includes a set of module constructs that support programming in the large. These constructs extend ML's basic polymorphic type system by introducing the dependent types of Martin L{\"o}f's Intuitionistic Type Theory. This paper discusses the problems involved in implementing Standard ML's modules and describes a practical, efficient solution to these problems. The representations and algorithms of this implementation were inspired by a detailed formal semantics of Standard ML developed by Milner, Tofte, and Harper. The implementation is part of a new Standard ML compiler that is written in Standard ML using the module system.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFQuLi8uLi9QYXBlcnMvTWFjUXVlZW4vTWFjUXVlZW4gLSBBbiBpbXBsZW1lbnRhdGlvbiBvZiBzdGFuZGFyZCBNTCBtb2R1bGVzICgxOTg4KS5wZGbSGw8cHVdOUy5kYXRhTxECFAAAAAACFAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOBaiH01hY1F1ZWVuIC0gQW4gaW1wbGVtIzM4MTZDQy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4FszENu3oUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAhNYWNRdWVlbgAQAAgAAME0fl0AAAARAAgAAMQ3JigAAAABABAAOBaiAC2RPwADR6wAAGvYAAIAQU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpNYWNRdWVlbjpNYWNRdWVlbiAtIEFuIGltcGxlbSMzODE2Q0MucGRmAAAOAH4APgBNAGEAYwBRAHUAZQBlAG4AIAAtACAAQQBuACAAaQBtAHAAbABlAG0AZQBuAHQAYQB0AGkAbwBuACAAbwBmACAAcwB0AGEAbgBkAGEAcgBkACAATQBMACAAbQBvAGQAdQBsAGUAcwAgACgAMQA5ADgAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFtVc2Vycy9qZXJlbXkvUGFwZXJzL01hY1F1ZWVuL01hY1F1ZWVuIC0gQW4gaW1wbGVtZW50YXRpb24gb2Ygc3RhbmRhcmQgTUwgbW9kdWxlcyAoMTk4OCkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEBAQYBDgMmAygDLQM2A0EDRQNTA1oDYwNoA2sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADeA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/62678.62704}}

@inproceedings{MacQueen:A-Semantics:1994,
	Address = {London, UK},
	Author = {David B. MacQueen and Mads Tofte},
	Booktitle = {ESOP '94: Proceedings of the 5th European Symposium on Programming},
	Date-Added = {2008-04-25 02:01:10 -0400},
	Date-Modified = {2008-04-25 02:07:22 -0400},
	Isbn = {3-540-57880-3},
	Pages = {409--423},
	Publisher = {Springer-Verlag},
	Title = {A Semantics for Higher-Order Functors},
	Year = {1994},
	Abstract = {Standard ML has a module system that allows one to define parametric modules, called functors. Functors are "first-order," meaning that functors themselves cannot be passed as parameters or returned as results of functor applications. This paper presents a semantics for a higher-order module system which generalizes the module system of Standard ML. The higher-order functors described here are implemented in the current version of Standard ML of New Jersey and have proved useful in programming practice.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFcuLi8uLi9QYXBlcnMvTWFjUXVlZW4vTWFjUXVlZW4tVG9mdGUgLSBBIFNlbWFudGljcyBmb3IgSGlnaGVyLU9yZGVyIEZ1bmN0b3JzICgxOTk0KS5wZGbSGw8cHVdOUy5kYXRhTxECHAAAAAACHAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOBaiH01hY1F1ZWVuLVRvZnRlIC0gQSBTIzM4MTZFMi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4FuLENu5ZUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAhNYWNRdWVlbgAQAAgAAME0fl0AAAARAAgAAMQ3JpkAAAABABAAOBaiAC2RPwADR6wAAGvYAAIAQU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpNYWNRdWVlbjpNYWNRdWVlbi1Ub2Z0ZSAtIEEgUyMzODE2RTIucGRmAAAOAIQAQQBNAGEAYwBRAHUAZQBlAG4ALQBUAG8AZgB0AGUAIAAtACAAQQAgAFMAZQBtAGEAbgB0AGkAYwBzACAAZgBvAHIAIABIAGkAZwBoAGUAcgAtAE8AcgBkAGUAcgAgAEYAdQBuAGMAdABvAHIAcwAgACgAMQA5ADkANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF5Vc2Vycy9qZXJlbXkvUGFwZXJzL01hY1F1ZWVuL01hY1F1ZWVuLVRvZnRlIC0gQSBTZW1hbnRpY3MgZm9yIEhpZ2hlci1PcmRlciBGdW5jdG9ycyAoMTk5NCkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQQBCQERAzEDMwM4A0EDTANQA14DZQNuA3MDdgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOD}}

@inproceedings{MacQueen:Using:1986,
	Author = {David B. MacQueen},
	Booktitle = {Proceedings of the 13th annual ACM symposium on Principles of programming languages},
	Date-Added = {2008-04-25 01:55:03 -0400},
	Date-Modified = {2008-04-25 02:11:05 -0400},
	Doi = {http://doi.acm.org/10.1145/512644.512670},
	Location = {St. Petersburg Beach, Florida},
	Pages = {277--286},
	Publisher = {ACM Press},
	Title = {Using dependent types to express modular structure},
	Year = {1986},
	Abstract = {Writing any large program poses difficult problems of organization. In many modern programming languages these problems are addressed by special linguistic constructs, variously known as modules, packages, or clusters, which provide for partitioning programs into manageable components and for securely combining these components to form complete programs. Some general purpose components are able to take on a life of their own, being separately compiled and stored in libraries of generic, reusable program units. Usually modularity constructs also support some form of information hiding, such as "abstract data types." "Programming in the large" is concerned with using such constructs to impose structure on large programs, in contrast to "programming in the small", which deals with the detailed implementation of algorithms in terms of data structures and control constructs. Our goal here is to examine some of the proposed linguistic notions with respect to how they meet the pragmatic requirements of programming in the large.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFQuLi8uLi9QYXBlcnMvTWFjUXVlZW4vTWFjUXVlZW4gLSBVc2luZyBkZXBlbmRlbnQgdHlwZXMgdG8gZXhwcmVzcyBtb2R1bGFyICgxOTg2KS5wZGbSGw8cHVdOUy5kYXRhTxECFAAAAAACFAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOBaiH01hY1F1ZWVuIC0gVXNpbmcgZGVwIzM4MTZERS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4Ft7ENu5KUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAhNYWNRdWVlbgAQAAgAAME0fl0AAAARAAgAAMQ3JooAAAABABAAOBaiAC2RPwADR6wAAGvYAAIAQU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpNYWNRdWVlbjpNYWNRdWVlbiAtIFVzaW5nIGRlcCMzODE2REUucGRmAAAOAH4APgBNAGEAYwBRAHUAZQBlAG4AIAAtACAAVQBzAGkAbgBnACAAZABlAHAAZQBuAGQAZQBuAHQAIAB0AHkAcABlAHMAIAB0AG8AIABlAHgAcAByAGUAcwBzACAAbQBvAGQAdQBsAGEAcgAgACgAMQA5ADgANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFtVc2Vycy9qZXJlbXkvUGFwZXJzL01hY1F1ZWVuL01hY1F1ZWVuIC0gVXNpbmcgZGVwZW5kZW50IHR5cGVzIHRvIGV4cHJlc3MgbW9kdWxhciAoMTk4NikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEBAQYBDgMmAygDLQM2A0EDRQNTA1oDYwNoA2sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADeA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/512644.512670}}

@inproceedings{MacQueen:Modules:1984,
	Author = {David MacQueen},
	Booktitle = {Proceedings of the 1984 ACM Symposium on LISP and functional programming},
	Date-Added = {2008-04-25 01:54:25 -0400},
	Date-Modified = {2008-04-25 02:00:02 -0400},
	Isbn = {0-89791-142-3},
	Location = {Austin, Texas, United States},
	Pages = {198--207},
	Title = {Modules for standard ML},
	Year = {1984},
	Abstract = {The functional programming language ML has been undergoing a thorough redesign during the past year, and the module facility described here has been proposed as part of the revised language, now called Standard ML. The design has three main goals: (1) to facilitate the structuring of large ML programs; (2) to support separate compilation and generic library units; and (3) to employ new ideas in the semantics of data types to extend the power of ML's polymorphic type system. It is based on concepts inherent in the structure of ML, primarily the notions of a declaration, its type signature, and the environment that it denotes},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEMuLi8uLi9QYXBlcnMvTWFjUXVlZW4vTWFjUXVlZW4gLSBNb2R1bGVzIGZvciBzdGFuZGFyZCBNTCAoMTk4NCkucGRm0hsPHB1XTlMuZGF0YU8RAeAAAAAAAeAAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADgWoh9NYWNRdWVlbiAtIE1vZHVsZXMgZiMzODE2OTQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOBaUxDbsMVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAITWFjUXVlZW4AEAAIAADBNH5dAAAAEQAIAADENyRxAAAAAQAQADgWogAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6TWFjUXVlZW46TWFjUXVlZW4gLSBNb2R1bGVzIGYjMzgxNjk0LnBkZgAADgBcAC0ATQBhAGMAUQB1AGUAZQBuACAALQAgAE0AbwBkAHUAbABlAHMAIABmAG8AcgAgAHMAdABhAG4AZABhAHIAZAAgAE0ATAAgACgAMQA5ADgANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAEpVc2Vycy9qZXJlbXkvUGFwZXJzL01hY1F1ZWVuL01hY1F1ZWVuIC0gTW9kdWxlcyBmb3Igc3RhbmRhcmQgTUwgKDE5ODQpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgDwAPUA/QLhAuMC6ALxAvwDAAMOAxUDHgMjAyYAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADMw==}}

@inproceedings{Plumicke:Typeless:2006,
	Address = {New York, NY, USA},
	Author = {Martin Pl\"{u}micke and J\"{o}rg B\"{a}uerle},
	Booktitle = {PPPJ '06: Proceedings of the 4th international symposium on Principles and practice of programming in Java},
	Date-Added = {2008-04-25 01:38:21 -0400},
	Date-Modified = {2008-04-25 01:40:10 -0400},
	Doi = {http://doi.acm.org/10.1145/1168054.1168079},
	Isbn = {3-939352-05-5},
	Location = {Mannheim, Germany},
	Pages = {175--181},
	Publisher = {ACM},
	Title = {Typeless programming in Java 5.0},
	Year = {2006},
	Abstract = {With the introduction of Java 5.0 [9] the type system has been extended by parameterized types, type variables, type terms, and wildcards. As a result very complex types can arise. The termVector<Vector<AbstractList<Integer>>>is for example a correct type in Java 5.0.

Considering all that, it is often rather difficult for a programmer to recognize whether such a complex type is the correct one for a given method or not. Furthermore there are methods whose principle types would be intersection types. But intersection types are not implemented in Java 5.0. This means that Java 5.0 methods often don't have the principle type which is contradictive to the OOP-Principle of writing re-usable code.

This has caused us to develop a Java 5.0 type inference system which assists the programmer by calculating types automatically. This type inference system allows us, to declare method parameters and local variables without type annotations. The type inference algorithm calculates the appropriate and principle types.

We implement the algorithm in Java using the observer design pattern.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFQuLi8uLi9QYXBlcnMvUGx1bWlja2UvUGx1bWlja2UtQmF1ZXJsZSAtIFR5cGVsZXNzIHByb2dyYW1taW5nIGluIEphdmEgNS4wICgyMDA2KS5wZGbSGw8cHVdOUy5kYXRhTxECFAAAAAACFAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOBYTH1BsdW1pY2tlLUJhdWVybGUgLSBUIzM4MTYxMi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4FhLENubpUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAhQbHVtaWNrZQAQAAgAAME0fl0AAAARAAgAAMQ3HykAAAABABAAOBYTAC2RPwADR6wAAGvYAAIAQU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpQbHVtaWNrZTpQbHVtaWNrZS1CYXVlcmxlIC0gVCMzODE2MTIucGRmAAAOAH4APgBQAGwAdQBtAGkAYwBrAGUALQBCAGEAdQBlAHIAbABlACAALQAgAFQAeQBwAGUAbABlAHMAcwAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgAGkAbgAgAEoAYQB2AGEAIAA1AC4AMAAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFtVc2Vycy9qZXJlbXkvUGFwZXJzL1BsdW1pY2tlL1BsdW1pY2tlLUJhdWVybGUgLSBUeXBlbGVzcyBwcm9ncmFtbWluZyBpbiBKYXZhIDUuMCAoMjAwNikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEBAQYBDgMmAygDLQM2A0EDRQNTA1oDYwNoA2sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADeA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1168054.1168079}}

@inproceedings{Plumicke:Typeless:2007,
	Address = {New York, NY, USA},
	Author = {Martin Pl\"{u}micke},
	Booktitle = {PPPJ '07: Proceedings of the 5th international symposium on Principles and practice of programming in Java},
	Date-Added = {2008-04-25 01:37:20 -0400},
	Date-Modified = {2008-04-25 01:37:36 -0400},
	Doi = {http://doi.acm.org/10.1145/1294325.1294336},
	Isbn = {978-1-59593-672-1},
	Location = {Lisboa, Portugal},
	Pages = {73--82},
	Publisher = {ACM},
	Title = {Typeless programming in Java 5.0 with wildcards},
	Year = {2007},
	Abstract = {With the introduction of Java 5.0 [8] the type system has been extended by parameterized types, type variables, type terms, and wildcards. As a result very complex types can arise. The term Vector<? super Vector<? extends List<Integer>>> is for example a correct type in Java 5.0.

Considering all that, it is often rather inconvienent to give types like this, explictly. Furthermore there are methods whose principal types would be intersection types. But intersection types are not implemented in Java 5.0. This means that Java 5.0 methods often do not have the principal type which is contradictive to the OOP-Principle of writing re-usable code.

This has caused us to develop a Java 5.0 type inference system which assists the programmer by calculating types automatically. This type inference system allows us, to declare method parameters and local variables without type annotations. The type inference algorithm calculates the appropriate and principal types.

In this contribution we present the ideas extending type inference for types with wildcards.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFsuLi8uLi9QYXBlcnMvUGx1bWlja2UvUGx1bWlja2UgLSBUeXBlbGVzcyBwcm9ncmFtbWluZyBpbiBKYXZhIDUuMCB3aXRoIHdpbGRjYXJkcyAoMjAwNykucGRm0hsPHB1XTlMuZGF0YU8RAigAAAAAAigAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADgWEx9QbHVtaWNrZSAtIFR5cGVsZXNzICMzODE2MUMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOBYcxDbnD1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIUGx1bWlja2UAEAAIAADBNH5dAAAAEQAIAADENx9PAAAAAQAQADgWEwAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6UGx1bWlja2U6UGx1bWlja2UgLSBUeXBlbGVzcyAjMzgxNjFDLnBkZgAADgCMAEUAUABsAHUAbQBpAGMAawBlACAALQAgAFQAeQBwAGUAbABlAHMAcwAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgAGkAbgAgAEoAYQB2AGEAIAA1AC4AMAAgAHcAaQB0AGgAIAB3AGkAbABkAGMAYQByAGQAcwAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGJVc2Vycy9qZXJlbXkvUGFwZXJzL1BsdW1pY2tlL1BsdW1pY2tlIC0gVHlwZWxlc3MgcHJvZ3JhbW1pbmcgaW4gSmF2YSA1LjAgd2l0aCB3aWxkY2FyZHMgKDIwMDcpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEIAQ0BFQNBA0MDSANRA1wDYANuA3UDfgODA4YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1294325.1294336}}

@article{Peyton-Jones:Practical:2007,
	Address = {New York, NY, USA},
	Author = {Peyton Jones, Simon and Dimitrios Vytiniotis and Stephanie Weirich and Mark Shields},
	Date-Added = {2008-04-25 01:29:03 -0400},
	Date-Modified = {2008-04-25 01:33:54 -0400},
	Doi = {http://dx.doi.org/10.1017/S0956796806006034},
	Issn = {0956-7968},
	Journal = {J. Funct. Program.},
	Number = {1},
	Pages = {1--82},
	Publisher = {Cambridge University Press},
	Title = {Practical type inference for arbitrary-rank types},
	Url = {http://research.microsoft.com/~simonpj/papers/higher-rank/},
	Volume = {17},
	Year = {2007},
	Abstract = {Haskell's popularity has driven the need for ever more expressive type system features, most of which threaten the decidability and practicality of Damas-Milner type inference. One such feature is the ability to write functions with higher-rank types -- that is, functions that take polymorphic functions as their arguments.

Complete type inference is known to be undecidable for higher-rank (impredicative) type systems, but in practice programmers are more than willing to add type annotations to guide the type inference engine, and to document their code. However, the choice of just what annotations are required, and what changes are required in the type system and its inference algorithm, has been an ongoing topic of research.

We take as our starting point a $\lambda$-calculus proposed by Odersky and L{\"a}ufer. Their system supports arbitrary-rank polymorphism through the exploitation of type annotations on $\lambda$-bound arguments and arbitrary sub-terms. Though elegant, and more convenient than some other proposals, Odersky and L{\"{a}}ufer's system requires many annotations. We show how to use local type inference (invented by Pierce and Turner) to greatly reduce the annotation burden, to the point where higher-rank types become eminently usable.

Higher-rank types have a very modest impact on type inference. We substantiate this claim in a very concrete way, by presenting a complete type-inference engine, written in Haskell, for a traditional Damas-Milner type system, and then showing how to extend it for higher-rank types. We write the type-inference engine using a monadic framework: it turns out to be a particularly compelling example of monads in action.

The paper is long, but is strongly tutorial in style. Although we use Haskell as our example source language, and our implementation language, much of our work is directly applicable to any ML-like functional language.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHguLi8uLi9QYXBlcnMvUGV5dG9uIEpvbmVzL1BleXRvbiBKb25lcy1WeXRpbmlvdGlzLVdlaXJpY2ggLSBQcmFjdGljYWwgdHlwZSBpbmZlcmVuY2UgZm9yIGFyYml0cmFyeS1yYW5rIHR5cGVzICgyMDA3KS5wZGbSGw8cHVdOUy5kYXRhTxECgAAAAAACgAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZF6H1BleXRvbiBKb25lcy1WeXRpbmlvIzM4MTVENy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4FdfENuUTAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAxQZXl0b24gSm9uZXMAEAAIAADBNH5dAAAAEQAIAADENx1TAAAAAQAQAC2RegAtkT8AA0esAABr2AACAEVPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6UGV5dG9uIEpvbmVzOlBleXRvbiBKb25lcy1WeXRpbmlvIzM4MTVENy5wZGYAAA4AvgBeAFAAZQB5AHQAbwBuACAASgBvAG4AZQBzAC0AVgB5AHQAaQBuAGkAbwB0AGkAcwAtAFcAZQBpAHIAaQBjAGgAIAAtACAAUAByAGEAYwB0AGkAYwBhAGwAIAB0AHkAcABlACAAaQBuAGYAZQByAGUAbgBjAGUAIABmAG8AcgAgAGEAcgBiAGkAdAByAGEAcgB5AC0AcgBhAG4AawAgAHQAeQBwAGUAcwAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAH9Vc2Vycy9qZXJlbXkvUGFwZXJzL1BleXRvbiBKb25lcy9QZXl0b24gSm9uZXMtVnl0aW5pb3Rpcy1XZWlyaWNoIC0gUHJhY3RpY2FsIHR5cGUgaW5mZXJlbmNlIGZvciBhcmJpdHJhcnktcmFuayB0eXBlcyAoMjAwNykucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgElASoBMgO2A7gDvQPGA9ED1QPjA+oD8wP4A/sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAECA==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1017/S0956796806006034},
	Bdsk-Url-2 = {http://research.microsoft.com/~simonpj/papers/higher-rank/}}

@article{Heeren:Scripting:2003,
	Address = {New York, NY, USA},
	Author = {Bastiaan Heeren and Jurriaan Hage and S. Doaitse Swierstra},
	Date-Added = {2008-04-25 01:26:11 -0400},
	Date-Modified = {2008-04-25 01:26:25 -0400},
	Doi = {http://doi.acm.org/10.1145/944746.944707},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {9},
	Pages = {3--13},
	Publisher = {ACM},
	Title = {Scripting the type inference process},
	Volume = {38},
	Year = {2003},
	Abstract = {To improve the quality of type error messages in functional programming languages,we propose four techniques which influence the behaviour of constraint-based type inference processes. These techniques take the form of externally supplied type inference directives, precluding the need to make any changes to the compiler. A second advantage is that the directives are automatically checked for soundness with respect to the underlying type system. We show how the techniques can be used to improve the type error messages reported for a combinator library. More specifically, how they can help to generate error messages which are conceptually closer to the domain for which the library was developed. The techniques have all been incorporated in the Helium compiler, which implements a large subset of Haskell.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFsuLi8uLi9QYXBlcnMvSGVlcmVuL0hlZXJlbi1IYWdlLVN3aWVyc3RyYSAtIFNjcmlwdGluZyB0aGUgdHlwZSBpbmZlcmVuY2UgcHJvY2VzcyAoMjAwMykucGRm0hsPHB1XTlMuZGF0YU8RAigAAAAAAigAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADgV5x9IZWVyZW4tSGFnZS1Td2llcnN0ciMzODE1QUIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOBWrxDbjylBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGSGVlcmVuABAACAAAwTR+XQAAABEACAAAxDccCgAAAAEAEAA4FecALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkhlZXJlbjpIZWVyZW4tSGFnZS1Td2llcnN0ciMzODE1QUIucGRmAAAOAJAARwBIAGUAZQByAGUAbgAtAEgAYQBnAGUALQBTAHcAaQBlAHIAcwB0AHIAYQAgAC0AIABTAGMAcgBpAHAAdABpAG4AZwAgAHQAaABlACAAdAB5AHAAZQAgAGkAbgBmAGUAcgBlAG4AYwBlACAAcAByAG8AYwBlAHMAcwAgACgAMgAwADAAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGJVc2Vycy9qZXJlbXkvUGFwZXJzL0hlZXJlbi9IZWVyZW4tSGFnZS1Td2llcnN0cmEgLSBTY3JpcHRpbmcgdGhlIHR5cGUgaW5mZXJlbmNlIHByb2Nlc3MgKDIwMDMpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEIAQ0BFQNBA0MDSANRA1wDYANuA3UDfgODA4YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/944746.944707}}

@article{Vytiniotis:Boxy:2006,
	Address = {New York, NY, USA},
	Author = {Dimitrios Vytiniotis and Stephanie Weirich and Simon Peyton Jones},
	Date-Added = {2008-04-25 01:24:27 -0400},
	Date-Modified = {2008-05-01 20:29:49 -0400},
	Doi = {http://doi.acm.org/10.1145/1160074.1159838},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {9},
	Pages = {251--262},
	Publisher = {ACM},
	Title = {Boxy types: inference for higher-rank types and impredicativity},
	Url = {http://www.cis.upenn.edu/~dimitriv/dimitriv-inference.html},
	Volume = {41},
	Year = {2006},
	Abstract = {Languages with rich type systems are beginning to employ a blend of type \textit{inference} and type \textit{checking}, so that the type inference engine is guided by programmer-supplied type annotations. In this paper we show, for the first time, how to combine the virtues of two well-established ideas: unification-based inference, and bidirectional propagation of type annotations. The result is a type system that conservatively extends Hindley-Milner, and yet supports both higher-rank types and impredicativity.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGkuLi8uLi9QYXBlcnMvVnl0aW5pb3Rpcy9WeXRpbmlvdGlzLVdlaXJpY2gtSm9uZXMgLSBCb3h5IHR5cGVzOiBpbmZlcmVuY2UgZm9yIGhpZ2hlci1yYW5rIHR5cGVzICgyMDA2KS5wZGbSGw8cHVdOUy5kYXRhTxECUgAAAAACUgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOBXcH1Z5dGluaW90aXMtV2VpcmljaC1KIzM4MTVBMC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4FaDENuOAUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAApWeXRpbmlvdGlzABAACAAAwTR+XQAAABEACAAAxDcbwAAAAAEAEAA4FdwALZE/AANHrAAAa9gAAgBDT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlZ5dGluaW90aXM6Vnl0aW5pb3Rpcy1XZWlyaWNoLUojMzgxNUEwLnBkZgAADgCkAFEAVgB5AHQAaQBuAGkAbwB0AGkAcwAtAFcAZQBpAHIAaQBjAGgALQBKAG8AbgBlAHMAIAAtACAAQgBvAHgAeQAgAHQAeQBwAGUAcwAvACAAaQBuAGYAZQByAGUAbgBjAGUAIABmAG8AcgAgAGgAaQBnAGgAZQByAC0AcgBhAG4AawAgAHQAeQBwAGUAcwAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHBVc2Vycy9qZXJlbXkvUGFwZXJzL1Z5dGluaW90aXMvVnl0aW5pb3Rpcy1XZWlyaWNoLUpvbmVzIC0gQm94eSB0eXBlczogaW5mZXJlbmNlIGZvciBoaWdoZXItcmFuayB0eXBlcyAoMjAwNikucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARYBGwEjA3kDewOAA4kDlAOYA6YDrQO2A7sDvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAPL},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1160074.1159838},
	Bdsk-Url-2 = {http://www.cis.upenn.edu/~dimitriv/dimitriv-inference.html}}

@inproceedings{Damas:Principal:1982,
	Address = {New York, NY, USA},
	Author = {Lu{\'{i}}s Damas and Robin Milner},
	Booktitle = {POPL '82: Proceedings of the 9th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
	Date-Added = {2008-04-25 01:20:02 -0400},
	Date-Modified = {2008-04-25 01:20:18 -0400},
	Doi = {http://doi.acm.org/10.1145/582153.582176},
	Isbn = {0-89791-065-6},
	Location = {Albuquerque, Mexico},
	Pages = {207--212},
	Publisher = {ACM},
	Title = {Principal type-schemes for functional programs},
	Year = {1982},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFsuLi8uLi9QYXBlcnMvRGFtYXMvRGFtYXMtTWlsbmVyIC0gUHJpbmNpcGFsIHR5cGUtc2NoZW1lcyBmb3IgZnVuY3Rpb25hbCBwcm9ncmFtcyAoMTk4MikucGRm0hsPHB1XTlMuZGF0YU8RAigAAAAAAigAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADgVix9EYW1hcy1NaWxuZXIgLSBQcmluYyMzODE1ODkucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOBWJxDbilFBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAFRGFtYXMAABAACAAAwTR+XQAAABEACAAAxDca1AAAAAEAEAA4FYsALZE/AANHrAAAa9gAAgA+T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkRhbWFzOkRhbWFzLU1pbG5lciAtIFByaW5jIzM4MTU4OS5wZGYADgCSAEgARABhAG0AYQBzAC0ATQBpAGwAbgBlAHIAIAAtACAAUAByAGkAbgBjAGkAcABhAGwAIAB0AHkAcABlAC0AcwBjAGgAZQBtAGUAcwAgAGYAbwByACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgAHAAcgBvAGcAcgBhAG0AcwAgACgAMQA5ADgAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGJVc2Vycy9qZXJlbXkvUGFwZXJzL0RhbWFzL0RhbWFzLU1pbG5lciAtIFByaW5jaXBhbCB0eXBlLXNjaGVtZXMgZm9yIGZ1bmN0aW9uYWwgcHJvZ3JhbXMgKDE5ODIpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEIAQ0BFQNBA0MDSANRA1wDYANuA3UDfgODA4YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/582153.582176}}

@book{Gansner:The-Standard:2002,
	Author = {Emden R. Gansner and John H. Reppy},
	Date-Added = {2008-04-25 00:37:30 -0400},
	Date-Modified = {2008-04-25 00:38:39 -0400},
	Isbn = {978-0521791427},
	Publisher = {Cambridge University Press},
	Title = {The {S}tandard {ML} Basis Library},
	Year = {2002}}

@book{Milner:Commentary:1990,
	Author = {Robin Milner and Mads Tofte},
	Date-Added = {2008-04-25 00:23:36 -0400},
	Date-Modified = {2008-04-25 00:26:37 -0400},
	Isbn = {978-0-262-63137-2},
	Month = {Nov},
	Publisher = {MIT Press},
	Title = {Commentary on Standard ML},
	Year = {1990}}

@book{Milner:The-Definition:1990,
	Author = {Robiner Milner and Mads Tofte and Robert Harper},
	Date-Added = {2008-04-25 00:19:47 -0400},
	Date-Modified = {2008-04-25 00:26:57 -0400},
	Isbn = {978-0-262-63132-7},
	Month = {Feb},
	Publisher = {MIT Press},
	Title = {The Definition of Standard ML},
	Year = {1990}}

@book{Milner:The-Definition:1997,
	Author = {Robin Milner and Mads Tofte and Robert Harper and David MacQueen},
	Date-Added = {2008-04-25 00:17:20 -0400},
	Date-Modified = {2008-04-25 00:30:31 -0400},
	Isbn = {978-0-262-63181-5},
	Month = {May},
	Publisher = {MIT Press},
	Title = {The Definition of Standard ML (Revised)},
	Year = {1997},
	Abstract = {Standard ML is general-purpose programming language designed for large projects. This book provides a formal definition of Standard ML for the benefit of all concerned with the language, including users and implementers. Because computer programs are increasingly required to withstand rigorous analysis, it is all the more important that the language in which they are written be defined with full rigor. The authors have defined their semantic objects in mathematical notation that is completely independent of Standard ML.}}

@article{Curry:Modified:1969,
	Author = {Curry},
	Date-Added = {2008-04-25 00:10:38 -0400},
	Date-Modified = {2008-04-25 00:33:54 -0400},
	Doi = {10.1111/j.1746-8361.1969.tb01183.x },
	Journal = {Dialectica},
	Month = {June},
	Number = {2},
	Pages = {83--92},
	Title = {Modified basic functionality in combinatory logic},
	Volume = {23},
	Year = {1969},
	Bdsk-Url-1 = {http://dx.doi.org/10.1111/j.1746-8361.1969.tb01183.x%20}}

@article{Hindley:Principal:1990,
	Author = {Hindley, J. Roger and Meredith, David},
	Date-Added = {2008-04-25 00:01:23 -0400},
	Date-Modified = {2008-04-25 00:05:42 -0400},
	Issn = {00224812},
	Journal = {The Journal of Symbolic Logic},
	Number = {1},
	Pages = {90--105},
	Title = {Principal Type-Schemes and Condensed Detachment},
	Url = {http://www.jstor.org/stable/2274956},
	Volume = {55},
	Year = {1990},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGIuLi8uLi9QYXBlcnMvSGluZGxleS9IaW5kbGV5LU1lcmVkaXRoIC0gUHJpbmNpcGFsIFR5cGUtU2NoZW1lcyBhbmQgQ29uZGVuc2VkIERldGFjaG1lbnQgKDE5OTApLnBkZtIbDxwdV05TLmRhdGFPEQI+AAAAAAI+AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4E8IfSGluZGxleS1NZXJlZGl0aCAtIFAjMzgxM0I4LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgTuMQ20RxQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAB0hpbmRsZXkAABAACAAAwTR+XQAAABEACAAAxDcJXAAAAAEAEAA4E8IALZE/AANHrAAAa9gAAgBAT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkhpbmRsZXk6SGluZGxleS1NZXJlZGl0aCAtIFAjMzgxM0I4LnBkZgAOAJwATQBIAGkAbgBkAGwAZQB5AC0ATQBlAHIAZQBkAGkAdABoACAALQAgAFAAcgBpAG4AYwBpAHAAYQBsACAAVAB5AHAAZQAtAFMAYwBoAGUAbQBlAHMAIABhAG4AZAAgAEMAbwBuAGQAZQBuAHMAZQBkACAARABlAHQAYQBjAGgAbQBlAG4AdAAgACgAMQA5ADkAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGlVc2Vycy9qZXJlbXkvUGFwZXJzL0hpbmRsZXkvSGluZGxleS1NZXJlZGl0aCAtIFByaW5jaXBhbCBUeXBlLVNjaGVtZXMgYW5kIENvbmRlbnNlZCBEZXRhY2htZW50ICgxOTkwKS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQ8BFAEcA14DYANlA24DeQN9A4sDkgObA6ADowAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOw},
	Bdsk-Url-1 = {http://www.jstor.org/stable/2274956}}

@article{Hindley:The-principal:1969,
	Author = {Hindley, Roger},
	Date-Added = {2008-04-24 23:54:59 -0400},
	Date-Modified = {2008-04-25 03:47:15 -0400},
	Issn = {0002-9947},
	Journal = {Transactions of the American Mathematical Society},
	Month = {Dec.},
	Pages = {29--60},
	Title = {The Principal Type-Scheme of an Object in Combinatory Logic},
	Url = {http://www.jstor.org/stable/1995158},
	Volume = {149},
	Year = {1969},
	Annote = {No Subject

    * To: TYPES@THEORY.LCS.MIT.EDU
    * From: <DEZANI%ITOINFO.BITNET%IBOINFN.BITNET@MITVMA.MIT.EDU>
    * Date: Thu, 14 Apr 88 13:12 N
    * Reply-To: <DEZANI%ITOINFO.BITNET%IBOINFN.BITNET@MITVMA.MIT.EDU>

Received: From ITOINFO(MAILER) by IBOINFN with RSCS id 0000
          for MAILER@(&; Thu, 14 Apr 88 12:45 N
Message-id: <001>
Date: THU, 14-APR-88 13:11 N
From: <DEZANI@ITOINFO.BITNET>
Subject:
To:   <TYPES@THEORY.LCS.MIT.EDU>

Received: by leonardo.uucp
      (ITOINFO) (4.12/3.14

     )
        id AA27209; Thu, 14 Apr 88 11:42:53 GMT
Date: Thu, 14 Apr 88 11:42:53 GMT
From: dezani@ITOINFO (Dezani Mariangela)
To: types%THEORY.LCS.MIT.EDU@IBOINFN


Subject: Typed versus untyped  (Albert's April 10 note).

From: Roger Hindley (majrh%pyramid.swansea.ac.uk@rl.earn
 but temporarily c/o Mariangiola Dezani, address as header)


Henk's slogan "Church vs Curry" sounds a good approximation,
though
"Typed terms  vs Type-assignment" gives the flavour of the
distinction better.

One important advantage of type-assignment (TA) systems is that
in TA language, one can ask (and answer) questions of a kind
that cannot be expressed at all in typed-term language.

For example (1) "If we assumed that this part of a term X has a
certain type, what type would the whole of X have?"
Also the question mentioned in Albert's note: (2) "Is a given
term, for example S(KK)K, an erasure of a typed one?

It is this extra expressive power that makes TA-systems
interesting; they are, roughly speaking, like Meta-Languages
for languages of typed terms.  (cf. Milner's choice of name
"ML".)


By the way, the Hindley-Milner typing algorithm mentioned in
Albert's note has a long history;

   Curry used it informally in the 1950's, perhaps even 1930's,
before he wrote it up formally as an equation-solving procedure
in 1967 (published 1969).  Curry's algorithm includes a unific-
ation algorithm.
   The algorithm of Hindley, dating from 1967, depends on
Robinson's unification algorithm.
   The Milner algorithm depends on Robinson too.
   J.H. Morris gave an equation-solving algorithm in his thesis
at MIT (1968, but presumably devised some time before then);
it includes a unification algorithm in the same way Curry's does.
   Carew Meredith, working in propositional logics, used a
Hindley-like algorithm in the 1950's; by the formulas-as-types
correspondence, this is a principal-type-scheme algorithm,
in today's language.
   Tarski had used, it is rumoured, a p.t.s. or unification
algorithm in early work in the 1920's.

There must be a moral to this story of continual re-discovery;
perhaps someone along the line should have learned to read.
Or someone else learn to write.










},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGUuLi8uLi9QYXBlcnMvSGluZGxleS9IaW5kbGV5IC0gVGhlIFByaW5jaXBhbCBUeXBlLVNjaGVtZSBvZiBhbiBPYmplY3QgaW4gQ29tYmluYXRvcnkgTG9naWMgKDE5NjkpLnBkZtIbDxwdV05TLmRhdGFPEQJGAAAAAAJGAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA4E8IfSGluZGxleSAtIFRoZSBQcmluY2kjMzgxM0JGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgTv8Q20TRQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAB0hpbmRsZXkAABAACAAAwTR+XQAAABEACAAAxDcJdAAAAAEAEAA4E8IALZE/AANHrAAAa9gAAgBAT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkhpbmRsZXk6SGluZGxleSAtIFRoZSBQcmluY2kjMzgxM0JGLnBkZgAOAKIAUABIAGkAbgBkAGwAZQB5ACAALQAgAFQAaABlACAAUAByAGkAbgBjAGkAcABhAGwAIABUAHkAcABlAC0AUwBjAGgAZQBtAGUAIABvAGYAIABhAG4AIABPAGIAagBlAGMAdAAgAGkAbgAgAEMAbwBtAGIAaQBuAGEAdABvAHIAeQAgAEwAbwBnAGkAYwAgACgAMQA5ADYAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGxVc2Vycy9qZXJlbXkvUGFwZXJzL0hpbmRsZXkvSGluZGxleSAtIFRoZSBQcmluY2lwYWwgVHlwZS1TY2hlbWUgb2YgYW4gT2JqZWN0IGluIENvbWJpbmF0b3J5IExvZ2ljICgxOTY5KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBEgEXAR8DaQNrA3ADeQOEA4gDlgOdA6YDqwOuAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA7s=},
	Bdsk-Url-1 = {http://www.jstor.org/stable/1995158}}

@incollection{Gordon:From:2000,
	Author = {Gordon, Michael J. C.},
	Booktitle = {Proof, Language, and Interaction: {E}ssays in Honour of Robin Milner},
	Chapter = {6},
	Date-Added = {2008-04-24 23:35:15 -0400},
	Date-Modified = {2008-04-24 23:42:22 -0400},
	Editor = {G. Plotkin and Colin P. Stirling and Mads Tofte},
	Isbn = {978-0262161886},
	Note = {A version is available from the author at \url{http://www.cl.cam.ac.uk/~mjcg/papers/HolHistory.html}},
	Pages = {169--186},
	Publisher = {MIT Press},
	Series = {Foundations of Computing},
	Title = {From {LCF} to {HOL}: {A} Short History},
	Url = {http://www.cl.cam.ac.uk/~mjcg/papers/HolHistory.html},
	Year = {2000},
	Abstract = {The original LCF system was a proof-checking program developed at Stanford University by Robin Milner in 1972. Descendents of LCF now form a thriving paradigm in computer assisted reasoning. Many of the developments of the last 25 years have been due to Robin Milner, whose influence on the field of automated reasoning has been diverse and profound. One of the descendents of LCF is HOL, a proof assistant for higher order logic originally developed for reasoning about hardware. The multi-faceted contribution of Robin Milner to the development of HOL is remarkable. Not only did he invent the LCF-approach to theorem proving, but he also designed the ML programming language underlying it and the innovative polymorphic type system used both by ML and the LCF and HOL logics. Code Milner wrote is still in use today, and the design of the hardware verification system LCF_LSM (a now obsolete stepping stone from LCF to HOL) was inspired by Milner's Calculus of Communicating Systems (CCS).},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEguLi8uLi9QYXBlcnMvR29yZG9uL0dvcmRvbiAtIEZyb20gTENGIHRvIEhPTDogQSBTaG9ydCBIaXN0b3J5ICgyMDAwKS5wZGbSGw8cHVdOUy5kYXRhTxEB8AAAAAAB8AACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAOBJaH0dvcmRvbiAtIEZyb20gTENGIHRvIzM4MTI1MS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ElHENstpAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZHb3Jkb24AEAAIAADBNH5dAAAAEQAIAADENwOpAAAAAQAQADgSWgAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6R29yZG9uOkdvcmRvbiAtIEZyb20gTENGIHRvIzM4MTI1MS5wZGYAAA4AagA0AEcAbwByAGQAbwBuACAALQAgAEYAcgBvAG0AIABMAEMARgAgAHQAbwAgAEgATwBMAC8AIABBACAAUwBoAG8AcgB0ACAASABpAHMAdABvAHIAeQAgACgAMgAwADAAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAE9Vc2Vycy9qZXJlbXkvUGFwZXJzL0dvcmRvbi9Hb3Jkb24gLSBGcm9tIExDRiB0byBIT0w6IEEgU2hvcnQgSGlzdG9yeSAoMjAwMCkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD1APoBAgL2AvgC/QMGAxEDFQMjAyoDMwM4AzsAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADSA==},
	Bdsk-Url-1 = {http://www.cl.cam.ac.uk/~mjcg/papers/HolHistory.html}}

@misc{Cousineau:A-brief:1996,
	Author = {Guy Cousineau},
	Date-Added = {2008-04-24 22:54:15 -0400},
	Date-Modified = {2008-04-25 03:41:54 -0400},
	Howpublished = {Manuscript, available online},
	Title = {A brief history of Caml (as I remember it)},
	Url = {http://www.pps.jussieu.fr/~cousinea/Caml/caml_history.html},
	Urldate = {24 Apr 2008},
	Year = {1996},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFguLi8uLi9QYXBlcnMvQ291c2luZWF1L0NvdXNpbmVhdSAtIEEgYnJpZWYgaGlzdG9yeSBvZiBDYW1sIChhcyBJIHJlbWVtYmVyIGl0KSAoMTk5NikucGRm0hsPHB1XTlMuZGF0YU8RAiAAAAAAAiAAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADgSJh9Db3VzaW5lYXUgLSBBIGJyaWVmICMzODEyMjUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOBIlxDbJngAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAJQ291c2luZWF1AAAQAAgAAME0fl0AAAARAAgAAMQ3Ad4AAAABABAAOBImAC2RPwADR6wAAGvYAAIAQk9kaW46VXNlcnM6amVyZW15OlBhcGVyczpDb3VzaW5lYXU6Q291c2luZWF1IC0gQSBicmllZiAjMzgxMjI1LnBkZgAOAIQAQQBDAG8AdQBzAGkAbgBlAGEAdQAgAC0AIABBACAAYgByAGkAZQBmACAAaABpAHMAdABvAHIAeQAgAG8AZgAgAEMAYQBtAGwAIAAoAGEAcwAgAEkAIAByAGUAbQBlAG0AYgBlAHIAIABpAHQAKQAgACgAMQA5ADkANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF9Vc2Vycy9qZXJlbXkvUGFwZXJzL0NvdXNpbmVhdS9Db3VzaW5lYXUgLSBBIGJyaWVmIGhpc3Rvcnkgb2YgQ2FtbCAoYXMgSSByZW1lbWJlciBpdCkgKDE5OTYpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBBQEKARIDNgM4Az0DRgNRA1UDYwNqA3MDeAN7AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA4g=},
	Bdsk-Url-1 = {http://www.pps.jussieu.fr/~cousinea/Caml/caml_history.html}}

@misc{Peyton-Jones:Wearing:2003,
	Author = {Peyton Jones, Simon},
	Date-Added = {2008-04-24 16:04:20 -0400},
	Date-Modified = {2008-04-24 18:21:51 -0400},
	Howpublished = {Published online},
	Keywords = {history of computing},
	Note = {Invited talk at POPL 2003 (no paper in published proceedings)},
	Title = {Wearing the hair shirt: {A} retrospective on {H}askell},
	Url = {http://research.microsoft.com/~simonpj/papers/haskell-retrospective/index.htm},
	Year = {2003},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGYuLi8uLi9QYXBlcnMvUGV5dG9uIEpvbmVzL1BleXRvbiBKb25lcyAtIFdlYXJpbmcgdGhlIGhhaXIgc2hpcnQ6IEEgcmV0cm9zcGVjdGl2ZSBvbiBIYXNrZWxsICgyMDAzKS5wZGbSGw8cHVdOUy5kYXRhTxECSgAAAAACSgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZF6H1BleXRvbiBKb25lcyAtIFdlYXJpIzI5Rjg3OS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp+HkAAAAAAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAxQZXl0b24gSm9uZXMAEAAIAADBNH5dAAAAEQAIAAAAAAAAAAAAAQAQAC2RegAtkT8AA0esAABr2AACAEVPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6UGV5dG9uIEpvbmVzOlBleXRvbiBKb25lcyAtIFdlYXJpIzI5Rjg3OS5wZGYAAA4AmgBMAFAAZQB5AHQAbwBuACAASgBvAG4AZQBzACAALQAgAFcAZQBhAHIAaQBuAGcAIAB0AGgAZQAgAGgAYQBpAHIAIABzAGgAaQByAHQALwAgAEEAIAByAGUAdAByAG8AcwBwAGUAYwB0AGkAdgBlACAAbwBuACAASABhAHMAawBlAGwAbAAgACgAMgAwADAAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG1Vc2Vycy9qZXJlbXkvUGFwZXJzL1BleXRvbiBKb25lcy9QZXl0b24gSm9uZXMgLSBXZWFyaW5nIHRoZSBoYWlyIHNoaXJ0OiBBIHJldHJvc3BlY3RpdmUgb24gSGFza2VsbCAoMjAwMykucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgETARgBIANuA3ADdQN+A4kDjQObA6IDqwOwA7MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADwA==},
	Bdsk-File-2 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGYuLi8uLi9QYXBlcnMvUGV5dG9uIEpvbmVzL1BleXRvbiBKb25lcyAtIFdlYXJpbmcgdGhlIGhhaXIgc2hpcnQ6IEEgcmV0cm9zcGVjdGl2ZSBvbiBIYXNrZWxsICgyMDAzKS5wcHTSGw8cHVdOUy5kYXRhTxECSgAAAAACSgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZF6H1BleXRvbiBKb25lcyAtIFdlYXJpIzI5Rjg3QS5wcHQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp+HoAAAAAAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAxQZXl0b24gSm9uZXMAEAAIAADBNH5dAAAAEQAIAAAAAAAAAAAAAQAQAC2RegAtkT8AA0esAABr2AACAEVPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6UGV5dG9uIEpvbmVzOlBleXRvbiBKb25lcyAtIFdlYXJpIzI5Rjg3QS5wcHQAAA4AmgBMAFAAZQB5AHQAbwBuACAASgBvAG4AZQBzACAALQAgAFcAZQBhAHIAaQBuAGcAIAB0AGgAZQAgAGgAYQBpAHIAIABzAGgAaQByAHQALwAgAEEAIAByAGUAdAByAG8AcwBwAGUAYwB0AGkAdgBlACAAbwBuACAASABhAHMAawBlAGwAbAAgACgAMgAwADAAMwApAC4AcABwAHQADwAKAAQATwBkAGkAbgASAG1Vc2Vycy9qZXJlbXkvUGFwZXJzL1BleXRvbiBKb25lcy9QZXl0b24gSm9uZXMgLSBXZWFyaW5nIHRoZSBoYWlyIHNoaXJ0OiBBIHJldHJvc3BlY3RpdmUgb24gSGFza2VsbCAoMjAwMykucHB0AAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgETARgBIANuA3ADdQN+A4kDjQObA6IDqwOwA7MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADwA==},
	Bdsk-Url-1 = {http://research.microsoft.com/~simonpj/papers/haskell-retrospective/index.htm}}

@book{Alagic:Relational:1986,
	Address = {New York},
	Author = {Suad Alagi{\'{c}}},
	Date-Added = {2008-04-22 16:26:17 -0400},
	Date-Modified = {2008-04-22 16:27:09 -0400},
	Publisher = {Springer-Verlag},
	Series = {Texts and Monographs in Computer Science},
	Title = {Relational Database Technology},
	Year = {1986}}

@article{Hyland:Discrete:2006,
	Author = {Hyland, Martin and Power, John},
	Date-Added = {2008-04-21 14:43:02 -0400},
	Date-Modified = {2008-04-21 14:43:02 -0400},
	Journal = {Theoretical Computer Science},
	Keywords = {Countable Lawvere V-theory; Discrete countable Lawvere V-theory; Model; Sum; Tensor; Distributive tensor; Image},
	Number = {1-2},
	Pages = {144--162},
	Title = {Discrete Lawvere theories and computational effects},
	Title1 = {Algebra and Coalgebra in Computer Science},
	Ty = {JOUR},
	Url = {http://www.sciencedirect.com/science/article/B6V1G-4KFMCJW-7/1/ce2fab15b3d0de544d97b0510bc7ffa7},
	Volume = {366},
	Year = {2006},
	Abstract = { Countable Lawvere theories model computational effects such as exceptions, side-effects, interactive input/output, nondeterminism and probabilistic nondeterminism. The category of countable Lawvere theories has sums, tensors, and distributive tensors, modelling natural combinations of such effects. It is also closed under taking images. Enrichment in a category such as [omega]Cpo allows one to extend this modelling of computational effects to account for partiality and recursion. Sum and tensor extend to enriched countable Lawvere theories, but distributive tensor and image do not. So here we introduce discrete countable enriched Lawvere theories in order to allow natural definitions and accounts of distributive tensor and image. A discrete countable enriched Lawvere theory is, in a sense we make precise, an enriched Lawvere theory with discrete arities. We show that they include all our leading examples of computational effects and are closed under sum and tensor. And we develop notions of enriched operad and enriched multicategory to support the definition.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGEuLi8uLi9QYXBlcnMvSHlsYW5kL0h5bGFuZC1Qb3dlciAtIERpc2NyZXRlIExhd3ZlcmUgdGhlb3JpZXMgYW5kIGNvbXB1dGF0aW9uYWwgZWZmZWN0cyAoMjAwNikucGRm0hsPHB1XTlMuZGF0YU8RAjoAAAAAAjoAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADfHYR9IeWxhbmQtUG93ZXIgLSBEaXNjciMzN0M4NUIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN8hbxDJWS1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGSHlsYW5kABAACAAAwTR+XQAAABEACAAAxDKOiwAAAAEAEAA3x2EALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkh5bGFuZDpIeWxhbmQtUG93ZXIgLSBEaXNjciMzN0M4NUIucGRmAAAOAJwATQBIAHkAbABhAG4AZAAtAFAAbwB3AGUAcgAgAC0AIABEAGkAcwBjAHIAZQB0AGUAIABMAGEAdwB2AGUAcgBlACAAdABoAGUAbwByAGkAZQBzACAAYQBuAGQAIABjAG8AbQBwAHUAdABhAHQAaQBvAG4AYQBsACAAZQBmAGYAZQBjAHQAcwAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGhVc2Vycy9qZXJlbXkvUGFwZXJzL0h5bGFuZC9IeWxhbmQtUG93ZXIgLSBEaXNjcmV0ZSBMYXd2ZXJlIHRoZW9yaWVzIGFuZCBjb21wdXRhdGlvbmFsIGVmZmVjdHMgKDIwMDYpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEOARMBGwNZA1sDYANpA3QDeAOGA40DlgObA54AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqw==},
	Bdsk-Url-1 = {http://www.sciencedirect.com/science/article/B6V1G-4KFMCJW-7/1/ce2fab15b3d0de544d97b0510bc7ffa7}}

@article{Power:Countable:2006,
	Author = {Power, John},
	Date-Added = {2008-04-21 14:34:26 -0400},
	Date-Modified = {2008-04-21 14:34:29 -0400},
	Journal = {Electronic Notes in Theoretical Computer Science},
	Keywords = {mathematical operational semantics; modularity; timed transition systems; comonads; distributive laws},
	Pages = {59--71},
	Title = {Countable Lawvere Theories and Computational Effects},
	Title1 = {Proceedings of the Third Irish Conference on the Mathematical Foundations of Computer Science and Information Technology (MFCSIT 2004)},
	Ty = {JOUR},
	Url = {http://www.sciencedirect.com/science/article/B75H1-4KSH4B1-5/1/6859653c6c503a3630df85afc56ca8ec},
	Volume = {161},
	Year = {2006},
	Abstract = { Lawvere theories have been one of the two main category theoretic formulations of universal algebra, the other being monads. Monads have appeared extensively over the past fifteen years in the theoretical computer science literature, specifically in connection with computational effects, but Lawvere theories have not. So we define the notion of (countable) Lawvere theory and give a precise statement of its relationship with the notion of monad on the category Set. We illustrate with examples arising from the study of computational effects, explaining how the notion of Lawvere theory keeps one closer to computational practice. We then describe constructions that one can make with Lawvere theories, notably sum, tensor, and distributive tensor, reflecting the ways in which the various computational effects are usually combined, thus giving denotational semantics for the combinations.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFouLi8uLi9QYXBlcnMvUG93ZXIvUG93ZXIgLSBDb3VudGFibGUgTGF3dmVyZSBUaGVvcmllcyBhbmQgQ29tcHV0YXRpb25hbCBFZmZlY3RzICgyMDA2KS5wZGbSGw8cHVdOUy5kYXRhTxECJgAAAAACJgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAN8hhH1Bvd2VyIC0gQ291bnRhYmxlIExhIzM3Qzg0QS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3yErEMlYhUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVQb3dlcgAAEAAIAADBNH5dAAAAEQAIAADEMo5hAAAAAQAQADfIYQAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6UG93ZXI6UG93ZXIgLSBDb3VudGFibGUgTGEjMzdDODRBLnBkZgAOAJAARwBQAG8AdwBlAHIAIAAtACAAQwBvAHUAbgB0AGEAYgBsAGUAIABMAGEAdwB2AGUAcgBlACAAVABoAGUAbwByAGkAZQBzACAAYQBuAGQAIABDAG8AbQBwAHUAdABhAHQAaQBvAG4AYQBsACAARQBmAGYAZQBjAHQAcwAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGFVc2Vycy9qZXJlbXkvUGFwZXJzL1Bvd2VyL1Bvd2VyIC0gQ291bnRhYmxlIExhd3ZlcmUgVGhlb3JpZXMgYW5kIENvbXB1dGF0aW9uYWwgRWZmZWN0cyAoMjAwNikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEHAQwBFAM+A0ADRQNOA1kDXQNrA3IDewOAA4MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkA==},
	Bdsk-Url-1 = {http://www.sciencedirect.com/science/article/B75H1-4KSH4B1-5/1/6859653c6c503a3630df85afc56ca8ec}}

@article{Hyland:Combining:2007,
	Author = {Hyland, Martin and Levy, Paul Blain and Plotkin, Gordon and Power, John},
	Date-Added = {2008-04-21 14:26:02 -0400},
	Date-Modified = {2008-04-21 14:29:01 -0400},
	Journal = {Theoretical Computer Science},
	Keywords = {Computational effect; Lawvere theory; Modularity; Monad},
	Number = {1-3},
	Pages = {20--40},
	Title = {Combining algebraic effects with continuations},
	Title1 = {Festschrift for John C. Reynolds's 70th birthday},
	Ty = {JOUR},
	Url = {http://www.sciencedirect.com/science/article/B6V1G-4MPC46J-B/1/5d2e147eedc458c52654c30f35e474b7},
	Volume = {375},
	Year = {2007},
	Abstract = { We consider the natural combinations of algebraic computational effects such as side-effects, exceptions, interactive input/output, and nondeterminism with continuations. Continuations are not an algebraic effect, but previously developed combinations of algebraic effects given by sum and tensor extend, with effort, to include commonly used combinations of the various algebraic effects with continuations. Continuations also give rise to a third sort of combination, that given by applying the continuations monad transformer to an algebraic effect. We investigate the extent to which sum and tensor extend from algebraic effects to arbitrary monads, and the extent to which Felleisen et~al.'s operator extends from continuations to its combination with algebraic effects. To do all this, we use Dubuc's characterisation of strong monads in terms of enriched large Lawvere theories.},
	Bdsk-Url-1 = {http://www.sciencedirect.com/science/article/B6V1G-4MPC46J-B/1/5d2e147eedc458c52654c30f35e474b7}}

@article{Hyland:Combining:2006,
	Author = {Hyland, Martin and Plotkin, Gordon and Power, John},
	Date-Added = {2008-04-21 14:25:26 -0400},
	Date-Modified = {2008-04-21 14:25:28 -0400},
	Journal = {Theoretical Computer Science},
	Keywords = {Computational effect; Lawvere theory; Modularity; Monad},
	Number = {1-3},
	Pages = {70--99},
	Title = {Combining effects: Sum and tensor},
	Title1 = {Clifford Lectures and the Mathematical Foundations of Programming Semantics},
	Ty = {JOUR},
	Url = {http://www.sciencedirect.com/science/article/B6V1G-4JRKGWN-3/1/774fedfc2638f6cd203450c78089bdcf},
	Volume = {357},
	Year = {2006},
	Abstract = { We seek a unified account of modularity for computational effects. We begin by reformulating Moggi's monadic paradigm for modelling computational effects using the notion of enriched Lawvere theory, together with its relationship with strong monads; this emphasises the importance of the operations that produce the effects. Effects qua theories are then combined by appropriate bifunctors on the category of theories. We give a theory for the sum of computational effects, which in particular yields Moggi's exceptions monad transformer and an interactive input/output monad transformer. We further give a theory of the commutative combination of effects, their tensor, which yields Moggi's side-effects monad transformer. Finally, we give a theory of operation transformers, for redefining operations when adding new effects; we derive explicit forms for the operation transformers associated to the above monad transformers.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFcuLi8uLi9QYXBlcnMvSHlsYW5kL0h5bGFuZC1QbG90a2luLVBvd2VyIC0gQ29tYmluaW5nIGVmZmVjdHM6IFN1bSBhbmQgdGVuc29yICgyMDA2KS5wZGbSGw8cHVdOUy5kYXRhTxECHAAAAAACHAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAN8dhH0h5bGFuZC1QbG90a2luLVBvd2VyIzM3QzgxMi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3yBLEMlTxUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZIeWxhbmQAEAAIAADBNH5dAAAAEQAIAADEMo0xAAAAAQAQADfHYQAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6SHlsYW5kOkh5bGFuZC1QbG90a2luLVBvd2VyIzM3QzgxMi5wZGYAAA4AiABDAEgAeQBsAGEAbgBkAC0AUABsAG8AdABrAGkAbgAtAFAAbwB3AGUAcgAgAC0AIABDAG8AbQBiAGkAbgBpAG4AZwAgAGUAZgBmAGUAYwB0AHMALwAgAFMAdQBtACAAYQBuAGQAIAB0AGUAbgBzAG8AcgAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF5Vc2Vycy9qZXJlbXkvUGFwZXJzL0h5bGFuZC9IeWxhbmQtUGxvdGtpbi1Qb3dlciAtIENvbWJpbmluZyBlZmZlY3RzOiBTdW0gYW5kIHRlbnNvciAoMjAwNikucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQQBCQERAzEDMwM4A0EDTANQA14DZQNuA3MDdgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOD},
	Bdsk-Url-1 = {http://www.sciencedirect.com/science/article/B6V1G-4JRKGWN-3/1/774fedfc2638f6cd203450c78089bdcf}}

@article{Ghani:Monadic:2005,
	Address = {New York, NY, USA},
	Author = {Neil Ghani and Patricia Johann and Tarmo Uustalu and Varmo Vene},
	Date-Added = {2008-04-21 14:19:42 -0400},
	Date-Modified = {2008-04-21 14:19:45 -0400},
	Doi = {http://doi.acm.org/10.1145/1090189.1086403},
	Homepage = {http://www.cs.nott.ac.uk/~nxg/},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {9},
	Pages = {294--305},
	Publisher = {ACM},
	Title = {Monadic augment and generalised short cut fusion},
	Volume = {40},
	Year = {2005},
	Abstract = {Monads are commonplace programming devices that are used to uniformly structure computations with effects such as state, exceptions, and I/O. This paper further develops the monadic programming paradigm by investigating the extent to which monadic computations can be optimised by using generalisations of short cut fusion to eliminate monadic structures whose sole purpose is to "glue together" monadic program components.We make several contributions. First, we show that every inductive type has an associated build combinator and an associated short cut fusion rule. Second, we introduce the notion of an \textit{inductive monad} to describe those monads that give rise to inductive types, and we give examples of such monads which are widely used in functional programming. Third, we generalise the standard augment combinators and cata/augment fusion rules for algebraic data types to types induced by inductive monads. This allows us to give the first cata/augment rules for some common data types, such as rose trees. Fourth, we demonstrate the practical applicability of our generalisations by providing Haskell implementations for all concepts and examples in the paper. Finally, we offer deep theoretical insights by showing that the augment combinators are monadic in nature, and thus that our cata/build and cata/augment rules are arguably the best generally applicable fusion rules obtainable.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGUuLi8uLi9QYXBlcnMvR2hhbmkvR2hhbmktSm9oYW5uLVV1c3RhbHUgLSBNb25hZGljIGF1Z21lbnQgYW5kIGdlbmVyYWxpc2VkIHNob3J0IGN1dCBmdXNpb24gKDIwMDUpLnBkZtIbDxwdV05TLmRhdGFPEQJGAAAAAAJGAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA3xz8fR2hhbmktSm9oYW5uLVV1c3RhbHUjMzdDNUM2LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADfFxsQyUbhQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABUdoYW5pAAAQAAgAAME0fl0AAAARAAgAAMQyifgAAAABABAAN8c/AC2RPwADR6wAAGvYAAIAPk9kaW46VXNlcnM6amVyZW15OlBhcGVyczpHaGFuaTpHaGFuaS1Kb2hhbm4tVXVzdGFsdSMzN0M1QzYucGRmAA4ApgBSAEcAaABhAG4AaQAtAEoAbwBoAGEAbgBuAC0AVQB1AHMAdABhAGwAdQAgAC0AIABNAG8AbgBhAGQAaQBjACAAYQB1AGcAbQBlAG4AdAAgAGEAbgBkACAAZwBlAG4AZQByAGEAbABpAHMAZQBkACAAcwBoAG8AcgB0ACAAYwB1AHQAIABmAHUAcwBpAG8AbgAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGxVc2Vycy9qZXJlbXkvUGFwZXJzL0doYW5pL0doYW5pLUpvaGFubi1VdXN0YWx1IC0gTW9uYWRpYyBhdWdtZW50IGFuZCBnZW5lcmFsaXNlZCBzaG9ydCBjdXQgZnVzaW9uICgyMDA1KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBEgEXAR8DaQNrA3ADeQOEA4gDlgOdA6YDqwOuAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA7s=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1090189.1086403}}

@article{Ghani:Monadic:2007,
	Address = {New York, NY, USA},
	Author = {Neil Ghani and Patricia Johann},
	Date-Added = {2008-04-21 14:19:42 -0400},
	Date-Modified = {2008-04-21 14:19:45 -0400},
	Doi = {http://dx.doi.org/10.1017/S0956796807006314},
	Homepage = {http://www.cs.nott.ac.uk/~nxg/},
	Issn = {0956-7968},
	Journal = {J. Funct. Program.},
	Number = {6},
	Pages = {731--776},
	Publisher = {Cambridge University Press},
	Title = {Monadic augment and generalised short cut fusion},
	Volume = {17},
	Year = {2007},
	Abstract = {Monads are commonplace programming devices that are used to uniformly structure computations; in particular, they are often used to mimic the effects of impure features such as state, error handling, and I/O. This paper further develops the monadic programming paradigm by investigating the extent to which monadic computations can be optimised by using generalisations of short cut fusion to eliminate monadic structures whose sole purpose is to glue together monadic program components. Ghani, Uustalu, and Vene have recently shown that every inductive type has an associated build combinator and an associated short cut fusion law. They have also used the notion of a \textit{parameterised monad} to describe those monads that give rise to inductive types, and have shown that the standard augment combinators and cata/augment fusion rules for algebraic data types can be generalised to fixed points of all parameterised monads. We revisit these augment combinators and generalised short cut fusion rules for such types but consider them from a functional programming perspective, rather than a categorical one. In addition to making the category-theoretic ideas of Ghani, Uustalu, and Vene more easily accessible to a wider audience of functional programmers, we demonstrate their practical applicability by developing nontrivial application programs and performing modest benchmarking on them. We also show how the cata/augment rules can serve as the basis for deriving additional generic fusion laws, thus opening the way for an \textit{algebra of fusion.} Finally, we offer deep theoretical insights, arguing that the augment combinators are monadic in nature, and thus that the cata/build and cata/augment rules are arguably the best generally applicable fusion rules obtainable.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEF0uLi8uLi9QYXBlcnMvR2hhbmkvR2hhbmktSm9oYW5uIC0gTW9uYWRpYyBhdWdtZW50IGFuZCBnZW5lcmFsaXNlZCBzaG9ydCBjdXQgZnVzaW9uICgyMDA3KS5wZGbSGw8cHVdOUy5kYXRhTxECLgAAAAACLgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAN8c/H0doYW5pLUpvaGFubiAtIE1vbmFkIzM3QzVFQS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3xerEMlI4AAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVHaGFuaQAAEAAIAADBNH5dAAAAEQAIAADEMop4AAAAAQAQADfHPwAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6R2hhbmk6R2hhbmktSm9oYW5uIC0gTW9uYWQjMzdDNUVBLnBkZgAOAJYASgBHAGgAYQBuAGkALQBKAG8AaABhAG4AbgAgAC0AIABNAG8AbgBhAGQAaQBjACAAYQB1AGcAbQBlAG4AdAAgAGEAbgBkACAAZwBlAG4AZQByAGEAbABpAHMAZQBkACAAcwBoAG8AcgB0ACAAYwB1AHQAIABmAHUAcwBpAG8AbgAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGRVc2Vycy9qZXJlbXkvUGFwZXJzL0doYW5pL0doYW5pLUpvaGFubiAtIE1vbmFkaWMgYXVnbWVudCBhbmQgZ2VuZXJhbGlzZWQgc2hvcnQgY3V0IGZ1c2lvbiAoMjAwNykucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQoBDwEXA0kDSwNQA1kDZANoA3YDfQOGA4sDjgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOb},
	Bdsk-Url-1 = {http://dx.doi.org/10.1017/S0956796807006314}}

@article{Paterson:A-new-notation:2001,
	Address = {New York, NY, USA},
	Author = {Ross Paterson},
	Date-Added = {2008-04-21 14:19:42 -0400},
	Date-Modified = {2008-04-21 14:19:45 -0400},
	Doi = {http://doi.acm.org/10.1145/507546.507664},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {10},
	Pages = {229--240},
	Publisher = {ACM},
	Title = {A new notation for arrows},
	Volume = {36},
	Year = {2001},
	Abstract = {The categorical notion of monad, used by Moggi to structure denotational descriptions, has proved to be a powerful tool for structuring combinator libraries. Moreover, the monadic programming style provides a convenient syntax for many kinds of computation, so that each library defines a new sublanguage. Recently, several workers have proposed a generalization of monads, called variously "arrows" or Freyd-categories. The extra generality promises to increase the power, expressiveness and efficiency of the embedded approach, but does not mesh as well with the native abstraction and application. Definitions are typically given in a point-free style, which is useful for proving general properties, but can be awkward for programming specific instances. In this paper we define a simple extension to the functional language Haskell that makes these new notions of computation more convenient to use. Our language is similar to the monadic style, and has similar reasoning properties. Moreover, it is extensible, in the sense that new combining forms can be defined as expressions in the host language.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEUuLi8uLi9QYXBlcnMvUGF0ZXJzb24vUGF0ZXJzb24gLSBBIG5ldyBub3RhdGlvbiBmb3IgYXJyb3dzICgyMDAxKS5wZGbSGw8cHVdOUy5kYXRhTxEB5gAAAAAB5gACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAN8a6H1BhdGVyc29uIC0gQSBuZXcgbm90IzM3QzVDQy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3xczEMlHUUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAhQYXRlcnNvbgAQAAgAAME0fl0AAAARAAgAAMQyihQAAAABABAAN8a6AC2RPwADR6wAAGvYAAIAQU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpQYXRlcnNvbjpQYXRlcnNvbiAtIEEgbmV3IG5vdCMzN0M1Q0MucGRmAAAOAGAALwBQAGEAdABlAHIAcwBvAG4AIAAtACAAQQAgAG4AZQB3ACAAbgBvAHQAYQB0AGkAbwBuACAAZgBvAHIAIABhAHIAcgBvAHcAcwAgACgAMgAwADAAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAExVc2Vycy9qZXJlbXkvUGFwZXJzL1BhdGVyc29uL1BhdGVyc29uIC0gQSBuZXcgbm90YXRpb24gZm9yIGFycm93cyAoMjAwMSkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPIA9wD/AukC6wLwAvkDBAMIAxYDHQMmAysDLgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAM7},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/507546.507664}}

@article{Hyland:The-Category:2007,
	Address = {Amsterdam, The Netherlands, The Netherlands},
	Author = {Martin Hyland and John Power},
	Date-Added = {2008-04-21 14:19:42 -0400},
	Date-Modified = {2008-04-21 14:19:45 -0400},
	Doi = {http://dx.doi.org/10.1016/j.entcs.2007.02.019},
	Issn = {1571-0661},
	Journal = {Electron. Notes Theor. Comput. Sci.},
	Pages = {437--458},
	Publisher = {Elsevier Science Publishers B. V.},
	Title = {The Category Theoretic Understanding of Universal Algebra: Lawvere Theories and Monads},
	Volume = {172},
	Year = {2007},
	Abstract = {Lawvere theories and monads have been the two main category theoretic formulations of universal algebra, Lawvere theories arising in 1963 and the connection with monads being established a few years later. Monads, although mathematically the less direct and less malleable formulation, rapidly gained precedence. A generation later, the definition of monad began to appear extensively in theoretical computer science in order to model computational effects, without reference to universal algebra. But since then, the relevance of universal algebra to computational effects has been recognised, leading to renewed prominence of the notion of Lawvere theory, now in a computational setting. This development has formed a major part of Gordon Plotkin's mature work, and we study its history here, in particular asking why Lawvere theories were eclipsed by monads in the 1960's, and how the renewed interest in them in a computer science setting might develop in future.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGguLi8uLi9QYXBlcnMvSHlsYW5kL0h5bGFuZC1Qb3dlciAtIFRoZSBDYXRlZ29yeSBUaGVvcmV0aWMgVW5kZXJzdGFuZGluZyBvZiBVbml2ZXJzYWwgQWxnZWJyYTogKDIwMDcpLnBkZtIbDxwdV05TLmRhdGFPEQJQAAAAAAJQAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA3x2EfSHlsYW5kLVBvd2VyIC0gVGhlIEMjMzdDNzVGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADfHX8QyU/tQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABkh5bGFuZAAQAAgAAME0fl0AAAARAAgAAMQyjDsAAAABABAAN8dhAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpIeWxhbmQ6SHlsYW5kLVBvd2VyIC0gVGhlIEMjMzdDNzVGLnBkZgAADgCqAFQASAB5AGwAYQBuAGQALQBQAG8AdwBlAHIAIAAtACAAVABoAGUAIABDAGEAdABlAGcAbwByAHkAIABUAGgAZQBvAHIAZQB0AGkAYwAgAFUAbgBkAGUAcgBzAHQAYQBuAGQAaQBuAGcAIABvAGYAIABVAG4AaQB2AGUAcgBzAGEAbAAgAEEAbABnAGUAYgByAGEALwAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG9Vc2Vycy9qZXJlbXkvUGFwZXJzL0h5bGFuZC9IeWxhbmQtUG93ZXIgLSBUaGUgQ2F0ZWdvcnkgVGhlb3JldGljIFVuZGVyc3RhbmRpbmcgb2YgVW5pdmVyc2FsIEFsZ2VicmE6ICgyMDA3KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARUBGgEiA3YDeAN9A4YDkQOVA6MDqgOzA7gDuwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAPI},
	Bdsk-Url-1 = {http://dx.doi.org/10.1016/j.entcs.2007.02.019}}

@article{Moggi:Notions:1991,
	Address = {Duluth, MN, USA},
	Author = {Eugenio Moggi},
	Date-Added = {2008-04-21 13:29:36 -0400},
	Date-Modified = {2008-04-21 13:30:03 -0400},
	Doi = {http://dx.doi.org/10.1016/0890-5401(91)90052-4},
	Issn = {0890-5401},
	Journal = {Inf. Comput.},
	Number = {1},
	Pages = {55--92},
	Publisher = {Academic Press, Inc.},
	Title = {Notions of computation and monads},
	Url = {http://www.disi.unige.it/person/MoggiE/publications.html},
	Volume = {93},
	Year = {1991},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEcuLi8uLi9QYXBlcnMvTW9nZ2kvTW9nZ2kgLSBOb3Rpb25zIG9mIGNvbXB1dGF0aW9uIGFuZCBtb25hZHMgKDE5OTEpLnBkZtIbDxwdV05TLmRhdGFPEQHsAAAAAAHsAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA3xPQfTW9nZ2kgLSBOb3Rpb25zIG9mIGMjMkQyMjI5LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC0iKcOHAWlQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABU1vZ2dpAAAQAAgAAME0fl0AAAARAAgAAMOHR7kAAAABABAAN8T0AC2RPwADR6wAAGvYAAIAPk9kaW46VXNlcnM6amVyZW15OlBhcGVyczpNb2dnaTpNb2dnaSAtIE5vdGlvbnMgb2YgYyMyRDIyMjkucGRmAA4AagA0AE0AbwBnAGcAaQAgAC0AIABOAG8AdABpAG8AbgBzACAAbwBmACAAYwBvAG0AcAB1AHQAYQB0AGkAbwBuACAAYQBuAGQAIABtAG8AbgBhAGQAcwAgACgAMQA5ADkAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAE5Vc2Vycy9qZXJlbXkvUGFwZXJzL01vZ2dpL01vZ2dpIC0gTm90aW9ucyBvZiBjb21wdXRhdGlvbiBhbmQgbW9uYWRzICgxOTkxKS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA9AD5AQEC8QLzAvgDAQMMAxADHgMlAy4DMwM2AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA0M=},
	Bdsk-Url-1 = {http://dx.doi.org/10.1016/0890-5401(91)90052-4},
	Bdsk-Url-2 = {http://www.disi.unige.it/person/MoggiE/publications.html}}

@inproceedings{Moggi:Computational:1989,
	Address = {Piscataway, NJ, USA},
	Author = {E. Moggi},
	Booktitle = {Proceedings of the Fourth Annual Symposium on Logic in computer science},
	Date-Added = {2008-04-21 13:20:59 -0400},
	Date-Modified = {2008-04-21 13:26:48 -0400},
	Isbn = {0-8186-1954-6},
	Location = {Pacific Grove, California, United States},
	Pages = {14--23},
	Publisher = {IEEE Press},
	Title = {Computational lambda-calculus and monads},
	Url = {http://www.disi.unige.it/person/MoggiE/publications.html},
	Year = {5--8 Jun 1989},
	Abstract = {The $\lambda$-calculus is considered a useful mathematical tool in the study of programming languages. However, if one uses $\beta\eta$-conversion to prove equivalence of programs, then a gross simplification is introduced. The author gives a calculus based on a categorical semantics for computations, which provides a correct basis for proving equivalence of programs, independent from any specific computational model.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEsuLi8uLi9QYXBlcnMvTW9nZ2kvTW9nZ2kgLSBDb21wdXRhdGlvbmFsIGxhbWJkYS1jYWxjdWx1cyBhbmQgbW9uYWRzICg1KS5wZGbSGw8cHVdOUy5kYXRhTxEB+AAAAAAB+AACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAN8T0H01vZ2dpIC0gQ29tcHV0YXRpb25hIzM3QzRGMi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3xPLEMkXcUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVNb2dnaQAAEAAIAADBNH5dAAAAEQAIAADEMn4cAAAAAQAQADfE9AAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6TW9nZ2k6TW9nZ2kgLSBDb21wdXRhdGlvbmEjMzdDNEYyLnBkZgAOAHIAOABNAG8AZwBnAGkAIAAtACAAQwBvAG0AcAB1AHQAYQB0AGkAbwBuAGEAbAAgAGwAYQBtAGIAZABhAC0AYwBhAGwAYwB1AGwAdQBzACAAYQBuAGQAIABtAG8AbgBhAGQAcwAgACgANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFJVc2Vycy9qZXJlbXkvUGFwZXJzL01vZ2dpL01vZ2dpIC0gQ29tcHV0YXRpb25hbCBsYW1iZGEtY2FsY3VsdXMgYW5kIG1vbmFkcyAoNSkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPgA/QEFAwEDAwMIAxEDHAMgAy4DNQM+A0MDRgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANT},
	Bdsk-File-2 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEwuLi8uLi9QYXBlcnMvTW9nZ2kvTW9nZ2kgLSBDb21wdXRhdGlvbmFsIGxhbWJkYS1jYWxjdWx1cyBhbmQgbW9uYWRzICg1YSkucGRm0hsPHB1XTlMuZGF0YU8RAfwAAAAAAfwAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADfE9B9Nb2dnaSAtIENvbXB1dGF0aW9uYSMzN0M0RkMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN8T8xDJGQ1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAFTW9nZ2kAABAACAAAwTR+XQAAABEACAAAxDJ+gwAAAAEAEAA3xPQALZE/AANHrAAAa9gAAgA+T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOk1vZ2dpOk1vZ2dpIC0gQ29tcHV0YXRpb25hIzM3QzRGQy5wZGYADgB0ADkATQBvAGcAZwBpACAALQAgAEMAbwBtAHAAdQB0AGEAdABpAG8AbgBhAGwAIABsAGEAbQBiAGQAYQAtAGMAYQBsAGMAdQBsAHUAcwAgAGEAbgBkACAAbQBvAG4AYQBkAHMAIAAoADUAYQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFNVc2Vycy9qZXJlbXkvUGFwZXJzL01vZ2dpL01vZ2dpIC0gQ29tcHV0YXRpb25hbCBsYW1iZGEtY2FsY3VsdXMgYW5kIG1vbmFkcyAoNWEpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA+QD+AQYDBgMIAw0DFgMhAyUDMwM6A0MDSANLAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA1g=},
	Bdsk-Url-1 = {http://www.disi.unige.it/person/MoggiE/publications.html}}

@inproceedings{Belohlavek:Codds:2006,
	Address = {Washington, DC, USA},
	Author = {Radim Belohlavek and Vilem Vychodil},
	Booktitle = {CIMCA '06: Proceedings of the International Conference on Computational Inteligence for Modelling Control and Automation and International Conference on Intelligent Agents Web Technologies and International Commerce},
	Date-Added = {2008-04-21 13:07:11 -0400},
	Date-Modified = {2008-04-21 13:08:35 -0400},
	Doi = {http://dx.doi.org/10.1109/CIMCA.2006.68},
	Isbn = {0-7695-2731-0},
	Pages = {70},
	Publisher = {IEEE Computer Society},
	Title = {Codd's Relational Model of Data and Fuzzy Logic: Comparisons, Observations, and Some New Results},
	Year = {2006},
	Abstract = {The present paper deals with Codd's relational model of data. In particular, we deal with fuzzy logic extensions of the relational model. Our main purpose is to examine relationships between some of the models which have been proposed in the literature. We concentrate on functional dependencies which is the most studied part of the relational model within fuzzy logic extensions. In addition to the observations on relationships between fuzzy logic extensions of the relational model, our paper brings up several new technical results.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGIuLi8uLi9QYXBlcnMvQmVsb2hsYXZlay9CZWxvaGxhdmVrLVZ5Y2hvZGlsIC0gQ29kZCdzIFJlbGF0aW9uYWwgTW9kZWwgb2YgRGF0YSBhbmQgRnV6enkgKDIwMDYpLnBkZtIbDxwdV05TLmRhdGFPEQI+AAAAAAI+AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA3xKIfQmVsb2hsYXZlay1WeWNob2RpbCAjMzdDNEExLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADfEocQyQzpQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAACkJlbG9obGF2ZWsAEAAIAADBNH5dAAAAEQAIAADEMnt6AAAAAQAQADfEogAtkT8AA0esAABr2AACAENPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QmVsb2hsYXZlazpCZWxvaGxhdmVrLVZ5Y2hvZGlsICMzN0M0QTEucGRmAAAOAJYASgBCAGUAbABvAGgAbABhAHYAZQBrAC0AVgB5AGMAaABvAGQAaQBsACAALQAgAEMAbwBkAGQAJwBzACAAUgBlAGwAYQB0AGkAbwBuAGEAbAAgAE0AbwBkAGUAbAAgAG8AZgAgAEQAYQB0AGEAIABhAG4AZAAgAEYAdQB6AHoAeQAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGlVc2Vycy9qZXJlbXkvUGFwZXJzL0JlbG9obGF2ZWsvQmVsb2hsYXZlay1WeWNob2RpbCAtIENvZGQncyBSZWxhdGlvbmFsIE1vZGVsIG9mIERhdGEgYW5kIEZ1enp5ICgyMDA2KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQ8BFAEcA14DYANlA24DeQN9A4sDkgObA6ADowAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOw},
	Bdsk-Url-1 = {http://dx.doi.org/10.1109/CIMCA.2006.68}}

@article{Date:A-formal:1982,
	Address = {New York, NY, USA},
	Author = {C. J. Date},
	Date-Added = {2008-04-21 13:06:38 -0400},
	Date-Modified = {2008-04-21 13:08:02 -0400},
	Doi = {http://doi.acm.org/10.1145/984514.984515},
	Issn = {0163-5808},
	Journal = {SIGMOD Rec.},
	Number = {1},
	Pages = {18--29},
	Publisher = {ACM},
	Title = {A formal definition of the relational model},
	Volume = {13},
	Year = {1982},
	Abstract = {The relational model of data, originally introduced by Codd in [1], has three components: (1) a set of objects (relations, domains, etc.); (2) a set of operators (union, project, etc.); (3) a set of general integrity rules. The purpose of this paper is to provide a formal definition of each of these three components.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE8uLi8uLi9QYXBlcnMvRGF0ZS9EYXRlIC0gQSBmb3JtYWwgZGVmaW5pdGlvbiBvZiB0aGUgcmVsYXRpb25hbCBtb2RlbCAoMTk4MikucGRm0hsPHB1XTlMuZGF0YU8RAgQAAAAAAgQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADfExB9EYXRlIC0gQSBmb3JtYWwgZGVmaSMzN0M0QzEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN8TBxDJEH1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAERGF0ZQAQAAgAAME0fl0AAAARAAgAAMQyfF8AAAABABAAN8TEAC2RPwADR6wAAGvYAAIAPU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpEYXRlOkRhdGUgLSBBIGZvcm1hbCBkZWZpIzM3QzRDMS5wZGYAAA4AfAA9AEQAYQB0AGUAIAAtACAAQQAgAGYAbwByAG0AYQBsACAAZABlAGYAaQBuAGkAdABpAG8AbgAgAG8AZgAgAHQAaABlACAAcgBlAGwAYQB0AGkAbwBuAGEAbAAgAG0AbwBkAGUAbAAgACgAMQA5ADgAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFZVc2Vycy9qZXJlbXkvUGFwZXJzL0RhdGUvRGF0ZSAtIEEgZm9ybWFsIGRlZmluaXRpb24gb2YgdGhlIHJlbGF0aW9uYWwgbW9kZWwgKDE5ODIpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD8AQEBCQMRAxMDGAMhAywDMAM+A0UDTgNTA1YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADYw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/984514.984515}}

@article{Codd:A-relational:1970,
	Address = {New York, NY, USA},
	Author = {E. F. Codd},
	Date-Added = {2008-04-21 13:06:22 -0400},
	Date-Modified = {2008-04-21 13:07:41 -0400},
	Doi = {http://doi.acm.org/10.1145/362384.362685},
	Issn = {0001-0782},
	Journal = {Commun. ACM},
	Number = {6},
	Pages = {377--387},
	Publisher = {ACM},
	Title = {A relational model of data for large shared data banks},
	Volume = {13},
	Year = {1970},
	Abstract = { Future users of large data banks must be protected from having to know how the data is organized in the machine (the internal representation). A prompting service which supplies such information is not a satisfactory solution. Activities of users at terminals and most application programs should remain unaffected when the internal representation of data is changed and even when some aspects of the external representation are changed. Changes in data representation will often be needed as a result of changes in query, update, and report traffic and natural growth in the types of stored information. Existing noninferential, formatted data systems provide users with tree-structured files or slightly more general network models of the data. In Section 1, inadequacies of these models are discussed. A model based on n-ary relations, a normal form for data base relations, and the concept of a universal data sublanguage are introduced. In Section 2, certain operations on relations (other than logical inference) are discussed and applied to the problems of redundancy and consistency in the user's model.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE8uLi8uLi9QYXBlcnMvQ29kZC9Db2RkIC0gQSByZWxhdGlvbmFsIG1vZGVsIG9mIGRhdGEgZm9yIGxhcmdlIHNoYXJlZCAoMTk3MCkucGRm0hsPHB1XTlMuZGF0YU8RAgQAAAAAAgQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADfEwx9Db2RkIC0gQSByZWxhdGlvbmFsICMzN0M0QTkucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN8SpxDJDdFBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAEQ29kZAAQAAgAAME0fl0AAAARAAgAAMQye7QAAAABABAAN8TDAC2RPwADR6wAAGvYAAIAPU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpDb2RkOkNvZGQgLSBBIHJlbGF0aW9uYWwgIzM3QzRBOS5wZGYAAA4AfAA9AEMAbwBkAGQAIAAtACAAQQAgAHIAZQBsAGEAdABpAG8AbgBhAGwAIABtAG8AZABlAGwAIABvAGYAIABkAGEAdABhACAAZgBvAHIAIABsAGEAcgBnAGUAIABzAGgAYQByAGUAZAAgACgAMQA5ADcAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFZVc2Vycy9qZXJlbXkvUGFwZXJzL0NvZGQvQ29kZCAtIEEgcmVsYXRpb25hbCBtb2RlbCBvZiBkYXRhIGZvciBsYXJnZSBzaGFyZWQgKDE5NzApLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD8AQEBCQMRAxMDGAMhAywDMAM+A0UDTgNTA1YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADYw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/362384.362685}}

@article{Cohen:A-view:1988,
	Address = {New York, NY, USA},
	Author = {Jacques Cohen},
	Date-Added = {2008-04-21 06:59:03 -0400},
	Date-Modified = {2008-04-21 07:00:10 -0400},
	Doi = {http://doi.acm.org/10.1145/35043.35045},
	Issn = {0001-0782},
	Journal = {Commun. ACM},
	Number = {1},
	Pages = {26--36},
	Publisher = {ACM},
	Title = {A view of the origins and development of Prolog},
	Volume = {31},
	Year = {1988},
	Abstract = {This paper explores the origins of Prolog based on the views rising mainly from the language processing perspective. With this intent we first describe the related research efforts and their significant computer literature in the mid-1960s. We then show that those existing circumstances would very naturally lead to the development of a language like Prolog.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFUuLi8uLi9QYXBlcnMvQ29oZW4vQ29oZW4gLSBBIHZpZXcgb2YgdGhlIG9yaWdpbnMgYW5kIGRldmVsb3BtZW50IG9mIFByb2xvZyAoMTk4OCkucGRm0hsPHB1XTlMuZGF0YU8RAhYAAAAAAhYAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADfDGx9Db2hlbiAtIEEgdmlldyBvZiB0aCMzN0FFNzgucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN654xDGm11BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAFQ29oZW4AABAACAAAwTR+XQAAABEACAAAxDHfFwAAAAEAEAA3wxsALZE/AANHrAAAa9gAAgA+T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkNvaGVuOkNvaGVuIC0gQSB2aWV3IG9mIHRoIzM3QUU3OC5wZGYADgCGAEIAQwBvAGgAZQBuACAALQAgAEEAIAB2AGkAZQB3ACAAbwBmACAAdABoAGUAIABvAHIAaQBnAGkAbgBzACAAYQBuAGQAIABkAGUAdgBlAGwAbwBwAG0AZQBuAHQAIABvAGYAIABQAHIAbwBsAG8AZwAgACgAMQA5ADgAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFxVc2Vycy9qZXJlbXkvUGFwZXJzL0NvaGVuL0NvaGVuIC0gQSB2aWV3IG9mIHRoZSBvcmlnaW5zIGFuZCBkZXZlbG9wbWVudCBvZiBQcm9sb2cgKDE5ODgpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgECAQcBDwMpAysDMAM5A0QDSANWA10DZgNrA24AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADew==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/35043.35045}}

@article{Landin:The-next:1966,
	Address = {New York, NY, USA},
	Author = {P. J. Landin},
	Date-Added = {2008-04-21 06:55:37 -0400},
	Date-Modified = {2008-04-21 06:56:36 -0400},
	Doi = {http://doi.acm.org/10.1145/365230.365257},
	Issn = {0001-0782},
	Journal = {Commun. ACM},
	Number = {3},
	Pages = {157--166},
	Publisher = {ACM},
	Title = {The next 700 programming languages},
	Volume = {9},
	Year = {1966},
	Abstract = {A family of unimplemented computing languages is described that is intended to span differences of application area by a unified framework. This framework dictates the rules about the uses of user-coined names, and the conventions about characterizing functional relationships. Within this framework the design of a specific language splits into two independent parts. One is the choice of written appearances of programs (or more generally, their physical representation). The other is the choice of the abstract entities (such as numbers, character-strings, list of them, functional relations among them) that can be referred to in the language. The system is biased towards "expressions" rather than "statements." It includes a nonprocedural (purely functional) subsystem that aims to expand the class of users' needs that can be met by a single print-instruction, without sacrificing the important properties that make conventional right-hand-side expressions easy to construct and understand.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEouLi8uLi9QYXBlcnMvTGFuZGluL0xhbmRpbiAtIFRoZSBuZXh0IDcwMCBwcm9ncmFtbWluZyBsYW5ndWFnZXMgKDE5NjYpLnBkZtIbDxwdV05TLmRhdGFPEQH2AAAAAAH2AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA3wv4fTGFuZGluIC0gVGhlIG5leHQgNzAjMzdDMkZCLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADfC+8Qx60NQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABkxhbmRpbgAQAAgAAME0fl0AAAARAAgAAMQyI4MAAAABABAAN8L+AC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpMYW5kaW46TGFuZGluIC0gVGhlIG5leHQgNzAjMzdDMkZCLnBkZgAADgBuADYATABhAG4AZABpAG4AIAAtACAAVABoAGUAIABuAGUAeAB0ACAANwAwADAAIABwAHIAbwBnAHIAYQBtAG0AaQBuAGcAIABsAGEAbgBnAHUAYQBnAGUAcwAgACgAMQA5ADYANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFFVc2Vycy9qZXJlbXkvUGFwZXJzL0xhbmRpbi9MYW5kaW4gLSBUaGUgbmV4dCA3MDAgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzICgxOTY2KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPcA/AEEAv4DAAMFAw4DGQMdAysDMgM7A0ADQwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANQ},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/365230.365257}}

@book{Iverson:A-programming:1962,
	Address = {New York, NY, USA},
	Author = {Kenneth E. Iverson},
	Date-Added = {2008-04-21 06:53:58 -0400},
	Date-Modified = {2008-04-21 06:54:00 -0400},
	Isbn = {0-471430-14-5},
	Publisher = {John Wiley \& Sons, Inc.},
	Source = {Library of Congress Catalog Card Number: 62-15180},
	Title = {A programming language},
	Year = {1962}}

@incollection{Hodges:Did-Church:2006,
	Author = {Andrew Hodges},
	Booktitle = {Church's {T}hesis after 70 Years},
	Date-Added = {2008-04-19 02:26:53 -0400},
	Date-Modified = {2008-04-21 01:37:03 -0400},
	Editor = {Adam Olszewski and Jan Wole{'n}ski and Robert Janusz},
	Isbn = {3-938793-09-0},
	Keywords = {history of computing},
	Location = {Berlin},
	Publisher = {ontos verlag},
	Series = {Mathematical Logic},
	Title = {Did {C}hurch and {T}uring have a thesis about machines?},
	Url = {http://www.turing.org.uk/publications/ct70.html},
	Volume = {1},
	Year = {2006},
	Abstract = {This article draws attention to a central dispute in the interpretation of Church's Thesis. More precisely, we are concerned with the Church--Turing thesis, as it emerged in 1936 when Church endorsed Turing's characterization of the concept of effective calculability. (The article by Sieg in this volume details this history. It is valuable also to note from Krajewski, also in this volume, that the word 'thesis' was used only in 1952.) This controversy has a \textit{scientic} aspect, concerning the nature of the physical world and what can be done with it. It has a \textit{historical} aspect, to do with the 'confluence of ideas in 1936'. We shall focus on the historical question, but it is the continuing and serious scientific question that lends potency to the history.},
	Annote = {The publisher itself, both in English and German, insists on spelling its name in all lowercase, and so we have followed suit.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFEuLi8uLi9QYXBlcnMvSG9kZ2VzL0hvZGdlcyAtIERpZCBDaHVyY2ggYW5kIFR1cmluZyBoYXZlIGEgdGhlc2lzIGFib3V0ICgyMDA2KS5wZGbSGw8cHVdOUy5kYXRhTxECCgAAAAACCgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAN3MZH0hvZGdlcyAtIERpZCBDaHVyY2ggIzM3NzJDNS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3csXELwdmAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZIb2RnZXMAEAAIAADBNH5dAAAAEQAIAADELz+mAAAAAQAQADdzGQAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6SG9kZ2VzOkhvZGdlcyAtIERpZCBDaHVyY2ggIzM3NzJDNS5wZGYAAA4AfAA9AEgAbwBkAGcAZQBzACAALQAgAEQAaQBkACAAQwBoAHUAcgBjAGgAIABhAG4AZAAgAFQAdQByAGkAbgBnACAAaABhAHYAZQAgAGEAIAB0AGgAZQBzAGkAcwAgAGEAYgBvAHUAdAAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFhVc2Vycy9qZXJlbXkvUGFwZXJzL0hvZGdlcy9Ib2RnZXMgLSBEaWQgQ2h1cmNoIGFuZCBUdXJpbmcgaGF2ZSBhIHRoZXNpcyBhYm91dCAoMjAwNikucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAP4BAwELAxkDGwMgAykDNAM4A0YDTQNWA1sDXgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANr},
	Bdsk-Url-1 = {http://www.turing.org.uk/publications/ct70.html}}

@book{Olszewski:Churchs:2006,
	Date-Added = {2008-04-19 02:08:21 -0400},
	Date-Modified = {2008-04-19 02:20:41 -0400},
	Editor = {Adam Olszewski and Jan Wole{'n}ski and Robert Janusz},
	Isbn = {3-938793-09-0},
	Location = {Berlin},
	Publisher = {ontos verlag},
	Series = {Mathematical Logic},
	Title = {Church's Thesis after 70 Years},
	Url = {http://www.ontos-verlag.de/Buchreihen-ML-Olszewski.php},
	Volume = {1},
	Year = {2006},
	Abstract = {Church's Thesis was first published by Alonzo Church in 1935. The thesis is a proposition that identifies two notions: an intuitive notion of an effectively computable function defined in natural numbers with the notion of a recursive function. Despite many efforts by prominent scientists, Church's Thesis has never been falsified. There exists a vast literature concerning the thesis. The aim of this book is to provide a one-volume summary of the state of research on Church's Thesis. These include the following:  different formulations of the thesis, Church's Thesis and intuitionism, Church's Thesis and intensional mathematics, Church's Thesis and physics, the epistemic status of the thesis, Church's Thesis and philosophy of mind, provability of Church's thesis and Church's thesis and functional programming.},
	Annote = {The publisher itself, both in English and German, insists on spelling its name in all lowercase, and so we have followed suit.},
	Bdsk-Url-1 = {http://www.ontos-verlag.de/Buchreihen-ML-Olszewski.php}}

@misc{Schwartzbach:Polymorphic:1995,
	Author = {Schwartzbach, Michael I.},
	Date-Added = {2008-04-18 12:56:38 -0400},
	Date-Modified = {2008-04-18 12:57:08 -0400},
	Homepage = {http://www.daimi.au.dk/~mis/},
	Howpublished = {Lecture notes, published online},
	Month = {March},
	Note = {Also given as an invited lecture in June 1995 as BRICS LS-95-3.},
	Title = {Polymorphic type inference},
	Year = {1995},
	Abstract = {We will present a tiny functional language and

  gradually enrich its type system. We shall cover the basic Curry-Hindley
  system and Wand's constraint-based algorithm for monomorphic type inference;
  briefly observe the Curry-Howard isomorphism and notice that logical

  formalism may serve as the inspiration for new type rules; present the
  polymorphic Milner system and the Damas-Milner algorithm for polymorphic type
  inference; see the Milner-Mycroft system for polymorphic recursion; and

  sketch the development of higher type systems. We will touch upon the
  relationship between types and logic and show how rules from logic may give
  inspiration for new type rules. En route we shall encounter the curious

  discovery that two algorithmic problems for type systems, which have been
  implemented in popular programming languages, have turned out to be
  respectively complete for exponential time and undecidable.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE4uLi8uLi9QYXBlcnMvU2Nod2FydHpiYWNoL1NjaHdhcnR6YmFjaCAtIFBvbHltb3JwaGljIHR5cGUgaW5mZXJlbmNlICgxOTk1KS5wZGbSGw8cHVdOUy5kYXRhTxECAgAAAAACAgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAANoFOH1NjaHdhcnR6YmFjaCAtIFBvbHltIzM2ODE0Ny5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2gUfELks/UERGIHBydncAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAxTY2h3YXJ0emJhY2gAEAAIAADBNH5dAAAAEQAIAADELoN/AAAAAQAQADaBTgAtkT8AA0esAABr2AACAEVPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6U2Nod2FydHpiYWNoOlNjaHdhcnR6YmFjaCAtIFBvbHltIzM2ODE0Ny5wZGYAAA4AagA0AFMAYwBoAHcAYQByAHQAegBiAGEAYwBoACAALQAgAFAAbwBsAHkAbQBvAHIAcABoAGkAYwAgAHQAeQBwAGUAIABpAG4AZgBlAHIAZQBuAGMAZQAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFVVc2Vycy9qZXJlbXkvUGFwZXJzL1NjaHdhcnR6YmFjaC9TY2h3YXJ0emJhY2ggLSBQb2x5bW9ycGhpYyB0eXBlIGluZmVyZW5jZSAoMTk5NSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD7AQABCAMOAxADFQMeAykDLQM7A0IDSwNQA1MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADYA==}}

@book{Felleisen:How:2003,
	Author = {Felleisen, Matthias and Findler, Robert Bruce and Flatt, Matthew and Krishnamurthi, Shriram},
	Date-Added = {2008-04-18 12:56:38 -0400},
	Date-Modified = {2008-04-18 12:58:47 -0400},
	Month = {Sept},
	Note = {Published online at \url{http://www.htdp.org/}},
	Publisher = {MIT Press},
	Title = {How to Design Programs},
	Url = {http://www.htdp.org/},
	Year = {2003},
	Bdsk-Url-1 = {http://www.htdp.org/}}

@incollection{Turner:Church:2006,
	Author = {David Turner},
	Booktitle = {Church's Thesis after 70 Years},
	Date-Added = {2008-04-18 12:56:38 -0400},
	Date-Modified = {2008-04-19 02:23:18 -0400},
	Editor = {Olszewski, A.},
	Location = {Berlin},
	Pages = {518--544},
	Publisher = {ontos verlag},
	Title = {Church's Thesis and Functional Programming},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGAuLi8uLi9QYXBlcnMvVHVybmVyL1R1cm5lciAtIENodXJjaCdzIFRoZXNpcyBhbmQgRnVuY3Rpb25hbCBQcm9ncmFtbWluZyAocHAgNTE4LS01NDQpICgyMDA2KS5wZGbSGw8cHVdOUy5kYXRhTxECOAAAAAACOAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAANoFUH1R1cm5lciAtIENodXJjaCdzIFRoIzM2ODExQy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2gRzELh9uAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZUdXJuZXIAEAAIAADBNH5dAAAAEQAIAADELleuAAAAAQAQADaBVAAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6VHVybmVyOlR1cm5lciAtIENodXJjaCdzIFRoIzM2ODExQy5wZGYAAA4AmgBMAFQAdQByAG4AZQByACAALQAgAEMAaAB1AHIAYwBoACcAcwAgAFQAaABlAHMAaQBzACAAYQBuAGQAIABGAHUAbgBjAHQAaQBvAG4AYQBsACAAUAByAG8AZwByAGEAbQBtAGkAbgBnACAAKABwAHAAIAA1ADEAOAAtAC0ANQA0ADQAKQAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGdVc2Vycy9qZXJlbXkvUGFwZXJzL1R1cm5lci9UdXJuZXIgLSBDaHVyY2gncyBUaGVzaXMgYW5kIEZ1bmN0aW9uYWwgUHJvZ3JhbW1pbmcgKHBwIDUxOC0tNTQ0KSAoMjAwNikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgENARIBGgNWA1gDXQNmA3EDdQODA4oDkwOYA5sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqA==}}

@inproceedings{Meijer:Functional:1991,
	Address = {New York, NY, USA},
	Author = {Erik Meijer and Maarten Fokkinga and Ross Paterson},
	Booktitle = {Proceedings of the 5th ACM conference on Functional programming languages and computer architecture},
	Date-Added = {2008-04-18 12:52:53 -0400},
	Date-Modified = {2008-04-18 12:54:04 -0400},
	Isbn = {0-387-54396-1},
	Location = {Cambridge, Massachusetts, United States},
	Pages = {124--144},
	Publisher = {Springer-Verlag New York, Inc.},
	Title = {Functional programming with bananas, lenses, envelopes and barbed wire},
	Year = {1991},
	Abstract = {We develop a calculus for lazy functional programming based on recursion operators associated with data type definitions. For these operators we derive various algebraic laws that are useful in deriving and manipulating programs. We shall show that all example functions in Bird and Wadler's "Introduction to Functional Programming" can be expressed using these operators.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGYuLi8uLi9QYXBlcnMvTWVpamVyL01laWplci1Gb2traW5nYS1QYXRlcnNvbiAtIEZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgd2l0aCBiYW5hbmFzLCBsZW5zZXMsICgxOTkxKS5wZGbSGw8cHVdOUy5kYXRhTxECSgAAAAACSgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAANoEgH01laWplci1Gb2traW5nYS1QYXRlIzM2ODExQS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2gRrELh9qAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZNZWlqZXIAEAAIAADBNH5dAAAAEQAIAADELleqAAAAAQAQADaBIAAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6TWVpamVyOk1laWplci1Gb2traW5nYS1QYXRlIzM2ODExQS5wZGYAAA4ApgBSAE0AZQBpAGoAZQByAC0ARgBvAGsAawBpAG4AZwBhAC0AUABhAHQAZQByAHMAbwBuACAALQAgAEYAdQBuAGMAdABpAG8AbgBhAGwAIABwAHIAbwBnAHIAYQBtAG0AaQBuAGcAIAB3AGkAdABoACAAYgBhAG4AYQBuAGEAcwAsACAAbABlAG4AcwBlAHMALAAgACgAMQA5ADkAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG1Vc2Vycy9qZXJlbXkvUGFwZXJzL01laWplci9NZWlqZXItRm9ra2luZ2EtUGF0ZXJzb24gLSBGdW5jdGlvbmFsIHByb2dyYW1taW5nIHdpdGggYmFuYW5hcywgbGVuc2VzLCAoMTk5MSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgETARgBIANuA3ADdQN+A4kDjQObA6IDqwOwA7MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADwA==}}

@article{Hutton:A-tutorial:1999,
	Address = {New York, NY, USA},
	Author = {Graham Hutton},
	Date-Added = {2008-04-18 12:52:53 -0400},
	Date-Modified = {2008-04-18 12:54:04 -0400},
	Doi = {http://dx.doi.org/10.1017/S0956796899003500},
	Issn = {0956-7968},
	Journal = {J. Funct. Program.},
	Number = {4},
	Pages = {355--372},
	Publisher = {Cambridge University Press},
	Title = {A tutorial on the universality and expressiveness of fold},
	Volume = {9},
	Year = {1999},
	Abstract = {

In functional programming, \textit{fold} is a standard operator that encapsulates a simple pattern of recursion for processing lists. This article is a tutorial on two key aspects of the fold operator for lists. First of all, we emphasize the use of the \textit{universal property} of fold both as a \textit{proof principle} that avoids the need for inductive proofs, and as a \textit{definition principle} that guides the transformation of recursive functions into definitions using fold. Secondly, we show that even though the pattern of recursion encapsulated by fold is simple, in a language with tuples and functions as first-class values the fold operator has greater \textit{expressive power} than might first be expected.

},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGEuLi8uLi9QYXBlcnMvSHV0dG9uL0h1dHRvbiAtIEEgdHV0b3JpYWwgb24gdGhlIHVuaXZlcnNhbGl0eSBhbmQgZXhwcmVzc2l2ZW5lc3Mgb2YgZm9sZCAoMTk5OSkucGRm0hsPHB1XTlMuZGF0YU8RAjoAAAAAAjoAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2SYB9IdXR0b24gLSBBIHR1dG9yaWFsICMzNjgxMUIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANoEbxC4fbgAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGSHV0dG9uABAACAAAwTR+XQAAABEACAAAxC5XrgAAAAEAEAAtkmAALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkh1dHRvbjpIdXR0b24gLSBBIHR1dG9yaWFsICMzNjgxMUIucGRmAAAOAJwATQBIAHUAdAB0AG8AbgAgAC0AIABBACAAdAB1AHQAbwByAGkAYQBsACAAbwBuACAAdABoAGUAIAB1AG4AaQB2AGUAcgBzAGEAbABpAHQAeQAgAGEAbgBkACAAZQB4AHAAcgBlAHMAcwBpAHYAZQBuAGUAcwBzACAAbwBmACAAZgBvAGwAZAAgACgAMQA5ADkAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGhVc2Vycy9qZXJlbXkvUGFwZXJzL0h1dHRvbi9IdXR0b24gLSBBIHR1dG9yaWFsIG9uIHRoZSB1bml2ZXJzYWxpdHkgYW5kIGV4cHJlc3NpdmVuZXNzIG9mIGZvbGQgKDE5OTkpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEOARMBGwNZA1sDYANpA3QDeAOGA40DlgObA54AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqw==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1017/S0956796899003500}}

@misc{Altenkirch:Why-Dependent:2005,
	Author = {Thorsten Altenkirch and Conor McBride and James McKinna},
	Date-Added = {2008-04-16 22:12:18 -0400},
	Date-Modified = {2008-04-16 22:13:42 -0400},
	Howpublished = {Manuscript, available online},
	Keywords = {manuscript},
	Month = {April},
	Title = {Why Dependent Types Matter},
	Year = {2005},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFouLi8uLi9QYXBlcnMvQWx0ZW5raXJjaC9BbHRlbmtpcmNoLU1jQnJpZGUtTWNLaW5uYSAtIFdoeSBEZXBlbmRlbnQgVHlwZXMgTWF0dGVyICgyMDA1KS5wZGbSGw8cHVdOUy5kYXRhTxECJgAAAAACJgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAMfYoH0FsdGVua2lyY2gtTWNCcmlkZS1NIzMxRjYwMC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAx9gDELCl/UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAApBbHRlbmtpcmNoABAACAAAwTR+XQAAABEACAAAxCxhvwAAAAEAEAAx9igALZE/AANHrAAAa9gAAgBDT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkFsdGVua2lyY2g6QWx0ZW5raXJjaC1NY0JyaWRlLU0jMzFGNjAwLnBkZgAADgCGAEIAQQBsAHQAZQBuAGsAaQByAGMAaAAtAE0AYwBCAHIAaQBkAGUALQBNAGMASwBpAG4AbgBhACAALQAgAFcAaAB5ACAARABlAHAAZQBuAGQAZQBuAHQAIABUAHkAcABlAHMAIABNAGEAdAB0AGUAcgAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGFVc2Vycy9qZXJlbXkvUGFwZXJzL0FsdGVua2lyY2gvQWx0ZW5raXJjaC1NY0JyaWRlLU1jS2lubmEgLSBXaHkgRGVwZW5kZW50IFR5cGVzIE1hdHRlciAoMjAwNSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEHAQwBFAM+A0ADRQNOA1kDXQNrA3IDewOAA4MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkA==}}

@article{McKinna:Why-dependent:2006,
	Address = {New York, NY, USA},
	Author = {James McKinna},
	Date-Added = {2008-04-16 22:09:54 -0400},
	Date-Modified = {2008-04-16 22:10:12 -0400},
	Doi = {http://doi.acm.org/10.1145/1111320.1111038},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {1},
	Pages = {1--1},
	Publisher = {ACM},
	Title = {Why dependent types matter},
	Volume = {41},
	Year = {2006},
	Abstract = {Language designers have in recent years proposed a wealth of richer type systems for programming which seek to extend the range of statically enforced guarantees on data and code. Most such proposals have been evolutionary extensions of ML or Haskell, offering programmers a balanced compromise between expressive strength and existing well-understood technology. Typically they revolve around type- or kind-indexed types such as GADTs, supported by limited equality reasoning at the type-checking level, thus separating the dynamic behaviour of programs from the (simpler) static behaviour of indexing information occurring in their types.I want to argue in this talk for a more radical departure from such practice by examining full spectrum type dependency, lifting such restrictions on the data upon which types may depend. Conor McBride and I designed the language EPIGRAM for experiments in programming with inductive families of data (of which GADTs are a special case). Using it for illustration, I will explore some of the possibilities and challenges afforded by full spectrum type dependency at the static and dynamic level:
\begin{itemize}
\item types directly support modelling complex invariants in terms of other data (rather than their types), with a Curry-Howard flavour of data-as-evidence; such complexity is on a 'pay-as-you-go' basis, while keeping type annotations and other syntactic overheads to a minimum;
\item data decomposition steps, e.g. case analysis, furnish more informative interactions between types and values during typechecking; such steps may moreover be abstractly specified by their types, and thus user definable; this supports a style of programming embracing 'learning by testing', views, and Burstall's 'hand simulation plus a little induction';
\item the absence of a rigid phase distinction need not lead to type-passing or excessive run-time overhead; effectful computation, in particular partiality, can be incorporated via variations on existing ideas such as monads.
\end{itemize}
This talk is based on joint work with Conor McBride, Edwin Brady and Thorsten Altenkirch.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEQuLi8uLi9QYXBlcnMvTWNLaW5uYS9NY0tpbm5hIC0gV2h5IGRlcGVuZGVudCB0eXBlcyBtYXR0ZXIgKDIwMDYpLnBkZtIbDxwdV05TLmRhdGFPEQHkAAAAAAHkAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAx9hwfTWNLaW5uYSAtIFdoeSBkZXBlbmQjMzFGNjFCLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADH2G8QsKiNQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAB01jS2lubmEAABAACAAAwTR+XQAAABEACAAAxCxiYwAAAAEAEAAx9hwALZE/AANHrAAAa9gAAgBAT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOk1jS2lubmE6TWNLaW5uYSAtIFdoeSBkZXBlbmQjMzFGNjFCLnBkZgAOAGAALwBNAGMASwBpAG4AbgBhACAALQAgAFcAaAB5ACAAZABlAHAAZQBuAGQAZQBuAHQAIAB0AHkAcABlAHMAIABtAGEAdAB0AGUAcgAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAEtVc2Vycy9qZXJlbXkvUGFwZXJzL01jS2lubmEvTWNLaW5uYSAtIFdoeSBkZXBlbmRlbnQgdHlwZXMgbWF0dGVyICgyMDA2KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPEA9gD+AuYC6ALtAvYDAQMFAxMDGgMjAygDKwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAM4},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1111320.1111038}}

@article{McBride:The-view:2004,
	Address = {New York, NY, USA},
	Author = {Conor McBride and James McKinna},
	Date-Added = {2008-04-16 21:46:02 -0400},
	Date-Modified = {2008-04-16 21:50:29 -0400},
	Doi = {http://dx.doi.org/10.1017/S0956796803004829},
	Issn = {0956-7968},
	Journal = {J. Funct. Program.},
	Number = {1},
	Pages = {69--111},
	Publisher = {Cambridge University Press},
	Title = {The view from the left},
	Volume = {14},
	Year = {2004},
	Abstract = {Pattern matching has proved an extremely powerful and durable notion in functional programming. This paper contributes a new programming notation for type theory which elaborates the notion in various ways.

Firstly, as is by now quite well-known in the type theory community, definition by pattern matching becomes a more discriminating tool in the presence of dependent types, since it refines the explanation of types as well as values. This becomes all the more true in the presence of the rich class of datatypes known as inductive families (Dybjer, 1991).

Secondly, as proposed by Peyton Jones (1997) for Haskell, and independently rediscovered by us, subsidiary case analyses on the results of intermediate computations, which commonly take place on the right-hand side of definitions by pattern matching, should rather be handled on the left. In simply-typed languages, this subsumes the trivial case of Boolean guards; in our setting it becomes yet more powerful.

Thirdly, elementary pattern matching decompositions have a well-defined interface given by a dependent type; they correspond to the statement of an induction principle for the datatype. More general, user-definable decompositions may be defined which also have types of the same general form. Elementary pattern matching may therefore be recast in abstract form, with a semantics given by translation. Such abstract decompositions of data generalize Wadler's (1987) notion of `view'. The programmer wishing to introduce a new view of a type $\mathit{T}$, and exploit it directly in pattern matching, may do so via a standard programming idiom. The type theorist, looking through the Curry--Howard lens, may see this as proving a theorem, one which establishes the validity of a new induction principle for $\mathit{T}$.

We develop enough syntax and semantics to account for this high-level style of programming in dependent type theory. We close with the development of a typechecker for the simply-typed lambda calculus, which furnishes a view of raw terms as either being well-typed, or containing an error. The implementation of this view is \textit{ipso facto} a proof that typechecking is decidable.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEguLi8uLi9QYXBlcnMvTWNCcmlkZS9NY0JyaWRlLU1jS2lubmEgLSBUaGUgdmlldyBmcm9tIHRoZSBsZWZ0ICgyMDA0KS5wZGbSGw8cHVdOUy5kYXRhTxEB8AAAAAAB8AACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAMfWOH01jQnJpZGUtTWNLaW5uYSAtIFRoIzMxRjU4MS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAx9YHELCMpAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdNY0JyaWRlAAAQAAgAAME0fl0AAAARAAgAAMQsW2kAAAABABAAMfWOAC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpNY0JyaWRlOk1jQnJpZGUtTWNLaW5uYSAtIFRoIzMxRjU4MS5wZGYADgBoADMATQBjAEIAcgBpAGQAZQAtAE0AYwBLAGkAbgBuAGEAIAAtACAAVABoAGUAIAB2AGkAZQB3ACAAZgByAG8AbQAgAHQAaABlACAAbABlAGYAdAAgACgAMgAwADAANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAE9Vc2Vycy9qZXJlbXkvUGFwZXJzL01jQnJpZGUvTWNCcmlkZS1NY0tpbm5hIC0gVGhlIHZpZXcgZnJvbSB0aGUgbGVmdCAoMjAwNCkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD1APoBAgL2AvgC/QMGAxEDFQMjAyoDMwM4AzsAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADSA==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1017/S0956796803004829}}

@misc{McBride:The-view:2001,
	Author = {Conor McBride and James McKinna},
	Date-Added = {2008-04-16 21:45:58 -0400},
	Date-Modified = {2008-04-16 22:14:04 -0400},
	Howpublished = {Manuscript, available online},
	Keywords = {manuscript},
	Month = {Dec},
	Note = {Very different, early version of later J. Functional Programming paper. McKinna published online with note that ``we still think it worth reading as one of the only introductions to our perspective on \textit{interactive} program development.''},
	Title = {The view from the left (early draft)},
	Url = {http://www.dcs.st-and.ac.uk/~james/},
	Year = {2001},
	Abstract = {Interactive, refinement-style proof construction in type theory has several things to offer the programmer seeking to exploit languages with dependent types.

Firstly, as is by now quite well-known, definition by pattern matching becomes a more discriminating tool for problem-solving, since it refines the explanation of types as well as values. This corresponds to the instantiation of propositions in proof by induction.

Secondly, Gentzen's sequent calculus draws attention to the r\^{o}le played by cut formul\ae. Subsidiary case analyses on the results of intermediate computations, which commonly take place on the right-hand side of definitions for pattern matching, should rather be explained by `left rules'. This subsumes the trivial case of Boolean guards in simply-types languages.

Thirdly, pattern matching decompositions have a well-defined interface given by a dependent type. These are user-definable, and generalize Wadler's notion of `view' (Wadler, 1987). The programmer wishing to introduce a new view of datatype, and exploit it directly in pattern matching, may do so via a standard idiom: writing a program.

This paper introduces enough syntax and semantics to account for this high-level style of programming in dependent type theory. It culminates int he development of a type-checker for the simply-typed lambda calculus, which furnishes a view of raw terms as either being well-typed, or containing an error. The implementation of this view is a proof that typechecking is decidable.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFYuLi8uLi9QYXBlcnMvTWNCcmlkZS9NY0JyaWRlLU1jS2lubmEgLSBUaGUgdmlldyBmcm9tIHRoZSBsZWZ0IChlYXJseSBkcmFmdCkgKDIwMDApLnBkZtIbDxwdV05TLmRhdGFPEQIaAAAAAAIaAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAx9Y4fTWNCcmlkZS1NY0tpbm5hIC0gVGgjMzFGNTg3LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADH1h8QsIzYAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAB01jQnJpZGUAABAACAAAwTR+XQAAABEACAAAxCxbdgAAAAEAEAAx9Y4ALZE/AANHrAAAa9gAAgBAT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOk1jQnJpZGU6TWNCcmlkZS1NY0tpbm5hIC0gVGgjMzFGNTg3LnBkZgAOAIQAQQBNAGMAQgByAGkAZABlAC0ATQBjAEsAaQBuAG4AYQAgAC0AIABUAGgAZQAgAHYAaQBlAHcAIABmAHIAbwBtACAAdABoAGUAIABsAGUAZgB0ACAAKABlAGEAcgBsAHkAIABkAHIAYQBmAHQAKQAgACgAMgAwADAAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF1Vc2Vycy9qZXJlbXkvUGFwZXJzL01jQnJpZGUvTWNCcmlkZS1NY0tpbm5hIC0gVGhlIHZpZXcgZnJvbSB0aGUgbGVmdCAoZWFybHkgZHJhZnQpICgyMDAwKS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQMBCAEQAy4DMAM1Az4DSQNNA1sDYgNrA3ADcwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOA},
	Bdsk-Url-1 = {http://www.dcs.st-and.ac.uk/~james/}}

@inproceedings{McBride:Functional:2004,
	Address = {New York, NY, USA},
	Author = {Conor McBride and James McKinna},
	Booktitle = {Haskell '04: Proceedings of the 2004 ACM SIGPLAN workshop on Haskell},
	Date-Added = {2008-04-16 21:34:24 -0400},
	Date-Modified = {2008-04-16 21:57:47 -0400},
	Doi = {http://doi.acm.org/10.1145/1017472.1017477},
	Isbn = {1-58113-850-4},
	Location = {Snowbird, Utah, USA},
	Pages = {1--9},
	Publisher = {ACM},
	Title = {Functional Pearl: {I} am not a number -- {I} am a free variable},
	Year = {2004},
	Abstract = {In this paper, we show how to manipulate syntax with binding using a mixed representation of names for free variables (with respect to the task in hand) and de Bruijn indices [5] for bound variables. By doing so, we retain the advantages of both representations: naming supports easy, arithmetic-free manipulation of terms; de Bruijn indices eliminate the need for \alpha-conversion. Further, we have ensured that not only the user but also the \textit{implementation} need never deal with de Bruijn indices, except within key basic operations.

Moreover, we give a hierarchical representation for names which naturally reflects the structure of the operations we implement. Name choice is safe and straightforward. Our technology combines easily with an approach to syntax manipulation inspired by Huet's 'zippers'[10].

Without the ideas in this paper, we would have struggled to implement EPIGRAM [19]. Our example -- constructing inductive elimination operators for datatype families -- is but one of many where it proves invaluable.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEG0uLi8uLi9QYXBlcnMvTWNCcmlkZS9NY0JyaWRlLU1jS2lubmEgLSBGdW5jdGlvbmFsIHBlYXJsOiBJIGFtIG5vdCBhIG51bWJlciAtLSBJIGFtIGEgZnJlZSB2YXJpYWJsZSAoMjAwNCkucGRm0hsPHB1XTlMuZGF0YU8RAl4AAAAAAl4AAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADH1jh9NY0JyaWRlLU1jS2lubmEgLSBGdSMzMUY1QTAucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMfWgxCwj7lBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAHTWNCcmlkZQAAEAAIAADBNH5dAAAAEQAIAADELFwuAAAAAQAQADH1jgAtkT8AA0esAABr2AACAEBPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6TWNCcmlkZTpNY0JyaWRlLU1jS2lubmEgLSBGdSMzMUY1QTAucGRmAA4AsgBYAE0AYwBCAHIAaQBkAGUALQBNAGMASwBpAG4AbgBhACAALQAgAEYAdQBuAGMAdABpAG8AbgBhAGwAIABwAGUAYQByAGwALwAgAEkAIABhAG0AIABuAG8AdAAgAGEAIABuAHUAbQBiAGUAcgAgAC0ALQAgAEkAIABhAG0AIABhACAAZgByAGUAZQAgAHYAYQByAGkAYQBiAGwAZQAgACgAMgAwADAANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHRVc2Vycy9qZXJlbXkvUGFwZXJzL01jQnJpZGUvTWNCcmlkZS1NY0tpbm5hIC0gRnVuY3Rpb25hbCBwZWFybDogSSBhbSBub3QgYSBudW1iZXIgLS0gSSBhbSBhIGZyZWUgdmFyaWFibGUgKDIwMDQpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEaAR8BJwOJA4sDkAOZA6QDqAO2A70DxgPLA84AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAD2w==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1017472.1017477}}

@article{Barendregt:The-impact:1997,
	Author = {Barendregt, H. P.},
	Date-Added = {2008-04-14 20:34:22 -0400},
	Date-Modified = {2008-04-18 12:52:25 -0400},
	Journal = {Bull. Symbolic Logic},
	Month = {June},
	Number = {2},
	Pages = {181--215},
	Title = {The impact of the lambda calculus in logic and computer science},
	Url = {http://www.cs.ru.nl/~henk/papers.html},
	Volume = {3},
	Year = {1997},
	Abstract = {One of the most important contributions of A. Church to logic is his invention of the lambda calculus. We present the genesis of this theory and its two major areas of application: the representation of computations and the resulting functional programming languages on the one hand and the representation of reasoning and the resulting systems of computer mathematics on the other hand.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGcuLi8uLi9QYXBlcnMvQmFyZW5kcmVndC9CYXJlbmRyZWd0IC0gVGhlIGltcGFjdCBvZiB0aGUgbGFtYmRhIGNhbGN1bHVzIGluIGxvZ2ljIGFuZCBjb21wdXRlciAoMTk5NykucGRm0hsPHB1XTlMuZGF0YU8RAkwAAAAAAkwAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADGntR9CYXJlbmRyZWd0IC0gVGhlIGltcCMzMUI4OUMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMbicxClwLwAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAKQmFyZW5kcmVndAAQAAgAAME0fl0AAAARAAgAAMQpqG8AAAABABAAMae1AC2RPwADR6wAAGvYAAIAQ09kaW46VXNlcnM6amVyZW15OlBhcGVyczpCYXJlbmRyZWd0OkJhcmVuZHJlZ3QgLSBUaGUgaW1wIzMxQjg5Qy5wZGYAAA4AoABPAEIAYQByAGUAbgBkAHIAZQBnAHQAIAAtACAAVABoAGUAIABpAG0AcABhAGMAdAAgAG8AZgAgAHQAaABlACAAbABhAG0AYgBkAGEAIABjAGEAbABjAHUAbAB1AHMAIABpAG4AIABsAG8AZwBpAGMAIABhAG4AZAAgAGMAbwBtAHAAdQB0AGUAcgAgACgAMQA5ADkANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG5Vc2Vycy9qZXJlbXkvUGFwZXJzL0JhcmVuZHJlZ3QvQmFyZW5kcmVndCAtIFRoZSBpbXBhY3Qgb2YgdGhlIGxhbWJkYSBjYWxjdWx1cyBpbiBsb2dpYyBhbmQgY29tcHV0ZXIgKDE5OTcpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEUARkBIQNxA3MDeAOBA4wDkAOeA6UDrgOzA7YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADww==},
	Bdsk-Url-1 = {http://www.cs.ru.nl/~henk/papers.html}}

@book{Girard:Proofs:1989,
	Address = {New York, NY, USA},
	Author = {Jean-Yves Girard and Paul Taylor and Yves Lafont},
	Date-Added = {2008-04-14 20:18:04 -0400},
	Date-Modified = {2008-04-14 20:20:53 -0400},
	Isbn = {0-521-37181-3},
	Note = {Based on a short graduate course on typed lambda calculus given at the Universit\'e Paris VII in the autumn term of 1986--1987. Now available free of charge from the author's website},
	Pages = {176},
	Publisher = {Cambridge University Press},
	Title = {Proofs and types},
	Url = {http://www.monad.me.uk/stable/Proofs%2BTypes.html},
	Year = {1989},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEYuLi8uLi9QYXBlcnMvR2lyYXJkL0dpcmFyZC1UYXlsb3ItTGFmb250IC0gUHJvb2ZzIGFuZCB0eXBlcyAoMTk4OSkucGRm0hsPHB1XTlMuZGF0YU8RAeoAAAAAAeoAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADG4cx9HaXJhcmQtVGF5bG9yLUxhZm9udCMxNzUzQzQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF1PEwmmCuVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGR2lyYXJkABAACAAAwTR+XQAAABEACAAAwmm6+QAAAAEAEAAxuHMALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkdpcmFyZDpHaXJhcmQtVGF5bG9yLUxhZm9udCMxNzUzQzQucGRmAAAOAGYAMgBHAGkAcgBhAHIAZAAtAFQAYQB5AGwAbwByAC0ATABhAGYAbwBuAHQAIAAtACAAUAByAG8AbwBmAHMAIABhAG4AZAAgAHQAeQBwAGUAcwAgACgAMQA5ADgAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAE1Vc2Vycy9qZXJlbXkvUGFwZXJzL0dpcmFyZC9HaXJhcmQtVGF5bG9yLUxhZm9udCAtIFByb29mcyBhbmQgdHlwZXMgKDE5ODkpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA8wD4AQAC7gLwAvUC/gMJAw0DGwMiAysDMAMzAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA0A=},
	Bdsk-Url-1 = {http://www.monad.me.uk/stable/Proofs+Types.html}}

@incollection{Sestoft:Demonstrating:2002,
	Address = {New York, NY, USA},
	Author = {Peter Sestoft},
	Booktitle = {The essence of computation: {C}omplexity, analysis, transformation; essays dedicated to Neil D.~Jones},
	Date-Added = {2008-04-14 18:50:54 -0400},
	Date-Modified = {2008-04-17 14:54:17 -0400},
	Editor = {Torben {\AE}. Mogenson and David A. Schmidt and Sudborough, I. Hal},
	Isbn = {3-540-00326-6},
	Note = {See \url{http://www.dina.kvl.dk/~sestoft/lamreduce/} for a system implementing and visualizing the reduction strategies discussed in the paper},
	Pages = {420--435},
	Publisher = {Springer-Verlag},
	Read = {Yes},
	Series = {Lecture Notes in Computer Science},
	Title = {Demonstrating lambda calculus reduction},
	Volume = {2566: Festschrift},
	Year = {2002},
	Abstract = {We describe lambda calculus reduction strategies, such as call-by-value, call-by-name, normal order, and applicative order, using big-step operational semantics. We show how to simply and efficiently trace such reductions, and use this in a web-based lambda calculus reducer available at $\langle$ http://www.dina.kvl.dk/~sestoft/lamreduce/ $\rangle$.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFEuLi8uLi9QYXBlcnMvU2VzdG9mdC9TZXN0b2Z0IC0gRGVtb25zdHJhdGluZyBsYW1iZGEgY2FsY3VsdXMgcmVkdWN0aW9uICgyMDAyKS5wZGbSGw8cHVdOUy5kYXRhTxECCgAAAAACCgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAMbdDH1Nlc3RvZnQgLSBEZW1vbnN0cmF0IzE3NTNCMC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXU7DCaYJPAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdTZXN0b2Z0AAAQAAgAAME0fl0AAAARAAgAAMJpuo8AAAABABAAMbdDAC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpTZXN0b2Z0OlNlc3RvZnQgLSBEZW1vbnN0cmF0IzE3NTNCMC5wZGYADgB6ADwAUwBlAHMAdABvAGYAdAAgAC0AIABEAGUAbQBvAG4AcwB0AHIAYQB0AGkAbgBnACAAbABhAG0AYgBkAGEAIABjAGEAbABjAHUAbAB1AHMAIAByAGUAZAB1AGMAdABpAG8AbgAgACgAMgAwADAAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFhVc2Vycy9qZXJlbXkvUGFwZXJzL1Nlc3RvZnQvU2VzdG9mdCAtIERlbW9uc3RyYXRpbmcgbGFtYmRhIGNhbGN1bHVzIHJlZHVjdGlvbiAoMjAwMikucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAP4BAwELAxkDGwMgAykDNAM4A0YDTQNWA1sDXgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANr}}

@book{Barendregt:The-Lambda:1984,
	Address = {Amsterdam},
	Author = {Barendregt, H. P.},
	Date-Added = {2008-04-14 09:33:25 -0400},
	Date-Modified = {2008-04-14 09:35:19 -0400},
	Edition = {Revised},
	Publisher = {Elsevier},
	Series = {Studies in Logic and the Foundations of Mathematics},
	Title = {The Lambda Calculus: {I}ts Syntax and Semantics},
	Volume = {103},
	Year = {1984}}

@book{Pierce:Types:2002,
	Author = {Benjamin C. Pierce},
	Date-Added = {2008-04-14 01:02:02 -0400},
	Date-Modified = {2008-04-14 01:03:07 -0400},
	Errata = {http://www.cis.upenn.edu/~bcpierce/tapl/errata.txt},
	Homepage = {http://www.cis.upenn.edu/~bcpierce/tapl},
	Publisher = {MIT Press},
	Title = {Types and Programming Languages},
	Year = 2002}

@book{Pierce:Advanced:2005,
	Date-Added = {2008-04-14 01:02:02 -0400},
	Date-Modified = {2008-04-14 01:03:30 -0400},
	Editor = {Benjamin C. Pierce},
	Homepage = {http://www.cis.upenn.edu/~bcpierce/attapl},
	Publisher = {MIT Press},
	Title = {Advanced Topics in Types and Programming Languages},
	Year = 2005}

@book{Thompson:Type:1991,
	Author = {Thompson, Simon},
	Date-Added = {2008-04-14 00:55:33 -0400},
	Date-Modified = {2008-04-14 19:04:07 -0400},
	Isbn = {0-201-41667-0},
	Note = {Available free of charge from the author's website, \url{http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/}},
	Publisher = {Addison-Wesley},
	Title = {Type Theory and Functional Programming},
	Url = {http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/},
	Year = {1991},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFIuLi8uLi9QYXBlcnMvVGhvbXBzb24vVGhvbXBzb24gLSBUeXBlIFRoZW9yeSBhbmQgRnVuY3Rpb25hbCBQcm9ncmFtbWluZyAoMTk5MSkucGRm0hsPHB1XTlMuZGF0YU8RAg4AAAAAAg4AAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADG3hB9UaG9tcHNvbiAtIFR5cGUgVGhlbyMxNzUzQ0QucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF1PNwmmC2QAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIVGhvbXBzb24AEAAIAADBNH5dAAAAEQAIAADCabsZAAAAAQAQADG3hAAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6VGhvbXBzb246VGhvbXBzb24gLSBUeXBlIFRoZW8jMTc1M0NELnBkZgAADgB6ADwAVABoAG8AbQBwAHMAbwBuACAALQAgAFQAeQBwAGUAIABUAGgAZQBvAHIAeQAgAGEAbgBkACAARgB1AG4AYwB0AGkAbwBuAGEAbAAgAFAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMQA5ADkAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFlVc2Vycy9qZXJlbXkvUGFwZXJzL1Rob21wc29uL1Rob21wc29uIC0gVHlwZSBUaGVvcnkgYW5kIEZ1bmN0aW9uYWwgUHJvZ3JhbW1pbmcgKDE5OTEpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA/wEEAQwDHgMgAyUDLgM5Az0DSwNSA1sDYANjAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA3A=},
	Bdsk-Url-1 = {http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/}}

@unpublished{Steele-Jr.:The-evolution-uncut:1993,
	Author = {{Steele Jr.}, Guy L. and Richard P. Gabriel},
	Date-Added = {2008-04-12 19:44:58 -0400},
	Date-Modified = {2008-04-21 01:37:28 -0400},
	Keywords = {history of computing},
	Note = {Version of the HOPL-II conference paper with 32 pages of material restored that was cut due to lack of time to historically validate the claims made therein.},
	Title = {The evolution of {L}isp ({U}ncut)},
	Url = {http://www.dreamsongs.com/Files/HOPL2-Uncut.pdf},
	Year = {1993},
	Abstract = {

Lisp is the world's greatest programming language---or so its proponents think. The structure of Lisp makes it easy to extend the language or even to implement entirely new dialects without starting from scratch. Overall, the evolution of Lisp has been guided more by institutional rivalry, one-upsmanship, and the glee born of technical cleverness that is characteristic of the "hacker culture" than by sober assessments of technical requirements. Nevertheless this process has eventually produced both an industrial-strength programming language, messy but powerful, and a technically pure dialect, small but powerful, that is suitable for use by programming-language theoreticians. We pick up where McCarthy's paper in the first HOPL conference left off. We trace the development chronologically from the era of the PDP-6, through the heyday of Interlisp and MacLisp, past the ascension and decline of special purpose Lisp machines, to the present era of standardization activities. We then examine the technical evolution of a few representative language features, including both some notable successes and some notable failures, that illuminate design issues that distinguish Lisp from other programming languages. We also discuss the use of Lisp as a laboratory for designing other programming languages. We conclude with some reflections on the forces that have driven the evolution of Lisp.

},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFUuLi8uLi9QYXBlcnMvU3RlZWxlIEpyLi9TdGVlbGUgSnIuLUdhYnJpZWwgLSBUaGUgZXZvbHV0aW9uIG9mIExpc3AgKFVuY3V0KSAoMTk5MykucGRm0hsPHB1XTlMuZGF0YU8RAhYAAAAAAhYAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADGo1R9TdGVlbGUgSnIuLUdhYnJpZWwgLSMzMUE4RjgucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMaj4xCbCjQAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAKU3RlZWxlIEpyLgAQAAgAAME0fl0AAAARAAgAAMQm+s0AAAABABAAMajVAC2RPwADR6wAAGvYAAIAQ09kaW46VXNlcnM6amVyZW15OlBhcGVyczpTdGVlbGUgSnIuOlN0ZWVsZSBKci4tR2FicmllbCAtIzMxQThGOC5wZGYAAA4AfAA9AFMAdABlAGUAbABlACAASgByAC4ALQBHAGEAYgByAGkAZQBsACAALQAgAFQAaABlACAAZQB2AG8AbAB1AHQAaQBvAG4AIABvAGYAIABMAGkAcwBwACAAKABVAG4AYwB1AHQAKQAgACgAMQA5ADkAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFxVc2Vycy9qZXJlbXkvUGFwZXJzL1N0ZWVsZSBKci4vU3RlZWxlIEpyLi1HYWJyaWVsIC0gVGhlIGV2b2x1dGlvbiBvZiBMaXNwIChVbmN1dCkgKDE5OTMpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgECAQcBDwMpAysDMAM5A0QDSANWA10DZgNrA24AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADew==},
	Bdsk-Url-1 = {http://www.dreamsongs.com/Files/HOPL2-Uncut.pdf}}

@article{McCarthy:History:1978,
	Address = {New York, NY, USA},
	Author = {John McCarthy},
	Date-Added = {2008-04-12 19:11:07 -0400},
	Date-Modified = {2008-04-21 01:37:03 -0400},
	Doi = {http://doi.acm.org/10.1145/960118.808387},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Keywords = {history of computing},
	Number = {8},
	Pages = {217--223},
	Publisher = {ACM},
	Title = {History of {LISP}},
	Volume = {13},
	Year = {1978},
	Abstract = {This paper concentrates on the development of the basic ideas and

distinguishes two periods -- Summer 1956 through Summer 1958 when most
of the key ideas were developed (some of which were implemented in the
FORTRAN based FLPL), and Fall 1958 through 1962 when the programming
language was implemented and applied to problems of artificial

intelligence. After 1962, the development of LISP became
multi-stranded, and different ideas were pursued in different places.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEDsuLi8uLi9QYXBlcnMvTWNDYXJ0aHkvTWNDYXJ0aHkgLSBIaXN0b3J5IG9mIExJU1AgKDE5NzgpLnBkZtIbDxwdV05TLmRhdGFPEQHIAAAAAAHIAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAxp4gfTWNDYXJ0aHkgLSBIaXN0b3J5IG8jMzFBODk1LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADGolcQmj8wAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAACE1jQ2FydGh5ABAACAAAwTR+XQAAABEACAAAxCbIDAAAAAEAEAAxp4gALZE/AANHrAAAa9gAAgBBT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOk1jQ2FydGh5Ok1jQ2FydGh5IC0gSGlzdG9yeSBvIzMxQTg5NS5wZGYAAA4ATAAlAE0AYwBDAGEAcgB0AGgAeQAgAC0AIABIAGkAcwB0AG8AcgB5ACAAbwBmACAATABJAFMAUAAgACgAMQA5ADcAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAEJVc2Vycy9qZXJlbXkvUGFwZXJzL01jQ2FydGh5L01jQ2FydGh5IC0gSGlzdG9yeSBvZiBMSVNQICgxOTc4KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA6ADtAPUCwQLDAsgC0QLcAuAC7gL1Av4DAwMGAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAxM=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/960118.808387}}

@article{Steele-Jr.:The-evolution:1993,
	Address = {New York, NY, USA},
	Author = {{Steele Jr.}, Guy L. and Richard P. Gabriel},
	Date-Added = {2008-04-12 19:11:07 -0400},
	Date-Modified = {2008-04-21 01:37:28 -0400},
	Doi = {http://doi.acm.org/10.1145/155360.155373},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Keywords = {history of computing},
	Number = {3},
	Pages = {231--270},
	Publisher = {ACM},
	Rating = {5},
	Title = {The evolution of {L}isp},
	Volume = {28},
	Year = {1993},
	Abstract = {

Lisp is the world's greatest programming language---or so its proponents think. The structure of Lisp makes it easy to extend the language or even to implement entirely new dialects without starting from scratch. Overall, the evolution of Lisp has been guided more by institutional rivalry, one-upsmanship, and the glee born of technical cleverness that is characteristic of the "hacker culture" than by sober assessments of technical requirements. Nevertheless this process has eventually produced both an industrial-strength programming language, messy but powerful, and a technically pure dialect, small but powerful, that is suitable for use by programming-language theoreticians. We pick up where McCarthy's paper in the first HOPL conference left off. We trace the development chronologically from the era of the PDP-6, through the heyday of Interlisp and MacLisp, past the ascension and decline of special purpose Lisp machines, to the present era of standardization activities. We then examine the technical evolution of a few representative language features, including both some notable successes and some notable failures, that illuminate design issues that distinguish Lisp from other programming languages. We also discuss the use of Lisp as a laboratory for designing other programming languages. We conclude with some reflections on the forces that have driven the evolution of Lisp.

},
	Annote = {Fascinating reading. Like having a drink with Steele Jr. and Gabriel while they dish all the Lisp community gossip.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE0uLi8uLi9QYXBlcnMvU3RlZWxlIEpyLi9TdGVlbGUgSnIuLUdhYnJpZWwgLSBUaGUgZXZvbHV0aW9uIG9mIExpc3AgKDE5OTMpLnBkZtIbDxwdV05TLmRhdGFPEQH+AAAAAAH+AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAxqNUfU3RlZWxlIEpyLi1HYWJyaWVsIC0jMzFBODk2LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADGolsQmj84AAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAClN0ZWVsZSBKci4AEAAIAADBNH5dAAAAEQAIAADEJsgOAAAAAQAQADGo1QAtkT8AA0esAABr2AACAENPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6U3RlZWxlIEpyLjpTdGVlbGUgSnIuLUdhYnJpZWwgLSMzMUE4OTYucGRmAAAOAGwANQBTAHQAZQBlAGwAZQAgAEoAcgAuAC0ARwBhAGIAcgBpAGUAbAAgAC0AIABUAGgAZQAgAGUAdgBvAGwAdQB0AGkAbwBuACAAbwBmACAATABpAHMAcAAgACgAMQA5ADkAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFRVc2Vycy9qZXJlbXkvUGFwZXJzL1N0ZWVsZSBKci4vU3RlZWxlIEpyLi1HYWJyaWVsIC0gVGhlIGV2b2x1dGlvbiBvZiBMaXNwICgxOTkzKS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA+gD/AQcDCQMLAxADGQMkAygDNgM9A0YDSwNOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA1s=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/155360.155373}}

@article{Cardelli:On-understanding:1985,
	Address = {New York, NY, USA},
	Author = {Luca Cardelli and Peter Wegner},
	Date-Added = {2008-04-12 19:11:07 -0400},
	Date-Modified = {2008-04-13 17:01:47 -0400},
	Doi = {http://doi.acm.org/10.1145/6041.6042},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Number = {4},
	Pages = {471--523},
	Publisher = {ACM},
	Rating = {5},
	Title = {On understanding types, data abstraction, and polymorphism},
	Volume = {17},
	Year = {1985},
	Abstract = {Our objective is to understand the notion of \textit{type} in programming languages, present a model of typed, polymorphic programming languages that reflects recent research in type theory, and examine the relevance of recent research to the design of practical programming languages.

Object-oriented languages provide both a framework and a motivation for exploring the interaction among the concepts of type, data abstraction, and polymorphism, since they extend the notion of type to data abstraction and since type inheritance is an important form of polymorphism. We develop a $\lambda$-calculus--based model for type systems that allows us to explore these interactions in a simple setting, unencumbered by complexities of production programming languages.

The evolution of languages from untyped universes to monomorphic and then polymorphic type systems is reviewed. Mechanisms for polymorphism such as overloading, coercion, subtyping, and parameterization are examined. A unifying framework for polymorphic type systems is developed in terms of the typed $\lambda$-calculus augmented to include binding of types by quantification as well as binding of values by abstraction.

The typed $\lambda$-calculus is augmented by universal quantification to model generic functions with type parameters, existential quantification and packaging (information hiding) to model abstract data types, and bounded quantification to model subtypes and type inheritance. In this way we obtain a simple and precise characterization of a powerful type system that includes abstract datatypes, parametric polymorphism, and multiple inheritance in a single consistent framework. The mechanisms for type checking for the augmented $\lambda$-calculus are discussed.

The augmented typed $\lambda$;-calculus is used as a programming language for a variety of illustrative examples. We christen this language \textsf{Fun} because fun instead of $\lambda$ is the functional abstraction keyword and because it is pleasant to deal with.

\textsf{Fun} is mathematically simple and can serve as a basis for the design and implementation of real programming languages with type facilities that are more powerful and expressive than those of existing programming languages. In particular, it provides a basis for the design of strongly typed object-oriented languages.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEG0uLi8uLi9QYXBlcnMvQ2FyZGVsbGkvQ2FyZGVsbGktV2VnbmVyIC0gT24gdW5kZXJzdGFuZGluZyB0eXBlcywgZGF0YSBhYnN0cmFjdGlvbiwgYW5kIHBvbHltb3JwaGlzbSAoMTk4NSkucGRm0hsPHB1XTlMuZGF0YU8RAl4AAAAAAl4AAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2Tph9DYXJkZWxsaS1XZWduZXIgLSBPbiMzMUE4OTcucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMaiXxCaP0AAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIQ2FyZGVsbGkAEAAIAADBNH5dAAAAEQAIAADEJsgQAAAAAQAQAC2TpgAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6Q2FyZGVsbGk6Q2FyZGVsbGktV2VnbmVyIC0gT24jMzFBODk3LnBkZgAADgCwAFcAQwBhAHIAZABlAGwAbABpAC0AVwBlAGcAbgBlAHIAIAAtACAATwBuACAAdQBuAGQAZQByAHMAdABhAG4AZABpAG4AZwAgAHQAeQBwAGUAcwAsACAAZABhAHQAYQAgAGEAYgBzAHQAcgBhAGMAdABpAG8AbgAsACAAYQBuAGQAIABwAG8AbAB5AG0AbwByAHAAaABpAHMAbQAgACgAMQA5ADgANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHRVc2Vycy9qZXJlbXkvUGFwZXJzL0NhcmRlbGxpL0NhcmRlbGxpLVdlZ25lciAtIE9uIHVuZGVyc3RhbmRpbmcgdHlwZXMsIGRhdGEgYWJzdHJhY3Rpb24sIGFuZCBwb2x5bW9ycGhpc20gKDE5ODUpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEaAR8BJwOJA4sDkAOZA6QDqAO2A70DxgPLA84AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAD2w==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/6041.6042}}

@article{Backus:Can-programming:1978,
	Address = {New York, NY, USA},
	Author = {John Backus},
	Date-Added = {2008-04-12 19:06:12 -0400},
	Date-Modified = {2008-04-30 02:45:58 -0400},
	Doi = {http://doi.acm.org/10.1145/359576.359579},
	Issn = {0001-0782},
	Journal = {Commun. ACM},
	Number = {8},
	Pages = {613--641},
	Publisher = {ACM},
	Title = {Can programming be liberated from the von Neumann style?: a functional style and its algebra of programs},
	Volume = {21},
	Year = {1978},
	Abstract = {Conventional programming languages are growing ever more enormous, but not stronger. Inherent defects at the most basic level cause them to be both fat and weak: their primitive word-at-a-time style of programming inherited from their common ancestor---the von Neumann computer, their close coupling of semantics to state transitions, their division of programming into a world of expressions and a world of statements, their inability to effectively use powerful combining forms for building new programs from existing ones, and their lack of useful mathematical properties for reasoning about programs. An alternative functional style of programming is founded on the use of combining forms for creating programs. Functional programs deal with structured data, are often nonrepetitive and nonrecursive, are hierarchically constructed, do not name their arguments, and do not require the complex machinery of procedure declarations to become generally applicable. Combining forms can use high level programs to build still higher level ones in a style not possible in conventional languages. Associated with the functional style of programming is an algebra of programs whose variables range over programs and whose operations are combining forms. This algebra can be used to transform programs and to solve equations whose "unknowns" are programs in much the same way one transforms equations in high school algebra. These transformations are given by algebraic laws and are carried out in the same language in which programs are written. Combining forms are chosen not only for their programming power but also for the power of their associated algebraic laws. General theorems of the algebra give the detailed behavior and termination conditions for large classes of programs. A new class of computing systems uses the functional programming style both in its programming language and in its state transition rules. Unlike von Neumann languages, these systems have semantics loosely coupled to states---only one state transition occurs per major computation.},
	Annote = {See p. 616, bottom left, for criticisms of applicative languages:
	* substitution is inefficient;
	* lack of storage and history sensitivity;
These lead to applicative systems' becoming "engulfed in a large von Neumann system," as often happens with Lisp. He sees the lack of history sensitivity as their biggest problem.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGEuLi8uLi9QYXBlcnMvQmFja3VzL0JhY2t1cyAtIENhbiBwcm9ncmFtbWluZyBiZSBsaWJlcmF0ZWQgZnJvbSB0aGUgdm9uIE5ldW1hbm4gc3R5bGU/OiAoMTk3OCkucGRm0hsPHB1XTlMuZGF0YU8RAjoAAAAAAjoAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADGn1B9CYWNrdXMgLSBDYW4gcHJvZ3JhbSMzMUE3RDYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMafWxCa46FBERiBwcnZ3AAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGQmFja3VzABAACAAAwTR+XQAAABEACAAAxCbxKAAAAAEAEAAxp9QALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkJhY2t1czpCYWNrdXMgLSBDYW4gcHJvZ3JhbSMzMUE3RDYucGRmAAAOAJwATQBCAGEAYwBrAHUAcwAgAC0AIABDAGEAbgAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgAGIAZQAgAGwAaQBiAGUAcgBhAHQAZQBkACAAZgByAG8AbQAgAHQAaABlACAAdgBvAG4AIABOAGUAdQBtAGEAbgBuACAAcwB0AHkAbABlAD8ALwAgACgAMQA5ADcAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGhVc2Vycy9qZXJlbXkvUGFwZXJzL0JhY2t1cy9CYWNrdXMgLSBDYW4gcHJvZ3JhbW1pbmcgYmUgbGliZXJhdGVkIGZyb20gdGhlIHZvbiBOZXVtYW5uIHN0eWxlPzogKDE5NzgpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEOARMBGwNZA1sDYANpA3QDeAOGA40DlgObA54AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/359576.359579}}

@article{Wadler:Why-no-one-uses:1998,
	Address = {New York, NY, USA},
	Author = {Philip Wadler},
	Date-Added = {2008-04-12 19:06:12 -0400},
	Date-Modified = {2008-04-30 04:07:11 -0400},
	Doi = {http://doi.acm.org/10.1145/286385.286387},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {8},
	Pages = {23--27},
	Publisher = {ACM},
	Title = {Why no one uses functional languages},
	Url = {http://homepages.inf.ed.ac.uk/wadler/papers/sigplan-why/sigplan-why.ps},
	Volume = {33},
	Year = {1998},
	Abstract = {This column lists eight reasons why functional languages are not more

widely used (compatibility, libraries, portability, availability,
packagability, tools, training, and popularity) and two non-reasons
(performance and ``they just don't get it''), then draws four lessons.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEwuLi8uLi9QYXBlcnMvV2FkbGVyL1dhZGxlciAtIFdoeSBubyBvbmUgdXNlcyBmdW5jdGlvbmFsIGxhbmd1YWdlcyAoMTk5OCkucGRm0hsPHB1XTlMuZGF0YU8RAfwAAAAAAfwAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2ReB9XYWRsZXIgLSBXaHkgbm8gb25lICMzMUE3QzIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMafCxCa4vFBERiBwcnZ3AAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGV2FkbGVyABAACAAAwTR+XQAAABEACAAAxCbw/AAAAAEAEAAtkXgALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOldhZGxlcjpXYWRsZXIgLSBXaHkgbm8gb25lICMzMUE3QzIucGRmAAAOAHIAOABXAGEAZABsAGUAcgAgAC0AIABXAGgAeQAgAG4AbwAgAG8AbgBlACAAdQBzAGUAcwAgAGYAdQBuAGMAdABpAG8AbgBhAGwAIABsAGEAbgBnAHUAYQBnAGUAcwAgACgAMQA5ADkAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFNVc2Vycy9qZXJlbXkvUGFwZXJzL1dhZGxlci9XYWRsZXIgLSBXaHkgbm8gb25lIHVzZXMgZnVuY3Rpb25hbCBsYW5ndWFnZXMgKDE5OTgpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA+QD+AQYDBgMIAw0DFgMhAyUDMwM6A0MDSANLAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA1g=},
	Bdsk-Url-1 = {http://homepages.inf.ed.ac.uk/wadler/papers/sigplan-why/sigplan-why.ps},
	Bdsk-Url-2 = {http://doi.acm.org/10.1145/286385.286387}}

@inproceedings{Barendregt:Types:1990,
	Address = {London, UK},
	Author = {Henk Barendregt and Kees Hemerik},
	Booktitle = {ESOP '90: Proceedings of the 3rd European Symposium on Programming},
	Date-Added = {2008-04-12 19:04:51 -0400},
	Date-Modified = {2008-04-12 19:04:58 -0400},
	Isbn = {3-540-52592-0},
	Pages = {1--35},
	Publisher = {Springer-Verlag},
	Title = {Types in Lambda Calculi and Programming Languages},
	Year = {1990},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGkuLi8uLi9QYXBlcnMvQmFyZW5kcmVndC9CYXJlbmRyZWd0LUhlbWVyaWsgLSBUeXBlcyBpbiBMYW1iZGEgQ2FsY3VsaSBhbmQgUHJvZ3JhbW1pbmcgTGFuZ3VhZ2VzICgxOTkwKS5wZGbSGw8cHVdOUy5kYXRhTxECUgAAAAACUgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAMae1H0JhcmVuZHJlZ3QtSGVtZXJpayAtIzMxQTdBMy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxp6PEJrhlUERGIHBydncAAgADAAAJIAAAAAAAAAAAAAAAAAAAAApCYXJlbmRyZWd0ABAACAAAwTR+XQAAABEACAAAxCbwpQAAAAEAEAAxp7UALZE/AANHrAAAa9gAAgBDT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkJhcmVuZHJlZ3Q6QmFyZW5kcmVndC1IZW1lcmlrIC0jMzFBN0EzLnBkZgAADgCkAFEAQgBhAHIAZQBuAGQAcgBlAGcAdAAtAEgAZQBtAGUAcgBpAGsAIAAtACAAVAB5AHAAZQBzACAAaQBuACAATABhAG0AYgBkAGEAIABDAGEAbABjAHUAbABpACAAYQBuAGQAIABQAHIAbwBnAHIAYQBtAG0AaQBuAGcAIABMAGEAbgBnAHUAYQBnAGUAcwAgACgAMQA5ADkAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHBVc2Vycy9qZXJlbXkvUGFwZXJzL0JhcmVuZHJlZ3QvQmFyZW5kcmVndC1IZW1lcmlrIC0gVHlwZXMgaW4gTGFtYmRhIENhbGN1bGkgYW5kIFByb2dyYW1taW5nIExhbmd1YWdlcyAoMTk5MCkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARYBGwEjA3kDewOAA4kDlAOYA6YDrQO2A7sDvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAPL}}

@article{Bruijn:Lambda:1972,
	Author = {de Bru{\ij}n, N. G.},
	Date-Added = {2008-04-12 19:04:51 -0400},
	Date-Modified = {2008-04-16 21:31:06 -0400},
	Journal = {Indagationes Mathematic{\ae}},
	Number = {5},
	Pages = {381-392},
	Title = {Lambda calculus notation with nameless dummies, a tool for automatic formula manipulation, with application to the {C}hurch--{R}osser theorem},
	Volume = {34},
	Year = 1972,
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE4uLi8uLi9QYXBlcnMvQnJ1aWpuL0JydWlqbiAtIExhbWJkYSBjYWxjdWx1cyBub3RhdGlvbiB3aXRoIG5hbWVsZXNzICgxOTcyKS5wZGbSGw8cHVdOUy5kYXRhTxECAgAAAAACAgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAMae0H0JydWlqbiAtIExhbWJkYSBjYWxjIzMxQTdBOS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxp6nEJrhyUERGIHBydncAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZCcnVpam4AEAAIAADBNH5dAAAAEQAIAADEJvCyAAAAAQAQADGntAAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QnJ1aWpuOkJydWlqbiAtIExhbWJkYSBjYWxjIzMxQTdBOS5wZGYAAA4AdgA6AEIAcgB1AGkAagBuACAALQAgAEwAYQBtAGIAZABhACAAYwBhAGwAYwB1AGwAdQBzACAAbgBvAHQAYQB0AGkAbwBuACAAdwBpAHQAaAAgAG4AYQBtAGUAbABlAHMAcwAgACgAMQA5ADcAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFVVc2Vycy9qZXJlbXkvUGFwZXJzL0JydWlqbi9CcnVpam4gLSBMYW1iZGEgY2FsY3VsdXMgbm90YXRpb24gd2l0aCBuYW1lbGVzcyAoMTk3MikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD7AQABCAMOAxADFQMeAykDLQM7A0IDSwNQA1MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADYA==},
	Bdsk-File-2 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFAuLi8uLi9QYXBlcnMvQnJ1XGlqbi9CcnVcaWpuIC0gTGFtYmRhIGNhbGN1bHVzIG5vdGF0aW9uIHdpdGggbmFtZWxlc3MgKDE5NzIpLnBkZtIbDxwdV05TLmRhdGFPEQIIAAAAAAIIAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAx9QgfQnJ1XGlqbiAtIExhbWJkYSBjYWwjMzFGNDU3LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADH0V8QsFwpQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAB0JydVxpam4AABAACAAAwTR+XQAAABEACAAAxCxPSgAAAAEAEAAx9QgALZE/AANHrAAAa9gAAgBAT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkJydVxpam46QnJ1XGlqbiAtIExhbWJkYSBjYWwjMzFGNDU3LnBkZgAOAHgAOwBCAHIAdQBcAGkAagBuACAALQAgAEwAYQBtAGIAZABhACAAYwBhAGwAYwB1AGwAdQBzACAAbgBvAHQAYQB0AGkAbwBuACAAdwBpAHQAaAAgAG4AYQBtAGUAbABlAHMAcwAgACgAMQA5ADcAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFdVc2Vycy9qZXJlbXkvUGFwZXJzL0JydVxpam4vQnJ1XGlqbiAtIExhbWJkYSBjYWxjdWx1cyBub3RhdGlvbiB3aXRoIG5hbWVsZXNzICgxOTcyKS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAP0BAgEKAxYDGAMdAyYDMQM1A0MDSgNTA1gDWwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANo}}

@inproceedings{McCarthy:LISP:1980,
	Address = {New York, NY, USA},
	Author = {John McCarthy},
	Booktitle = {LFP '80: Proceedings of the 1980 ACM conference on LISP and functional programming},
	Date-Added = {2008-04-12 18:58:16 -0400},
	Date-Modified = {2008-04-21 01:37:28 -0400},
	Doi = {http://doi.acm.org/10.1145/800087.802782},
	Keywords = {history of computing},
	Location = {Stanford University, California, United States},
	Pages = {.5--viii},
	Publisher = {ACM},
	Title = {LISP - notes on its past and future},
	Year = {1980},
	Abstract = {LISP has survived for 21 years because it is an approximate local optimum in the space of programming languages. However, it has accumulated some barnacles that should be scraped off, and some long-standing opportunities for improvement have been neglected. It would benefit from some co-operative maintenance especially in creating and maintaining program libraries. Computer checked proofs of program correctness are now possible for pure LISP and some extensions, but more theory and some smoothing of the language itself are required before we can take full advantage of LISP's mathematical basis.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE8uLi8uLi9QYXBlcnMvTWNDYXJ0aHkvTWNDYXJ0aHkgLSBMSVNQIC0gbm90ZXMgb24gaXRzIHBhc3QgYW5kIGZ1dHVyZSAoMTk4MCkucGRm0hsPHB1XTlMuZGF0YU8RAgQAAAAAAgQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADGniB9NY0NhcnRoeSAtIExJU1AgLSBubyMzMUE3NjIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMadixCa3UwAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAITWNDYXJ0aHkAEAAIAADBNH5dAAAAEQAIAADEJu+TAAAAAQAQADGniAAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6TWNDYXJ0aHk6TWNDYXJ0aHkgLSBMSVNQIC0gbm8jMzFBNzYyLnBkZgAADgB0ADkATQBjAEMAYQByAHQAaAB5ACAALQAgAEwASQBTAFAAIAAtACAAbgBvAHQAZQBzACAAbwBuACAAaQB0AHMAIABwAGEAcwB0ACAAYQBuAGQAIABmAHUAdAB1AHIAZQAgACgAMQA5ADgAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFZVc2Vycy9qZXJlbXkvUGFwZXJzL01jQ2FydGh5L01jQ2FydGh5IC0gTElTUCAtIG5vdGVzIG9uIGl0cyBwYXN0IGFuZCBmdXR1cmUgKDE5ODApLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD8AQEBCQMRAxMDGAMhAywDMAM+A0UDTgNTA1YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADYw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/800087.802782}}

@article{McCarthy:Recursive:1960,
	Address = {New York, NY, USA},
	Author = {John McCarthy},
	Date-Added = {2008-04-12 18:58:16 -0400},
	Date-Modified = {2008-04-12 18:58:38 -0400},
	Doi = {http://doi.acm.org/10.1145/367177.367199},
	Issn = {0001-0782},
	Journal = {Commun. ACM},
	Number = {4},
	Pages = {184--195},
	Publisher = {ACM},
	Title = {Recursive functions of symbolic expressions and their computation by machine, Part I},
	Volume = {3},
	Year = {1960},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGEuLi8uLi9QYXBlcnMvTWNDYXJ0aHkvTWNDYXJ0aHkgLSBSZWN1cnNpdmUgZnVuY3Rpb25zIG9mIHN5bWJvbGljIGV4cHJlc3Npb25zIGFuZCB0aGVpciAoMTk2MCkucGRm0hsPHB1XTlMuZGF0YU8RAjoAAAAAAjoAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADGniB9NY0NhcnRoeSAtIFJlY3Vyc2l2ZSMzMUE3OTUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMaeVxCa4DAAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAITWNDYXJ0aHkAEAAIAADBNH5dAAAAEQAIAADEJvBMAAAAAQAQADGniAAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6TWNDYXJ0aHk6TWNDYXJ0aHkgLSBSZWN1cnNpdmUjMzFBNzk1LnBkZgAADgCYAEsATQBjAEMAYQByAHQAaAB5ACAALQAgAFIAZQBjAHUAcgBzAGkAdgBlACAAZgB1AG4AYwB0AGkAbwBuAHMAIABvAGYAIABzAHkAbQBiAG8AbABpAGMAIABlAHgAcAByAGUAcwBzAGkAbwBuAHMAIABhAG4AZAAgAHQAaABlAGkAcgAgACgAMQA5ADYAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGhVc2Vycy9qZXJlbXkvUGFwZXJzL01jQ2FydGh5L01jQ2FydGh5IC0gUmVjdXJzaXZlIGZ1bmN0aW9ucyBvZiBzeW1ib2xpYyBleHByZXNzaW9ucyBhbmQgdGhlaXIgKDE5NjApLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEOARMBGwNZA1sDYANpA3QDeAOGA40DlgObA54AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/367177.367199}}

@article{Layer:Lisp:1991,
	Address = {New York, NY, USA},
	Author = {D. Kevin Layer and Chris Richardson},
	Date-Added = {2008-04-12 18:58:16 -0400},
	Date-Modified = {2008-04-21 01:37:28 -0400},
	Doi = {http://doi.acm.org/10.1145/114669.114674},
	Issn = {0001-0782},
	Journal = {Commun. ACM},
	Keywords = {history of computing},
	Number = {9},
	Pages = {48--57},
	Publisher = {ACM},
	Title = {Lisp systems in the 1990s},
	Volume = {34},
	Year = {1991},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEouLi8uLi9QYXBlcnMvTGF5ZXIvTGF5ZXItUmljaGFyZHNvbiAtIExpc3Agc3lzdGVtcyBpbiB0aGUgMTk5MHMgKDE5OTEpLnBkZtIbDxwdV05TLmRhdGFPEQH2AAAAAAH2AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAxp1IfTGF5ZXItUmljaGFyZHNvbiAtIEwjMjlGODdFLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACn4fgAAAAAAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABUxheWVyAAAQAAgAAME0fl0AAAARAAgAAAAAAAAAAAABABAAMadSAC2RPwADR6wAAGvYAAIAPk9kaW46VXNlcnM6amVyZW15OlBhcGVyczpMYXllcjpMYXllci1SaWNoYXJkc29uIC0gTCMyOUY4N0UucGRmAA4AcAA3AEwAYQB5AGUAcgAtAFIAaQBjAGgAYQByAGQAcwBvAG4AIAAtACAATABpAHMAcAAgAHMAeQBzAHQAZQBtAHMAIABpAG4AIAB0AGgAZQAgADEAOQA5ADAAcwAgACgAMQA5ADkAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFFVc2Vycy9qZXJlbXkvUGFwZXJzL0xheWVyL0xheWVyLVJpY2hhcmRzb24gLSBMaXNwIHN5c3RlbXMgaW4gdGhlIDE5OTBzICgxOTkxKS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPcA/AEEAv4DAAMFAw4DGQMdAysDMgM7A0ADQwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANQ},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/114669.114674}}

@inproceedings{Stoyan:Early:1984,
	Address = {New York, NY, USA},
	Author = {Herbert Stoyan},
	Booktitle = {LFP '84: Proceedings of the 1984 ACM Symposium on LISP and functional programming},
	Date-Added = {2008-04-12 18:58:16 -0400},
	Date-Modified = {2008-04-21 01:36:32 -0400},
	Doi = {http://doi.acm.org/10.1145/800055.802047},
	Isbn = {0-89791-142-3},
	Keywords = {history of computing},
	Location = {Austin, Texas, United States},
	Pages = {299--310},
	Publisher = {ACM},
	Read = {Yes},
	Title = {Early LISP history (1956 - 1959)},
	Year = {1984},
	Abstract = {This paper describes the development of LISP from McCarthy's first research in the topic of programming languages for AI until the stage when the LISP1 implementation had developed into a serious program (May 1959). We show the steps that led to LISP and the various proposals for LISP interpreters (between November 1958 and May 1959). The paper contains some correcting details to our book (32).},
	Annote = {Improves on McCarthy's own recollection through a basis in available written record. Very interesting look at what led up to the realization of honest-to-goodness LISP.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEguLi8uLi9QYXBlcnMvU3RveWFuL1N0b3lhbiAtIEVhcmx5IExJU1AgaGlzdG9yeSAoMTk1NiAtIDE5NTkpICgxOTg0KS5wZGbSGw8cHVdOUy5kYXRhTxEB8AAAAAAB8AACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAMadUH1N0b3lhbiAtIEVhcmx5IExJU1AgIzI5Rjg4MC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp+IAAAAAAAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZTdG95YW4AEAAIAADBNH5dAAAAEQAIAAAAAAAAAAAAAQAQADGnVAAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6U3RveWFuOlN0b3lhbiAtIEVhcmx5IExJU1AgIzI5Rjg4MC5wZGYAAA4AagA0AFMAdABvAHkAYQBuACAALQAgAEUAYQByAGwAeQAgAEwASQBTAFAAIABoAGkAcwB0AG8AcgB5ACAAKAAxADkANQA2ACAALQAgADEAOQA1ADkAKQAgACgAMQA5ADgANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAE9Vc2Vycy9qZXJlbXkvUGFwZXJzL1N0b3lhbi9TdG95YW4gLSBFYXJseSBMSVNQIGhpc3RvcnkgKDE5NTYgLSAxOTU5KSAoMTk4NCkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD1APoBAgL2AvgC/QMGAxEDFQMjAyoDMwM4AzsAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADSA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/800055.802047}}

@article{Mody:Functional:1992,
	Address = {New York, NY, USA},
	Author = {R. P. Mody},
	Date-Added = {2008-04-12 18:58:16 -0400},
	Date-Modified = {2008-04-12 18:58:38 -0400},
	Doi = {http://doi.acm.org/10.1145/141018.141021},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {11},
	Pages = {13--14},
	Publisher = {ACM},
	Title = {Functional programming is not self-modifying code},
	Volume = {27},
	Year = {1992},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFUuLi8uLi9QYXBlcnMvTW9keS9Nb2R5IC0gRnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpcyBub3Qgc2VsZi1tb2RpZnlpbmcgY29kZSAoMTk5MikucGRm0hsPHB1XTlMuZGF0YU8RAhYAAAAAAhYAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADGnUx9Nb2R5IC0gRnVuY3Rpb25hbCBwciMyOUY4N0YucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKfh/AAAAAAAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAETW9keQAQAAgAAME0fl0AAAARAAgAAAAAAAAAAAABABAAMadTAC2RPwADR6wAAGvYAAIAPU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpNb2R5Ok1vZHkgLSBGdW5jdGlvbmFsIHByIzI5Rjg3Ri5wZGYAAA4AiABDAE0AbwBkAHkAIAAtACAARgB1AG4AYwB0AGkAbwBuAGEAbAAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgAGkAcwAgAG4AbwB0ACAAcwBlAGwAZgAtAG0AbwBkAGkAZgB5AGkAbgBnACAAYwBvAGQAZQAgACgAMQA5ADkAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFxVc2Vycy9qZXJlbXkvUGFwZXJzL01vZHkvTW9keSAtIEZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaXMgbm90IHNlbGYtbW9kaWZ5aW5nIGNvZGUgKDE5OTIpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgECAQcBDwMpAysDMAM5A0QDSANWA10DZgNrA24AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADew==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/141018.141021}}

@article{Yuen:Which:1991,
	Address = {This article reviews models of programming applicable to Lisp, and argues that both the sequential model and the functional model have  developed in directions of excessive complexity. For future developments, a mixed model based on old-style Lisp, but augmented with new parallel constructs, can provide a simpler tool for handling practical programming tasks.},
	Author = {C. K. Yuen},
	Date-Added = {2008-04-12 18:58:16 -0400},
	Date-Modified = {2008-04-12 18:58:38 -0400},
	Doi = {http://doi.acm.org/10.1145/122616.122626},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {10},
	Pages = {83--92},
	Publisher = {ACM},
	Title = {Which model of programming for LISP: sequential, functional or mixed?},
	Volume = {26},
	Year = {1991},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFQuLi8uLi9QYXBlcnMvWXVlbi9ZdWVuIC0gV2hpY2ggbW9kZWwgb2YgcHJvZ3JhbW1pbmcgZm9yIExJU1A6IHNlcXVlbnRpYWwsICgxOTkxKS5wZGbSGw8cHVdOUy5kYXRhTxECFAAAAAACFAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAMadVH1l1ZW4gLSBXaGljaCBtb2RlbCBvIzI5Rjg4MS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp+IEAAAAAAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAARZdWVuABAACAAAwTR+XQAAABEACAAAAAAAAAAAAAEAEAAxp1UALZE/AANHrAAAa9gAAgA9T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOll1ZW46WXVlbiAtIFdoaWNoIG1vZGVsIG8jMjlGODgxLnBkZgAADgCGAEIAWQB1AGUAbgAgAC0AIABXAGgAaQBjAGgAIABtAG8AZABlAGwAIABvAGYAIABwAHIAbwBnAHIAYQBtAG0AaQBuAGcAIABmAG8AcgAgAEwASQBTAFAALwAgAHMAZQBxAHUAZQBuAHQAaQBhAGwALAAgACgAMQA5ADkAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFtVc2Vycy9qZXJlbXkvUGFwZXJzL1l1ZW4vWXVlbiAtIFdoaWNoIG1vZGVsIG9mIHByb2dyYW1taW5nIGZvciBMSVNQOiBzZXF1ZW50aWFsLCAoMTk5MSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEBAQYBDgMmAygDLQM2A0EDRQNTA1oDYwNoA2sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADeA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/122616.122626}}

@inproceedings{Demaine:Cache-Oblivious:2002,
	Address = {BRICS, University of Aarhus, Denmark},
	Author = {Demaine, Erik D.},
	Booktitle = {Lecture Notes from the EEF Summer School on Massive Data Sets},
	Bookurl = {http://www.brics.dk/MassiveData02/},
	Date-Added = {2008-04-03 13:05:11 -0400},
	Date-Modified = {2008-04-03 13:28:03 -0400},
	Length = {29 pages},
	Month = {June 27--July 1},
	Note = {To appear},
	Publisher = {Springer-Verlag},
	Read = {Yes},
	Series = {Lecture Notes in Computer Science},
	Seriesurl = {http://www.springer.de/comp/lncs/},
	Title = {Cache-Oblivious Algorithms and Data Structures},
	Url = {http://erikdemaine.org/papers/BRICS2002/},
	Year = {2002},
	Abstract = {A recent direction in the design of cache-efficient and disk-efficient algorithms and data structures is the notion of \textit{cache obliviousness,} introduced by Frigo, Leiserson, Prokop, and Ramachandran in 1999. Cache-oblivious algorithms perform well on a multilevel memory hierarchy without knowing any parameters of the hierarchy, only knowing the existence of a hierarchy. Equivalently, a single cache-oblivious algorithm is efficient on all memory hierarchies simultaneously. While such results might seem impossible, a recent body of work has developed cache-oblivious algorithms and data structures that perform as well or nearly as well as standard external-memory structures which require knowledge of the cache/memory size and block transfer size. Here we describe several of these results with the intent of elucidating the techniques behind their design. Perhaps the most exciting of these results are the data structures, which form general building blocks immediately leading to several algorithmic results.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFguLi8uLi9QYXBlcnMvRGVtYWluZS9EZW1haW5lIC0gQ2FjaGUtT2JsaXZpb3VzIEFsZ29yaXRobXMgYW5kIERhdGEgU3RydWN0dXJlcyAoMjAwMikucGRm0hsPHB1XTlMuZGF0YU8RAiAAAAAAAiAAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADFGcR9EZW1haW5lIC0gQ2FjaGUtT2JsaSMzMTQ2MEUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMUYOxBqKjlBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAHRGVtYWluZQAAEAAIAADBNH5dAAAAEQAIAADEGsLOAAAAAQAQADFGcQAtkT8AA0esAABr2AACAEBPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6RGVtYWluZTpEZW1haW5lIC0gQ2FjaGUtT2JsaSMzMTQ2MEUucGRmAA4AiABDAEQAZQBtAGEAaQBuAGUAIAAtACAAQwBhAGMAaABlAC0ATwBiAGwAaQB2AGkAbwB1AHMAIABBAGwAZwBvAHIAaQB0AGgAbQBzACAAYQBuAGQAIABEAGEAdABhACAAUwB0AHIAdQBjAHQAdQByAGUAcwAgACgAMgAwADAAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF9Vc2Vycy9qZXJlbXkvUGFwZXJzL0RlbWFpbmUvRGVtYWluZSAtIENhY2hlLU9ibGl2aW91cyBBbGdvcml0aG1zIGFuZCBEYXRhIFN0cnVjdHVyZXMgKDIwMDIpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBBQEKARIDNgM4Az0DRgNRA1UDYwNqA3MDeAN7AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA4g=},
	Bdsk-Url-1 = {http://erikdemaine.org/papers/BRICS2002/}}

@book{Hennessy:Computer:2006,
	Author = {Hennessy, John L. and Patterson, David A.},
	Date-Added = {2008-04-03 13:01:59 -0400},
	Date-Modified = {2008-04-03 14:32:04 -0400},
	Edition = {Fourth},
	Month = {Sep},
	Publisher = {Morgan Kaufmann Publishers},
	Title = {Computer Architecture: A Quantitative Approach},
	Year = {2006}}

@book{Patterson:Computer:2007,
	Author = {Patterson, David A. and Hennessy, John L.},
	Date-Added = {2008-04-03 13:00:11 -0400},
	Date-Modified = {2008-04-03 14:31:55 -0400},
	Edition = {Third revised},
	Month = {June},
	Publisher = {Morgan Kaufmann Publishers},
	Title = {Computer Organization and Design: {T}he Hardware/Software Interface},
	Year = {2007}}

@book{Herken:The-Universal:1995,
	Address = {London, UK},
	Date-Added = {2008-04-03 12:53:05 -0400},
	Date-Modified = {2008-04-03 12:58:08 -0400},
	Edition = {Second},
	Editor = {Herken, Rolf},
	Month = {May},
	Publisher = {Springer-Verlag},
	Title = {The Universal Turing Machine: {A} Half-Century Survey},
	Year = {1995}}

@article{Turing:On-Computable:1937,
	Author = {Turing, Alan},
	Date-Added = {2008-04-03 12:44:01 -0400},
	Date-Modified = {2008-04-03 12:49:30 -0400},
	Journal = {Proceedings of the London Mathematical Society, Series 2},
	Pages = {230--265},
	Title = {On Computable Numbers, With an Application to the {E}ntscheidungsproblem},
	Volume = {42},
	Year = {1937}}

@book{Aho:Compilers:1986,
	Author = {Aho, Alfred V. and Sethi, Ravi and Ullman, Jeffrey D.},
	Date-Added = {2008-03-02 12:46:05 -0500},
	Date-Modified = {2008-04-14 19:03:47 -0400},
	Edition = {First},
	Isbn = {0-201-10088-6},
	Note = {Known as the ``red dragon book''},
	Publisher = {Addison-Wesley Higher Education},
	Title = {Compilers: {P}rinciples, Techniques, and Tools},
	Year = {1986}}

@book{Aho:Principles:1977,
	Address = {Reading, Mass., USA},
	Author = {Aho, Alfred V. and Ullman, Jeffrey D.},
	Date-Added = {2008-03-02 12:43:04 -0500},
	Date-Modified = {2008-04-14 19:03:54 -0400},
	Isbn = {0-201-00022-9},
	Note = {Known as the ``green dragon book''},
	Publisher = {Addison-Wesley},
	Title = {Principles of Compiler Design},
	Year = {1977}}

@inproceedings{Hovemeyer:Finding:2004,
	Address = {New York, NY, USA},
	Author = {David Hovemeyer and William Pugh},
	Booktitle = {OOPSLA '04: Companion to the 19th annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications},
	Date-Added = {2008-02-24 18:11:09 -0500},
	Date-Modified = {2008-02-24 18:14:39 -0500},
	Doi = {http://doi.acm.org/10.1145/1028664.1028717},
	Isbn = {1-58113-833-4},
	Location = {Vancouver, BC, CANADA},
	Note = {{\em See \url{http://findbugs.sourceforge.net/}.}},
	Pages = {132--136},
	Publisher = {ACM},
	Title = {Finding Bugs Is Easy},
	Url = {http://findbugs.sourceforge.net/docs/oopsla2004.pdf},
	Year = {2004},
	Abstract = {Many techniques have been developed over the years to automatically find bugs in software. Often, these techniques rely on formal methods and sophisticated program analysis. While these techniques are valuable, they can be difficult to apply, and they aren't always effective in finding real bugs.

<i>Bug patterns</i> are code idioms that are often errors. We have implemented automatic detectors for a variety of bug patterns found in Java programs. In this extended abstract<sup>1</sup>, we describe how we have used bug pattern detectors to find serious bugs in several widely used Java applications and libraries. We have found that the effort required to implement a bug pattern detector tends to be low, and that even extremely simple detectors find bugs in real applications.

From our experience applying bug pattern detectors to real programs, we have drawn several interesting conclusions. First, we have found that even well tested code written by experts contains a surprising number of obvious bugs. Second, Java (and similar languages) have many language features and APIs which are prone to misuse. Finally, that simple automatic techniques can be effective at countering the impact of both ordinary mistakes and misunderstood language features.},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1028664.1028717},
	Bdsk-Url-2 = {http://findbugs.sourceforge.net/docs/oopsla2004.pdf}}

@mastersthesis{Lattner:LLVM:2002,
	Address = {Urbana, Ill., USA},
	Author = {Chris Lattner},
	Date-Added = {2008-02-24 18:00:35 -0500},
	Date-Modified = {2008-02-24 18:02:21 -0500},
	Month = {Dec},
	Note = {{\em See \url{http://llvm.cs.uiuc.edu}.}},
	School = {{Computer Science Dept., University of Illinois at Urbana-Champaign}},
	Title = {{LLVM: An Infrastructure for Multi-Stage Optimization}},
	Year = {2002}}

@book{Zima:Supercompilers:1991,
	Address = {Reading, Mass., USA},
	Author = {Zima, Hans and Barbara Chapman},
	Date-Added = {2008-02-24 17:48:41 -0500},
	Date-Modified = {2008-02-24 17:56:48 -0500},
	Publisher = {ACM Press/Addison-Wesley},
	Title = {Supercompilers for Parallel and Vector Machines},
	Year = {1991}}

@book{Wolfe:High-Performance:1996,
	Address = {Redwood City, Calif., USA},
	Author = {Wolfe, Michael R.},
	Date-Added = {2008-02-24 17:48:37 -0500},
	Date-Modified = {2008-02-24 17:55:04 -0500},
	Publisher = {Addison-Wesley},
	Title = {High-Performance Compilers for Parallel Computing},
	Year = {1996}}

@book{Bannerjee:Loop:1994,
	Address = {Boston, Mass., USA},
	Author = {Bannerjee, Utpal},
	Date-Added = {2008-02-24 17:48:34 -0500},
	Date-Modified = {2008-02-24 17:53:30 -0500},
	Publisher = {Kluwer Academic Publishers},
	Title = {Loop Parallelization},
	Year = {1994}}

@book{Bannerjee:Loop:1993,
	Address = {Boston, Mass., USA},
	Author = {Bannerjee, Utpal},
	Date-Added = {2008-02-24 17:48:28 -0500},
	Date-Modified = {2008-02-24 17:52:50 -0500},
	Publisher = {Kluwer Academic Publishers},
	Title = {Loop Transformations for Restructuring Compilers},
	Year = {1993}}

@book{Bannerjee:Dependence:1988,
	Address = {Boston, Mass., USA},
	Author = {Bannerjee, Utpal},
	Date-Added = {2008-02-24 17:48:06 -0500},
	Date-Modified = {2008-02-24 17:52:15 -0500},
	Publisher = {Kluwer Academic Publishers},
	Title = {Dependence Analysis for Supercomputing},
	Year = {1988}}

@book{Aho:Compilers:2006,
	Author = {Aho, Alfred V. and Sethi, Ravi and Ullman, Jeffrey D. and Lam, Monica S.},
	Date-Added = {2008-02-10 14:28:34 -0500},
	Date-Modified = {2008-04-14 19:01:55 -0400},
	Edition = {Second},
	Isbn = {978-0-321-48681-1},
	Month = {August},
	Note = {Known as the ``purple dragon book''},
	Publisher = {Addison-Wesley Higher Education},
	Title = {Compilers: {P}rinciples, Techniques, and Tools},
	Year = {2006}}

@article{Wadler:Fixing:1987,
	Author = {Philip Wadler},
	Date-Added = {2007-12-13 14:15:18 -0500},
	Date-Modified = {2008-04-29 03:58:01 -0400},
	Journal = {Software Practice and Experience},
	Keywords = {space leak, garbage collection, functional languages, lazy evaluation},
	Local-Url = {file://localhost/Users/jeremy/Papers/Wadler/Wadler%20-%20Fixing%20some%20space%20leaks%20with%20(1987).pdf},
	Month = {September},
	Number = {9},
	Pages = {595-608},
	Rating = {3},
	Read = {Yes},
	Title = {Fixing some space leaks with a garbage collector},
	Url = {http://www.research.avayalabs.com/user/wadler/papers/leak/leak.ps},
	Volume = {17},
	Year = {1987},
	Abstract = {Some functional programs may use more space than would be expected. A modification to the garbage collector is suggested which solves this problem in some cases. Related work is discussed.},
	Annote = {Proposes having the garbage collector perform limited evaluation to eliminate a certain class of space leaks involving tuples and pattern-matched where clauses (as allowed in Miranda and Haskell). Contrasts to a more general but more obnoxious solution of forcing programmers to insert parallelism annotations.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEQuLi8uLi9QYXBlcnMvV2FkbGVyL1dhZGxlciAtIEZpeGluZyBzb21lIHNwYWNlIGxlYWtzIHdpdGggKDE5ODcpLnBkZtIbDxwdV05TLmRhdGFPEQHkAAAAAAHkAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtkXgfV2FkbGVyIC0gRml4aW5nIHNvbWUjMkM3NzdCLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACx3e8NqGCgAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABldhZGxlcgAQAAgAAME0fl0AAAARAAgAAMNqXngAAAABABAALZF4AC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpXYWRsZXI6V2FkbGVyIC0gRml4aW5nIHNvbWUjMkM3NzdCLnBkZgAADgBiADAAVwBhAGQAbABlAHIAIAAtACAARgBpAHgAaQBuAGcAIABzAG8AbQBlACAAcwBwAGEAYwBlACAAbABlAGEAawBzACAAdwBpAHQAaAAgACgAMQA5ADgANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAEtVc2Vycy9qZXJlbXkvUGFwZXJzL1dhZGxlci9XYWRsZXIgLSBGaXhpbmcgc29tZSBzcGFjZSBsZWFrcyB3aXRoICgxOTg3KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPEA9gD+AuYC6ALtAvYDAQMFAxMDGgMjAygDKwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAM4},
	Bdsk-Url-1 = {http://www.research.avayalabs.com/user/wadler/papers/leak/leak.ps}}

@book{Grune:Parsing:2007,
	Address = {London, UK},
	Author = {Grune, Dick and Jacobs, Ceriel J.\ H.},
	Date-Added = {2008-02-10 14:04:15 -0500},
	Date-Modified = {2008-04-14 19:02:31 -0400},
	Edition = {Second},
	Isbn = {978-0-387-20248-8},
	Keywords = {parsing},
	Note = {Complete first edition available online at \url{http://www.cs.vu.nl/$\sim$dick/PTAPG.html}},
	Publisher = {Springer-Verlag},
	Title = {Parsing Techniques: {A} Practical Guide},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEDEuLi8uLi9EZXNrdG9wL2JsYW5rIGxhbmRzY2FwZSBjYWxlbmRhciAtIDIwMDgucGRm0hsPHB1XTlMuZGF0YU8RAa4AAAAAAa4AAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAANHtx9ibGFuayBsYW5kc2NhcGUgY2FsZSMyRDBEQUMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALQ2sw4J0/AAAAAAAAAAAAAIAAgAACSAAAAAAAAAAAAAAAAAAAAAHRGVza3RvcAAAEAAIAADBNH5dAAAAEQAIAADDgrtMAAAAAQAMAANHtwADR6wAAGvYAAIAOU9kaW46VXNlcnM6amVyZW15OkRlc2t0b3A6YmxhbmsgbGFuZHNjYXBlIGNhbGUjMkQwREFDLnBkZgAADgBIACMAYgBsAGEAbgBrACAAbABhAG4AZABzAGMAYQBwAGUAIABjAGEAbABlAG4AZABhAHIAIAAtACAAMgAwADAAOAAuAHAAZABmAA8ACgAEAE8AZABpAG4AEgA4VXNlcnMvamVyZW15L0Rlc2t0b3AvYmxhbmsgbGFuZHNjYXBlIGNhbGVuZGFyIC0gMjAwOC5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA3gDjAOsCnQKfAqQCrQK4ArwCygLRAtoC3wLiAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAu8=}}

@article{Parr:ANTLR:1995,
	Address = {New York, NY, USA},
	Author = {T. J. Parr and R. W. Quong},
	Date-Added = {2008-02-10 13:49:52 -0500},
	Date-Modified = {2008-02-10 14:10:28 -0500},
	Doi = {http://dx.doi.org/10.1002/spe.4380250705},
	Issn = {0038-0644},
	Journal = {Softw. Pract. Exper.},
	Keywords = {parsing},
	Note = {Current information on ANTLR is available from \url{http://www.antlr.org/}},
	Number = {7},
	Pages = {789--810},
	Publisher = {John Wiley \& Sons, Inc.},
	Title = {{ANTLR}: {A} predicated-{LL}($k$) parser generator},
	Url = {http://www.antlr.org/article/1055550346383/antlr.pdf},
	Volume = {25},
	Year = {1995},
	Abstract = {Despite the parsing power of LR/LALR algorithms, e.g. YACC, programmers often choose to write recursive-descent parsers by hand to obtain increased flexibility, better error handling, and ease of debugging. We introduce ANTLR, a public-domain parser generator that combines the flexibility of hand-coded parsing with the convenience of a parser generator, which is a component of PCCTS. ANTLR has many features that make it easier to use than other language tools. Most important, ANTLR provides predicates which let the programmer systematically direct the parse via arbitrary expressions using semantic and syntactic context; in practice, the use of predicates eliminates the need to hand-tweak the ANTLR output, even for difficult parsing problems. ANTLR also integrates the description of lexical and syntactic analysis, accepts LL(k) grammars for k > 1 with extended BNF notation, and can automatically generate abstract syntax trees.

ANTLR is widely used, with over 1000 registered industrial and academic users in 37 countries. It has been ported to many popular systems such as the PC, Macintosh, and a variety of UNIX platforms; a commercial C++ front-end has been developed as a result of one of our industrial collaborations.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFYuLi8uLi9QYXBlcnMvUGFyci9QYXJyLVF1b25nIC0gQU5UTFI6IEEgcHJlZGljYXRlZC1MTCgkayQpIHBhcnNlciBnZW5lcmF0b3IgKDE5OTUpLnBkZtIbDxwdV05TLmRhdGFPEQIaAAAAAAIaAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAwFAQfUGFyci1RdW9uZyAtIEFOVExSLyAjMzAxM0Y1LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAT9cPUslQAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABFBhcnIAEAAIAADBNH5dAAAAEQAIAADD1PikAAAAAQAQADAUBAAtkT8AA0esAABr2AACAD1PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6UGFycjpQYXJyLVF1b25nIC0gQU5UTFIvICMzMDEzRjUucGRmAAAOAIoARABQAGEAcgByAC0AUQB1AG8AbgBnACAALQAgAEEATgBUAEwAUgAvACAAQQAgAHAAcgBlAGQAaQBjAGEAdABlAGQALQBMAEwAKAAkAGsAJAApACAAcABhAHIAcwBlAHIAIABnAGUAbgBlAHIAYQB0AG8AcgAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF1Vc2Vycy9qZXJlbXkvUGFwZXJzL1BhcnIvUGFyci1RdW9uZyAtIEFOVExSOiBBIHByZWRpY2F0ZWQtTEwoJGskKSBwYXJzZXIgZ2VuZXJhdG9yICgxOTk1KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQMBCAEQAy4DMAM1Az4DSQNNA1sDYgNrA3ADcwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOA},
	Bdsk-Url-1 = {http://dx.doi.org/10.1002/spe.4380250705},
	Bdsk-Url-2 = {http://www.antlr.org/article/1055550346383/antlr.pdf}}

@manual{Pottier:Menhir:2007,
	Author = {Pottier, Fran{\c c}ois and R{\'e}gis-Gianis, Yann},
	Date-Added = {2008-02-10 13:29:59 -0500},
	Date-Modified = {2008-02-10 14:43:37 -0500},
	Keywords = {parsing},
	Month = {December},
	Organization = {INRIA},
	Title = {Menhir Reference Manual},
	Url = {http://cristal.inria.fr/~fpottier/menhir/},
	Year = {2007},
	Bdsk-Url-1 = {http://cristal.inria.fr/~fpottier/menhir/}}

@techreport{McPeak:Elkhound:2002,
	Address = {Berkeley, California, USA},
	Author = {McPeak, Scott},
	Date-Added = {2008-02-10 12:54:30 -0500},
	Date-Modified = {2008-02-10 14:43:23 -0500},
	Institution = {University of California, Berkeley},
	Keywords = {parsing},
	Month = {December},
	Number = {UCB/CSD--2--1214},
	Title = {Elkhound: {A} Fast, Practical {GLR} Parser Generator},
	Url = {http://www.cs.berkeley.edu/~smcpeak/elkhound/},
	Year = {2002},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFguLi8uLi9QYXBlcnMvTWNQZWFrL01jUGVhayAtIEVsa2hvdW5kOiBBIEZhc3QsIFByYWN0aWNhbCBHTFIgUGFyc2VyIEdlbmVyYXRvciAoMjAwMikucGRm0hsPHB1XTlMuZGF0YU8RAiAAAAAAAiAAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADAS+B9NY1BlYWsgLSBFbGtob3VuZC8gQSMyRTdGRkQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALn/9w7BQaQAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGTWNQZWFrABAACAAAwTR+XQAAABEACAAAw7CWuQAAAAEAEAAwEvgALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOk1jUGVhazpNY1BlYWsgLSBFbGtob3VuZC8gQSMyRTdGRkQucGRmAAAOAIoARABNAGMAUABlAGEAawAgAC0AIABFAGwAawBoAG8AdQBuAGQALwAgAEEAIABGAGEAcwB0ACwAIABQAHIAYQBjAHQAaQBjAGEAbAAgAEcATABSACAAUABhAHIAcwBlAHIAIABHAGUAbgBlAHIAYQB0AG8AcgAgACgAMgAwADAAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF9Vc2Vycy9qZXJlbXkvUGFwZXJzL01jUGVhay9NY1BlYWsgLSBFbGtob3VuZDogQSBGYXN0LCBQcmFjdGljYWwgR0xSIFBhcnNlciBHZW5lcmF0b3IgKDIwMDIpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBBQEKARIDNgM4Az0DRgNRA1UDYwNqA3MDeAN7AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA4g=},
	Bdsk-Url-1 = {http://www.cs.berkeley.edu/~smcpeak/elkhound/}}

@book{Muchnick:Advanced:1997,
	Author = {Muchnick, Steven S.},
	Date-Added = {2008-02-10 11:11:29 -0500},
	Date-Modified = {2008-04-14 19:03:06 -0400},
	Isbn = {978-1-55860-320-4},
	Keywords = {compilation},
	Publisher = {Academic Press},
	Title = {Advanced Compiler Design and Implementation},
	Year = {1997}}

@book{Hopcroft:Introduction:2007,
	Author = {Hopcroft, John E. and Motwani, Rajeev and Ullman, Jeffrey D.},
	Date-Added = {2008-02-08 18:53:33 -0500},
	Date-Modified = {2008-04-14 19:02:38 -0400},
	Edition = {Third},
	Isbn = {978-0-23-146225-1},
	Month = {July},
	Publisher = {Addison-Wesley Higher Education},
	Title = {Introduction to Automata Theory, Languages, and Computation},
	Url = {http://infolab.stanford.edu/~ullman/ialc.html},
	Year = {2007},
	Bdsk-Url-1 = {http://infolab.stanford.edu/~ullman/ialc.html}}

@inproceedings{Pereira:Register:2006,
	Address = {Vienna, Austria},
	Author = {Pereira, Fernando Magno Quint{\~a}o and Palsberg, Jens},
	Booktitle = {Proceedings of FOSSACS'06},
	Date-Added = {2008-02-08 16:15:40 -0500},
	Date-Modified = {2008-02-08 16:20:12 -0500},
	Keywords = {compilation},
	Month = {March},
	Pages = {79--93},
	Publisher = {Springer-Verlag (LNCS 3921)},
	Series = {Foundations of Software Science and Computation Structures},
	Title = {Register Allocation after Classical {SSA} Elimination Is {NP}-Complete},
	Url = {http://www.cs.ucla.edu/~palsberg/paper/fossacs06.pdf},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGYuLi8uLi9QYXBlcnMvUGVyZWlyYS9QZXJlaXJhLVBhbHNiZXJnIC0gUmVnaXN0ZXIgQWxsb2NhdGlvbiBhZnRlciBDbGFzc2ljYWwgU1NBIEVsaW1pbmF0aW9uICgyMDA2KS5wZGbSGw8cHVdOUy5kYXRhTxECSgAAAAACSgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAL/JjH1BlcmVpcmEtUGFsc2JlcmcgLSBSIzJGRjIzOS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv8jnD0jAuUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdQZXJlaXJhAAAQAAgAAME0fl0AAAARAAgAAMPSdn4AAAABABAAL/JjAC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpQZXJlaXJhOlBlcmVpcmEtUGFsc2JlcmcgLSBSIzJGRjIzOS5wZGYADgCkAFEAUABlAHIAZQBpAHIAYQAtAFAAYQBsAHMAYgBlAHIAZwAgAC0AIABSAGUAZwBpAHMAdABlAHIAIABBAGwAbABvAGMAYQB0AGkAbwBuACAAYQBmAHQAZQByACAAQwBsAGEAcwBzAGkAYwBhAGwAIABTAFMAQQAgAEUAbABpAG0AaQBuAGEAdABpAG8AbgAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG1Vc2Vycy9qZXJlbXkvUGFwZXJzL1BlcmVpcmEvUGVyZWlyYS1QYWxzYmVyZyAtIFJlZ2lzdGVyIEFsbG9jYXRpb24gYWZ0ZXIgQ2xhc3NpY2FsIFNTQSBFbGltaW5hdGlvbiAoMjAwNikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgETARgBIANuA3ADdQN+A4kDjQObA6IDqwOwA7MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADwA==},
	Bdsk-Url-1 = {http://www.cs.ucla.edu/~palsberg/paper/fossacs06.pdf}}

@inproceedings{Pereira:Register:2008,
	Address = {Tucson, Arizona, USA},
	Author = {Pereira, Fernando Magno Quint{\~a}o and Palsberg, Jens},
	Booktitle = {Proceedings of PLDI'08},
	Date-Added = {2008-02-08 15:24:30 -0500},
	Date-Modified = {2008-02-08 16:14:06 -0500},
	Keywords = {compilation},
	Month = {June},
	Note = {To appear},
	Series = {ACM SIGPLAN Conference on Programming Language Design and Implementation},
	Title = {Register Allocation by Puzzle Solving},
	Url = {http://www.cs.ucla.edu/~palsberg/paper/PereiraPalsberg08.pdf},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFkuLi8uLi9QYXBlcnMvUGFsc2JlcmcvUGFsc2JlcmctUGVyZWlyYSAtIFJlZ2lzdGVyIEFsbG9jYXRpb24gYnkgUHV6emxlIFNvbHZpbmcgKDIwMDgpLnBkZtIbDxwdV05TLmRhdGFPEQIiAAAAAAIiAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAv8ZofUGFsc2JlcmctUGVyZWlyYSAtIFIjMkZGMERELnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC/w3cPSJJsAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAACFBhbHNiZXJnABAACAAAwTR+XQAAABEACAAAw9Jq6wAAAAEAEAAv8ZoALZE/AANHrAAAa9gAAgBBT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlBhbHNiZXJnOlBhbHNiZXJnLVBlcmVpcmEgLSBSIzJGRjBERC5wZGYAAA4AiABDAFAAYQBsAHMAYgBlAHIAZwAtAFAAZQByAGUAaQByAGEAIAAtACAAUgBlAGcAaQBzAHQAZQByACAAQQBsAGwAbwBjAGEAdABpAG8AbgAgAGIAeQAgAFAAdQB6AHoAbABlACAAUwBvAGwAdgBpAG4AZwAgACgAMgAwADAAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGBVc2Vycy9qZXJlbXkvUGFwZXJzL1BhbHNiZXJnL1BhbHNiZXJnLVBlcmVpcmEgLSBSZWdpc3RlciBBbGxvY2F0aW9uIGJ5IFB1enpsZSBTb2x2aW5nICgyMDA4KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBBgELARMDOQM7A0ADSQNUA1gDZgNtA3YDewN+AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA4s=},
	Bdsk-Url-1 = {http://www.cs.ucla.edu/~palsberg/paper/PereiraPalsberg08.pdf}}

@inproceedings{Hines:Using:2005,
	Address = {New York, NY, USA},
	Author = {Stephen Hines and Prasad Kulkarni and David Whalley and Jack Davidson},
	Booktitle = {EMSOFT '05: Proceedings of the 5th ACM international conference on Embedded software},
	Date-Added = {2008-02-04 20:41:39 -0500},
	Date-Modified = {2008-02-04 20:45:28 -0500},
	Doi = {http://doi.acm.org/10.1145/1086228.1086251},
	Isbn = {1-59593-091-4},
	Keywords = {optimization phase ordering},
	Location = {Jersey City, NJ, USA},
	Pages = {114--123},
	Publisher = {ACM},
	Title = {Using de-optimization to re-optimize code},
	Year = {2005},
	Abstract = {The nature of embedded systems development places a great deal of importance on meeting strict requirements in areas such as static code size, power consumption, and execution time. In order to meet these requirements, embedded developers frequently generate and tune assembly code for applications by hand, despite the disadvantages of coding at a low level. The phase ordering problem is a well-known problem affecting the design of optimizing compilers. Hand-tuned code is susceptible to an analogous problem to phase ordering due to the process of iterative refinement, but there has been little research in mitigating its effect on the quality of the generated code. This paper presents an extension of the VISTA framework for investigating the effect and potential benefit of performing de-optimization before re-optimizing assembly code. The design and implementation of algorithms for de-optimization of both loop-invariant code motion and register allocation, along with results of experiments regarding de-optimization and re-optimization of previously generated assembly code are also presented.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGAuLi8uLi9QYXBlcnMvSGluZXMvSGluZXMtS3Vsa2FybmktV2hhbGxleSAtIFVzaW5nIGRlLW9wdGltaXphdGlvbiB0byByZS1vcHRpbWl6ZSBjb2RlICgyMDA1KS5wZGbSGw8cHVdOUy5kYXRhTxECOAAAAAACOAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAL9j2H0hpbmVzLUt1bGthcm5pLVdoYWxsIzJGRDhFQy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv2OzDzSjwUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVIaW5lcwAAEAAIAADBNH5dAAAAEQAIAADDzW9AAAAAAQAQAC/Y9gAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6SGluZXM6SGluZXMtS3Vsa2FybmktV2hhbGwjMkZEOEVDLnBkZgAOAJwATQBIAGkAbgBlAHMALQBLAHUAbABrAGEAcgBuAGkALQBXAGgAYQBsAGwAZQB5ACAALQAgAFUAcwBpAG4AZwAgAGQAZQAtAG8AcAB0AGkAbQBpAHoAYQB0AGkAbwBuACAAdABvACAAcgBlAC0AbwBwAHQAaQBtAGkAegBlACAAYwBvAGQAZQAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGdVc2Vycy9qZXJlbXkvUGFwZXJzL0hpbmVzL0hpbmVzLUt1bGthcm5pLVdoYWxsZXkgLSBVc2luZyBkZS1vcHRpbWl6YXRpb24gdG8gcmUtb3B0aW1pemUgY29kZSAoMjAwNSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgENARIBGgNWA1gDXQNmA3EDdQODA4oDkwOYA5sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1086228.1086251}}

@inproceedings{Edwards:No-ifs-ands:2007,
	Address = {New York, NY, USA},
	Author = {Jonathan Edwards},
	Booktitle = {OOPSLA '07: Proceedings of the 22nd annual ACM SIGPLAN conference on Object oriented programming systems and applications},
	Date-Added = {2008-01-29 22:26:53 -0500},
	Date-Modified = {2008-01-29 22:29:55 -0500},
	Doi = {http://doi.acm.org/10.1145/1297027.1297075},
	Isbn = {978-1-59593-786-5},
	Keywords = {language design},
	Location = {Montreal, Quebec, Canada},
	Pages = {639--658},
	Publisher = {ACM},
	Title = {No ifs, ands, or buts: uncovering the simplicity of conditionals},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFouLi8uLi9QYXBlcnMvRWR3YXJkcy9FZHdhcmRzIC0gTm8gaWZzLCBhbmRzLCBvciBidXRzOiB1bmNvdmVyaW5nIHRoZSBzaW1wbGljaXR5ICgyMDA3KS5wZGbSGw8cHVdOUy5kYXRhTxECJgAAAAACJgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAL7JXH0Vkd2FyZHMgLSBObyBpZnMsIGFuIzJGQjI1Ni5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvslbDxVjPUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdFZHdhcmRzAAAQAAgAAME0fl0AAAARAAgAAMPFnx8AAAABABAAL7JXAC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpFZHdhcmRzOkVkd2FyZHMgLSBObyBpZnMsIGFuIzJGQjI1Ni5wZGYADgCMAEUARQBkAHcAYQByAGQAcwAgAC0AIABOAG8AIABpAGYAcwAsACAAYQBuAGQAcwAsACAAbwByACAAYgB1AHQAcwAvACAAdQBuAGMAbwB2AGUAcgBpAG4AZwAgAHQAaABlACAAcwBpAG0AcABsAGkAYwBpAHQAeQAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGFVc2Vycy9qZXJlbXkvUGFwZXJzL0Vkd2FyZHMvRWR3YXJkcyAtIE5vIGlmcywgYW5kcywgb3IgYnV0czogdW5jb3ZlcmluZyB0aGUgc2ltcGxpY2l0eSAoMjAwNykucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEHAQwBFAM+A0ADRQNOA1kDXQNrA3IDewOAA4MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1297027.1297075}}

@article{Pippenger:Pure:1997,
	Address = {New York, NY, USA},
	Author = {Nicholas Pippenger},
	Date-Added = {2008-01-19 10:30:22 -0500},
	Date-Modified = {2008-04-21 01:38:54 -0400},
	Doi = {http://doi.acm.org/10.1145/244795.244798},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Number = {2},
	Pages = {223--238},
	Publisher = {ACM},
	Title = {Pure versus impure Lisp},
	Volume = {19},
	Year = {1997},
	Annote = {Appears from the abstract that impure Lisp is strictly more powerful (in that it can compute faster) than pure Lisp when online operation, as in an interpreter, is required. Not sure how this affects interactive programs -- probably the same difference remains. This is where the details would come in handy....},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEUuLi8uLi9QYXBlcnMvUGlwcGVuZ2VyL1BpcHBlbmdlciAtIFB1cmUgdmVyc3VzIGltcHVyZSBMaXNwICgxOTk3KS5wZGbSGw8cHVdOUy5kYXRhTxEB5gAAAAAB5gACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALuySH1BpcHBlbmdlciAtIFB1cmUgdmVyIzJFRUM4Qy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAu7IzDt4HrUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAlQaXBwZW5nZXIAABAACAAAwTR+XQAAABEACAAAw7fIOwAAAAEAEAAu7JIALZE/AANHrAAAa9gAAgBCT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlBpcHBlbmdlcjpQaXBwZW5nZXIgLSBQdXJlIHZlciMyRUVDOEMucGRmAA4AXgAuAFAAaQBwAHAAZQBuAGcAZQByACAALQAgAFAAdQByAGUAIAB2AGUAcgBzAHUAcwAgAGkAbQBwAHUAcgBlACAATABpAHMAcAAgACgAMQA5ADkANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAExVc2Vycy9qZXJlbXkvUGFwZXJzL1BpcHBlbmdlci9QaXBwZW5nZXIgLSBQdXJlIHZlcnN1cyBpbXB1cmUgTGlzcCAoMTk5NykucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPIA9wD/AukC6wLwAvkDBAMIAxYDHQMmAysDLgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAM7},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/244795.244798}}

@article{Wadler:Lazy:1996,
	Address = {New York, NY, USA},
	Author = {Philip Wadler},
	Date-Added = {2008-01-19 10:29:44 -0500},
	Date-Modified = {2008-01-19 10:29:46 -0500},
	Doi = {http://doi.acm.org/10.1145/234528.234738},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Number = {2},
	Pages = {318--320},
	Publisher = {ACM},
	Title = {Lazy versus strict},
	Volume = {28},
	Year = {1996},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEDouLi8uLi9QYXBlcnMvV2FkbGVyL1dhZGxlciAtIExhenkgdmVyc3VzIHN0cmljdCAoMTk5NikucGRm0hsPHB1XTlMuZGF0YU8RAcYAAAAAAcYAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2ReB9XYWRsZXIgLSBMYXp5IHZlcnN1cyMyRUVDODIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALuyCw7eBzVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGV2FkbGVyABAACAAAwTR+XQAAABEACAAAw7fIHQAAAAEAEAAtkXgALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOldhZGxlcjpXYWRsZXIgLSBMYXp5IHZlcnN1cyMyRUVDODIucGRmAAAOAE4AJgBXAGEAZABsAGUAcgAgAC0AIABMAGEAegB5ACAAdgBlAHIAcwB1AHMAIABzAHQAcgBpAGMAdAAgACgAMQA5ADkANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAEFVc2Vycy9qZXJlbXkvUGFwZXJzL1dhZGxlci9XYWRsZXIgLSBMYXp5IHZlcnN1cyBzdHJpY3QgKDE5OTYpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA5wDsAPQCvgLAAsUCzgLZAt0C6wLyAvsDAAMDAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAxA=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/234528.234738}}

@inproceedings{Bravenboer:Concrete:2004,
	Address = {New York, NY, USA},
	Author = {Martin Bravenboer and Eelco Visser},
	Booktitle = {OOPSLA '04: Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications},
	Date-Added = {2008-01-19 09:34:24 -0500},
	Date-Modified = {2008-01-19 09:38:17 -0500},
	Doi = {http://doi.acm.org/10.1145/1028976.1029007},
	Isbn = {1-58113-831-9},
	Keywords = {parsing},
	Location = {Vancouver, BC, Canada},
	Pages = {365--383},
	Publisher = {ACM},
	Title = {Concrete syntax for objects: domain-specific language embedding and assimilation without restrictions},
	Year = {2004},
	Abstract = {Application programmer's interfaces give access to domain knowledge encapsulated in class libraries without providing the appropriate notation for expressing domain composition. Since object-oriented languages are designed for extensibility and reuse, the language constructs are often sufficient for expressing domain abstractions at the semantic level. However, they do not provide the right abstractions at the syntactic level. In this paper we describe MetaBorg, a method for providing <i>concrete syntax</i> for domain abstractions to application programmers. The method consists of <i>embedding</i> domain-specific languages in a general purpose host language and <i>assimilating</i> the embedded domain code into the surrounding host code. Instead of extending the implementation of the host language, the assimilation phase implements domain abstractions in terms of existing APIs leaving the host language undisturbed. Indeed, MetaBorg can be considered a method for promoting APIs to the language level. The method is supported by proven and available technology, i.e. the syntax definition formalism SDF and the program transformation language and toolset Stratego/XT. We illustrate the method with applications in three domains: code generation, XML generation, and user-interface construction.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGwuLi8uLi9QYXBlcnMvQnJhdmVuYm9lci9CcmF2ZW5ib2VyLVZpc3NlciAtIENvbmNyZXRlIHN5bnRheCBmb3Igb2JqZWN0czogZG9tYWluLXNwZWNpZmljIGxhbmd1YWdlICgyMDA0KS5wZGbSGw8cHVdOUy5kYXRhTxECXAAAAAACXAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALusHH0JyYXZlbmJvZXItVmlzc2VyIC0gIzJFRUI0NC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAu60TDt3U9UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAApCcmF2ZW5ib2VyABAACAAAwTR+XQAAABEACAAAw7e7jQAAAAEAEAAu6wcALZE/AANHrAAAa9gAAgBDT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkJyYXZlbmJvZXI6QnJhdmVuYm9lci1WaXNzZXIgLSAjMkVFQjQ0LnBkZgAADgCqAFQAQgByAGEAdgBlAG4AYgBvAGUAcgAtAFYAaQBzAHMAZQByACAALQAgAEMAbwBuAGMAcgBlAHQAZQAgAHMAeQBuAHQAYQB4ACAAZgBvAHIAIABvAGIAagBlAGMAdABzAC8AIABkAG8AbQBhAGkAbgAtAHMAcABlAGMAaQBmAGkAYwAgAGwAYQBuAGcAdQBhAGcAZQAgACgAMgAwADAANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHNVc2Vycy9qZXJlbXkvUGFwZXJzL0JyYXZlbmJvZXIvQnJhdmVuYm9lci1WaXNzZXIgLSBDb25jcmV0ZSBzeW50YXggZm9yIG9iamVjdHM6IGRvbWFpbi1zcGVjaWZpYyBsYW5ndWFnZSAoMjAwNCkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEZAR4BJgOGA4gDjQOWA6EDpQOzA7oDwwPIA8sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAD2A==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1028976.1029007}}

@inproceedings{Bravenboer:Preventing:2007,
	Address = {New York, NY, USA},
	Author = {Martin Bravenboer and Eelco Dolstra and Eelco Visser},
	Booktitle = {GPCE '07: Proceedings of the 6th international conference on Generative programming and component engineering},
	Date-Added = {2008-01-19 09:34:02 -0500},
	Date-Modified = {2008-01-19 09:38:17 -0500},
	Doi = {http://doi.acm.org/10.1145/1289971.1289975},
	Isbn = {978-1-59593-855-8},
	Keywords = {parsing},
	Location = {Salzburg, Austria},
	Pages = {3--12},
	Publisher = {ACM},
	Title = {Preventing injection attacks with syntax embeddings},
	Year = {2007},
	Abstract = {Software written in one language often needs to construct sentences in another language, such as SQL queries, XML output, or shell command invocations. This is almost always done using unhygienic string manipulation, the concatenation of constants and client-supplied strings. A client can then supply specially crafted input that causes the constructed sentence to be interpreted in an unintended way, leading to an injection attack. We describe a more natural style of programming that yields code that is impervious to injections by construction. Our approach embeds the grammars of the guest languages (e.g., SQL) into that of the host language (e.g., Java) and automatically generates code that maps the embedded language to constructs in the host language that reconstruct the embedded sentences, adding escaping functions where appropriate. This approach is generic, meaning that it can be applied with relative ease to any combination of host and guest languages.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGcuLi8uLi9QYXBlcnMvQnJhdmVuYm9lci9CcmF2ZW5ib2VyLURvbHN0cmEtVmlzc2VyIC0gUHJldmVudGluZyBpbmplY3Rpb24gYXR0YWNrcyB3aXRoIHN5bnRheCAoMjAwNykucGRm0hsPHB1XTlMuZGF0YU8RAkwAAAAAAkwAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC7rBx9CcmF2ZW5ib2VyLURvbHN0cmEtViMyRUVCM0QucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALus9w7d07FBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAKQnJhdmVuYm9lcgAQAAgAAME0fl0AAAARAAgAAMO3uzwAAAABABAALusHAC2RPwADR6wAAGvYAAIAQ09kaW46VXNlcnM6amVyZW15OlBhcGVyczpCcmF2ZW5ib2VyOkJyYXZlbmJvZXItRG9sc3RyYS1WIzJFRUIzRC5wZGYAAA4AoABPAEIAcgBhAHYAZQBuAGIAbwBlAHIALQBEAG8AbABzAHQAcgBhAC0AVgBpAHMAcwBlAHIAIAAtACAAUAByAGUAdgBlAG4AdABpAG4AZwAgAGkAbgBqAGUAYwB0AGkAbwBuACAAYQB0AHQAYQBjAGsAcwAgAHcAaQB0AGgAIABzAHkAbgB0AGEAeAAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG5Vc2Vycy9qZXJlbXkvUGFwZXJzL0JyYXZlbmJvZXIvQnJhdmVuYm9lci1Eb2xzdHJhLVZpc3NlciAtIFByZXZlbnRpbmcgaW5qZWN0aW9uIGF0dGFja3Mgd2l0aCBzeW50YXggKDIwMDcpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEUARkBIQNxA3MDeAOBA4wDkAOeA6UDrgOzA7YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADww==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1289971.1289975}}

@techreport{Bravenboer:Program:2005,
	Address = {Utrecht},
	Author = {Martin Bravenboer and Arthur van Dam and Karina Olmos and Eelco Visser},
	Date-Added = {2008-01-19 09:28:07 -0500},
	Date-Modified = {2008-01-19 13:23:20 -0500},
	Institution = {Utrecht University},
	Keywords = {parsing},
	Month = {June},
	Number = {UU-CS-2005-05},
	Title = {Program Transformation with Scoped Dynamic Rewrite Rules},
	Year = {2005},
	Annote = {Published as Bravenboer:Program:2006.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGQuLi8uLi9QYXBlcnMvQnJhdmVuYm9lci9CcmF2ZW5ib2VyLURhbS1PbG1vcyAtIFByb2dyYW0gVHJhbnNmb3JtYXRpb24gd2l0aCBTY29wZWQgRHluYW1pYyAoMjAwNSkucGRm0hsPHB1XTlMuZGF0YU8RAkQAAAAAAkQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC7rBx9CcmF2ZW5ib2VyLURhbS1PbG1vcyMyRUVBRkUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALur+w7dzH1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAKQnJhdmVuYm9lcgAQAAgAAME0fl0AAAARAAgAAMO3uW8AAAABABAALusHAC2RPwADR6wAAGvYAAIAQ09kaW46VXNlcnM6amVyZW15OlBhcGVyczpCcmF2ZW5ib2VyOkJyYXZlbmJvZXItRGFtLU9sbW9zIzJFRUFGRS5wZGYAAA4AmgBMAEIAcgBhAHYAZQBuAGIAbwBlAHIALQBEAGEAbQAtAE8AbABtAG8AcwAgAC0AIABQAHIAbwBnAHIAYQBtACAAVAByAGEAbgBzAGYAbwByAG0AYQB0AGkAbwBuACAAdwBpAHQAaAAgAFMAYwBvAHAAZQBkACAARAB5AG4AYQBtAGkAYwAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGtVc2Vycy9qZXJlbXkvUGFwZXJzL0JyYXZlbmJvZXIvQnJhdmVuYm9lci1EYW0tT2xtb3MgLSBQcm9ncmFtIFRyYW5zZm9ybWF0aW9uIHdpdGggU2NvcGVkIER5bmFtaWMgKDIwMDUpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBEQEWAR4DZgNoA20DdgOBA4UDkwOaA6MDqAOrAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA7g=}}

@inproceedings{Bravenboer:Declarative:2006,
	Address = {New York, NY, USA},
	Author = {Martin Bravenboer and \'{E}ric Tanter and Eelco Visser},
	Booktitle = {OOPSLA '06: Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications},
	Date-Added = {2008-01-19 09:25:07 -0500},
	Date-Modified = {2008-01-19 09:38:17 -0500},
	Doi = {http://doi.acm.org/10.1145/1167473.1167491},
	Isbn = {1-59593-348-4},
	Keywords = {parsing},
	Location = {Portland, Oregon, USA},
	Pages = {209--228},
	Publisher = {ACM},
	Title = {Declarative, formal, and extensible syntax definition for aspect{J}},
	Year = {2006},
	Abstract = {Aspect-Oriented Programming (AOP) is attracting attention from both research and industry, as illustrated by the ever-growing popularity of AspectJ, the de facto standard AOP extension of Java. From a compiler construction perspective AspectJ is interesting as it is a typical example of compositional language, ie a language composed of a number of separate languages with different syntactical styles: in addition to plain Java, AspectJ includes a language for defining pointcuts and one for defining advices. Language composition represents a non-trivial challenge for conventional parsing techniques. First, combining several languages with different lexical syntax leads to considerable complexity in the lexical states to processed. Second, as new language features for AOP are being explored, many research proposals are concerned with further extending the AspectJ language, resulting in a need for an extensible syntax definition.This paper shows how scannerless parsing elegantly addresses the issues encountered by conventional techniques when parsing AspectJ . We present the design of a modular, extensible, and formal definition of the lexical and context-free aspects of the AspectJ syntax in the Syntax Definition Formalism SDF, which is implemented by a scannerless, generalized-LR parser (SGLR). We introduce grammar mixins as a novel application of SDF's modularity features, which allows the declarative definition of different keyword policies and combination of extensions. We illustrate the modular extensibility of our definition with syntax extensions taken from current research on aspect languages. Finally, benchmarks show the reasonable performance of scannerless generalized-LR parsing for this grammar.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHMuLi8uLi9QYXBlcnMvQnJhdmVuYm9lci9CcmF2ZW5ib2VyLVRhbnRlci1WaXNzZXIgLSBEZWNsYXJhdGl2ZSwgZm9ybWFsLCBhbmQgZXh0ZW5zaWJsZSBzeW50YXggZGVmaW5pdGlvbiAoMjAwNikucGRm0hsPHB1XTlMuZGF0YU8RAnAAAAAAAnAAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC7rBx9CcmF2ZW5ib2VyLVRhbnRlci1WaSMyRUVCMkEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALusqw7d0slBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAKQnJhdmVuYm9lcgAQAAgAAME0fl0AAAARAAgAAMO3uwIAAAABABAALusHAC2RPwADR6wAAGvYAAIAQ09kaW46VXNlcnM6amVyZW15OlBhcGVyczpCcmF2ZW5ib2VyOkJyYXZlbmJvZXItVGFudGVyLVZpIzJFRUIyQS5wZGYAAA4AuABbAEIAcgBhAHYAZQBuAGIAbwBlAHIALQBUAGEAbgB0AGUAcgAtAFYAaQBzAHMAZQByACAALQAgAEQAZQBjAGwAYQByAGEAdABpAHYAZQAsACAAZgBvAHIAbQBhAGwALAAgAGEAbgBkACAAZQB4AHQAZQBuAHMAaQBiAGwAZQAgAHMAeQBuAHQAYQB4ACAAZABlAGYAaQBuAGkAdABpAG8AbgAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHpVc2Vycy9qZXJlbXkvUGFwZXJzL0JyYXZlbmJvZXIvQnJhdmVuYm9lci1UYW50ZXItVmlzc2VyIC0gRGVjbGFyYXRpdmUsIGZvcm1hbCwgYW5kIGV4dGVuc2libGUgc3ludGF4IGRlZmluaXRpb24gKDIwMDYpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEgASUBLQOhA6MDqAOxA7wDwAPOA9UD3gPjA+YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAD8w==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1167473.1167491}}

@article{Bravenboer:Program:2006,
	Address = {Amsterdam, The Netherlands, The Netherlands},
	Author = {Martin Bravenboer and Arthur van Dam and Karina Olmos and Eelco Visser},
	Date-Added = {2008-01-19 09:22:05 -0500},
	Date-Modified = {2008-01-19 09:38:17 -0500},
	Issn = {0169-2968},
	Journal = {Fundam. Inf.},
	Keywords = {parsing},
	Number = {1-2},
	Pages = {123--178},
	Publisher = {IOS Press},
	Title = {Program Transformation with Scoped Dynamic Rewrite Rules},
	Volume = {69},
	Year = {2006}}

@techreport{Visser:Scannerless:1997,
	Address = {Amsterdam},
	Author = {Eelco Visser},
	Date-Added = {2008-01-19 09:16:04 -0500},
	Date-Modified = {2008-01-19 09:18:59 -0500},
	Institution = {University of Amsterdam},
	Keywords = {parsing},
	Month = {July},
	Number = {P9707},
	Title = {Scannerless Generalized-LR Parsing},
	Year = {1997},
	Abstract = {Current deterministic parsing techniques have a number of problems. These include the limitations of parser generators for deterministic languages and the complex interface between scanner and parser. Scannerless parsing is a parsing technique in which lexical and context-free syntax are integrated into one grammar and are all handled by a single context-free analysis phase. This approach has a number of advantages including discarding of the scanner and lexical disambiguation by means of the context in which a lexical token occurs. Scannerless parsing generates a number of interesting problems as well. Integrated grammars do not fit the requirements of the conventional deterministic parsing techniques. A plain context-free grammar formalism leads to unwieldy grammars, if all lexical information is included. Lexical disambiguation needs to be reformulated for use in context-free parsing.

The scannerless generalized-LR parsing approach presented in this paper solves these problems. Grammar normalization is used to support an expressive grammar formalism without complicating the underlying machinery. Follow restrictions are used to express longest match lexical disambiguation. Reject productions are used to express the prefer keywords rule for lexical disambiguation. The SLR(1) parser generation algorithm is adapted to implement disambiguation by general priority and associativity declarations and to interpret follow restrictions. Generalized-LR parsing is used to provide dynamic lookahead and to support parsing of arbitrary context-free grammars including ambiguous ones. An adaptation of the GLR algorithm supports the interpretation of grammars with reject productions. },
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEouLi8uLi9QYXBlcnMvVmlzc2VyL1Zpc3NlciAtIFNjYW5uZXJsZXNzIEdlbmVyYWxpemVkLUxSIFBhcnNpbmcgKDE5OTcpLnBkZtIbDxwdV05TLmRhdGFPEQH2AAAAAAH2AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAu6sgfVmlzc2VyIC0gU2Nhbm5lcmxlc3MjMkVFQUMxLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC7qwcO3cNIAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABlZpc3NlcgAQAAgAAME0fl0AAAARAAgAAMO3tyIAAAABABAALurIAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpWaXNzZXI6Vmlzc2VyIC0gU2Nhbm5lcmxlc3MjMkVFQUMxLnBkZgAADgBuADYAVgBpAHMAcwBlAHIAIAAtACAAUwBjAGEAbgBuAGUAcgBsAGUAcwBzACAARwBlAG4AZQByAGEAbABpAHoAZQBkAC0ATABSACAAUABhAHIAcwBpAG4AZwAgACgAMQA5ADkANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFFVc2Vycy9qZXJlbXkvUGFwZXJzL1Zpc3Nlci9WaXNzZXIgLSBTY2FubmVybGVzcyBHZW5lcmFsaXplZC1MUiBQYXJzaW5nICgxOTk3KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPcA/AEEAv4DAAMFAw4DGQMdAysDMgM7A0ADQwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANQ}}

@article{Brand:Generation:1996,
	Address = {New York, NY, USA},
	Author = {van den Brand, Mark and Eelco Visser},
	Date-Added = {2008-01-19 09:12:26 -0500},
	Date-Modified = {2008-01-19 09:23:02 -0500},
	Doi = {http://doi.acm.org/10.1145/226155.226156},
	Issn = {1049-331X},
	Journal = {ACM Trans. Softw. Eng. Methodol.},
	Keywords = {parsing},
	Number = {1},
	Pages = {1--41},
	Publisher = {ACM},
	Title = {Generation of formatters for context-free languages},
	Volume = {5},
	Year = {1996},
	Abstract = {Good documentation is important for the production of reusable and maintainable software. For the production of accurate documentation it is necessary that the original program text is not copied manually to obtain a typeset version. Apart from being tedious, this will invariably introduce errors. The production of tools that support the production of legible and accurate documentation is a software engineering challenge in itself. We present an algebraic approach to the generation of tools that produce typographically effective presentations of computer programs. A specification of a formatter is generated from the context-free grammar of a (programming) language. These generated formatters translate abstract syntax trees of programs into box expressions. Box expressions are translated by language-independent interpreters of the box language into ASCII or TEX. The formatting rules that are generated can easily be tuned in order to get the desired formatting of programs. We demonstrate this by means of real-life applications. Furthermore, we give a practical solution for the problem of formatting comments, which occur in the original text. The formatter generation approach proposed in this article can be used to generate formatting programs for arbitrary programming environments. Our formatter generation approach can be used to automatically generate formatters that have to be programmed explicitly in other systems.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGAuLi8uLi9QYXBlcnMvQnJhbmQvQnJhbmQtVmlzc2VyIC0gR2VuZXJhdGlvbiBvZiBmb3JtYXR0ZXJzIGZvciBjb250ZXh0LWZyZWUgbGFuZ3VhZ2VzICgxOTk2KS5wZGbSGw8cHVdOUy5kYXRhTxECOAAAAAACOAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALupwH0JyYW5kLVZpc3NlciAtIEdlbmVyIzJFRUFEOS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAu6tnDt3HQUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVCcmFuZAAAEAAIAADBNH5dAAAAEQAIAADDt7ggAAAAAQAQAC7qcAAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QnJhbmQ6QnJhbmQtVmlzc2VyIC0gR2VuZXIjMkVFQUQ5LnBkZgAOAJwATQBCAHIAYQBuAGQALQBWAGkAcwBzAGUAcgAgAC0AIABHAGUAbgBlAHIAYQB0AGkAbwBuACAAbwBmACAAZgBvAHIAbQBhAHQAdABlAHIAcwAgAGYAbwByACAAYwBvAG4AdABlAHgAdAAtAGYAcgBlAGUAIABsAGEAbgBnAHUAYQBnAGUAcwAgACgAMQA5ADkANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGdVc2Vycy9qZXJlbXkvUGFwZXJzL0JyYW5kL0JyYW5kLVZpc3NlciAtIEdlbmVyYXRpb24gb2YgZm9ybWF0dGVycyBmb3IgY29udGV4dC1mcmVlIGxhbmd1YWdlcyAoMTk5NikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgENARIBGgNWA1gDXQNmA3EDdQODA4oDkwOYA5sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/226155.226156}}

@inproceedings{Brand:Disambiguation:2002,
	Address = {London, UK},
	Author = {Mark G. J. van den Brand and Jeroen Scheerder and Jurgen J. Vinju and Eelco Visser},
	Booktitle = {CC '02: Proceedings of the 11th International Conference on Compiler Construction},
	Date-Added = {2008-01-19 09:08:40 -0500},
	Date-Modified = {2008-01-19 09:10:25 -0500},
	Isbn = {3-540-43369-4},
	Keywords = {parsing},
	Pages = {143--158},
	Publisher = {Springer-Verlag},
	Title = {Disambiguation Filters for Scannerless Generalized LR Parsers},
	Year = {2002},
	Abstract = {In this paper we present the fusion of generalized LR parsing and scannerless parsing. This combination supports syntax definitions in which all aspects (lexical and context-free) of the syntax of a language are defined explicitly in one formalism. Furthermore, there are no restrictions on the class of grammars, thus allowing a natural syntax tree structure. Ambiguities that arise through the use of unrestricted grammars are handled by explicit disambiguation constructs, instead of implicit defaults that are taken by traditional scanner and parser generators. Hence, a syntax definition becomes a full declarative description of a language. Scannerless generalized LR parsing is a viable technique that has been applied in various industrial and academic projects.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHMuLi8uLi9QYXBlcnMvQnJhbmQvQnJhbmQtU2NoZWVyZGVyLVZpbmp1IC0gRGlzYW1iaWd1YXRpb24gRmlsdGVycyBmb3IgU2Nhbm5lcmxlc3MgR2VuZXJhbGl6ZWQgTFIgUGFyc2VycyAoMjAwMikucGRm0hsPHB1XTlMuZGF0YU8RAnAAAAAAAnAAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC7qcB9CcmFuZC1TY2hlZXJkZXItVmluaiMyRUVBNkEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALupqw7dv11BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAFQnJhbmQAABAACAAAwTR+XQAAABEACAAAw7e2JwAAAAEAEAAu6nAALZE/AANHrAAAa9gAAgA+T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkJyYW5kOkJyYW5kLVNjaGVlcmRlci1WaW5qIzJFRUE2QS5wZGYADgDCAGAAQgByAGEAbgBkAC0AUwBjAGgAZQBlAHIAZABlAHIALQBWAGkAbgBqAHUAIAAtACAARABpAHMAYQBtAGIAaQBnAHUAYQB0AGkAbwBuACAARgBpAGwAdABlAHIAcwAgAGYAbwByACAAUwBjAGEAbgBuAGUAcgBsAGUAcwBzACAARwBlAG4AZQByAGEAbABpAHoAZQBkACAATABSACAAUABhAHIAcwBlAHIAcwAgACgAMgAwADAAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHpVc2Vycy9qZXJlbXkvUGFwZXJzL0JyYW5kL0JyYW5kLVNjaGVlcmRlci1WaW5qdSAtIERpc2FtYmlndWF0aW9uIEZpbHRlcnMgZm9yIFNjYW5uZXJsZXNzIEdlbmVyYWxpemVkIExSIFBhcnNlcnMgKDIwMDIpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEgASUBLQOhA6MDqAOxA7wDwAPOA9UD3gPjA+YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAD8w==}}

@inproceedings{Soisalon-Soininen:Elimination:1977,
	Address = {New York, NY, USA},
	Author = {Eljas Soisalon-Soininen},
	Booktitle = {POPL '77: Proceedings of the 4th ACM SIGACT-SIGPLAN symposium on Principles of programming languages},
	Date-Added = {2008-01-17 22:28:17 -0500},
	Date-Modified = {2008-01-17 22:29:10 -0500},
	Doi = {http://doi.acm.org/10.1145/512950.512967},
	Location = {Los Angeles, California},
	Pages = {183--193},
	Publisher = {ACM},
	Title = {Elimination of single productions from LR parsers in conjunction with the use of default reductions},
	Year = {1977},
	Abstract = {The problem in the use of default reductions in conjunction with the elimination of reductions by single productions is discussed in Pager[1973a] and a method is given there to solve the problem. The basis of the solution is to apply first the algorithm for eliminating reductions by single productions and then to check every potential default reduction in order to decide whether it can be used or not. Hence, in the optimized parser all reductions by single productions are eliminated, but the use of default reductions can be limited. (Pager [1973a] has found that in the case of some practical grammars almost all of potential default reductions can be used.)

In the present paper we consider another approach to the problem. In our method the elimination process itself corresponds to the technique of Pager[1973a,1974], but the elimination is carried out only if it does not affect the applicability of default reductions. The main motivation of this approach is the fact that it leads to a method for eliminating reductions by single productions which is applicable for any type of LR parser, including LALR parsers and generalizations of them.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEG8uLi8uLi9QYXBlcnMvU29pc2Fsb24tU29pbmluZW4vU29pc2Fsb24tU29pbmluZW4gLSBFbGltaW5hdGlvbiBvZiBzaW5nbGUgcHJvZHVjdGlvbnMgZnJvbSBMUiBwYXJzZXJzICgxOTc3KS5wZGbSGw8cHVdOUy5kYXRhTxECZAAAAAACZAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALuIZH1NvaXNhbG9uLVNvaW5pbmVuIC0gIzJFRTIxOC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAu4hjDtYiaUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAABFTb2lzYWxvbi1Tb2luaW5lbgAAEAAIAADBNH5dAAAAEQAIAADDtc7qAAAAAQAQAC7iGQAtkT8AA0esAABr2AACAEpPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6U29pc2Fsb24tU29pbmluZW46U29pc2Fsb24tU29pbmluZW4gLSAjMkVFMjE4LnBkZgAOAKIAUABTAG8AaQBzAGEAbABvAG4ALQBTAG8AaQBuAGkAbgBlAG4AIAAtACAARQBsAGkAbQBpAG4AYQB0AGkAbwBuACAAbwBmACAAcwBpAG4AZwBsAGUAIABwAHIAbwBkAHUAYwB0AGkAbwBuAHMAIABmAHIAbwBtACAATABSACAAcABhAHIAcwBlAHIAcwAgACgAMQA5ADcANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHZVc2Vycy9qZXJlbXkvUGFwZXJzL1NvaXNhbG9uLVNvaW5pbmVuL1NvaXNhbG9uLVNvaW5pbmVuIC0gRWxpbWluYXRpb24gb2Ygc2luZ2xlIHByb2R1Y3Rpb25zIGZyb20gTFIgcGFyc2VycyAoMTk3NykucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARwBIQEpA5EDkwOYA6EDrAOwA74DxQPOA9MD1gAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAPj},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/512950.512967}}

@article{Aycock:Even:2001,
	Address = {Secaucus, NJ, USA},
	Author = {John Aycock and Nigel Horspool and Jan Janou\v{s}ek and Bo\v{r}ivoj Melichar},
	Date-Added = {2008-01-17 22:17:11 -0500},
	Date-Modified = {2008-01-17 22:19:40 -0500},
	Doi = {http://dx.doi.org/10.1007/PL00013319},
	Issn = {0001-5903},
	Journal = {Acta Inf.},
	Keywords = {parsing},
	Number = {9},
	Pages = {633--651},
	Publisher = {Springer-Verlag New York, Inc.},
	Title = {Even faster generalized LR parsing},
	Volume = {37},
	Year = {2001},
	Abstract = {We prove a property of generalized LR (GLR) parsing -- if the grammar is without right and hidden left recursions, then the number of consecutive reductions between the shifts of two adjacent symbols cannot be greater than a constant. Further, we show that this property can be used for constructing an optimized version of our GLR parser. Compared with a standard GLR parser, our optimized parser reads one symbol on every transition and performs significantly fewer stack operations. Our timings show that, especially for highly ambiguous grammars, our parser is significantly faster than a standard GLR parser.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFwuLi8uLi9QYXBlcnMvQXljb2NrL0F5Y29jay1Ib3JzcG9vbC1KYW5vdXNlayAtIEV2ZW4gZmFzdGVyIGdlbmVyYWxpemVkIExSIHBhcnNpbmcgKDIwMDEpLnBkZtIbDxwdV05TLmRhdGFPEQIsAAAAAAIsAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAugkAfQXljb2NrLUhvcnNwb29sLUphbm8jMkVFMTk1LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC7hlcO1hHhQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABkF5Y29jawAQAAgAAME0fl0AAAARAAgAAMO1ysgAAAABABAALoJAAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpBeWNvY2s6QXljb2NrLUhvcnNwb29sLUphbm8jMkVFMTk1LnBkZgAADgCSAEgAQQB5AGMAbwBjAGsALQBIAG8AcgBzAHAAbwBvAGwALQBKAGEAbgBvAHUAcwBlAGsAIAAtACAARQB2AGUAbgAgAGYAYQBzAHQAZQByACAAZwBlAG4AZQByAGEAbABpAHoAZQBkACAATABSACAAcABhAHIAcwBpAG4AZwAgACgAMgAwADAAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGNVc2Vycy9qZXJlbXkvUGFwZXJzL0F5Y29jay9BeWNvY2stSG9yc3Bvb2wtSmFub3VzZWsgLSBFdmVuIGZhc3RlciBnZW5lcmFsaXplZCBMUiBwYXJzaW5nICgyMDAxKS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQkBDgEWA0YDSANNA1YDYQNlA3MDegODA4gDiwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOY},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/PL00013319}}

@article{Horspool:Even:1990,
	Address = {New York, NY, USA},
	Author = {R. N. Horspool and M. Whitney},
	Date-Added = {2008-01-17 22:12:22 -0500},
	Date-Modified = {2008-01-17 22:13:09 -0500},
	Doi = {http://dx.doi.org/10.1002/spe.4380200602},
	Issn = {0038-0644},
	Journal = {Softw. Pract. Exper.},
	Keywords = {parsing},
	Number = {6},
	Pages = {515--535},
	Publisher = {John Wiley \& Sons, Inc.},
	Title = {Even faster LR parsing},
	Volume = {20},
	Year = {1990},
	Abstract = {Conventional LR parser generators create tables which are used to drive a standard parser procedure. Much faster parsers can be obtained by compiling the table entries into code that is directly executed. A possible drawback with a directly executable parser is its large size. In this paper, we introduce optimization techniques that increase the parsing speed even further while simultaneously reducing the size of the parser.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEouLi8uLi9QYXBlcnMvSG9yc3Bvb2wvSG9yc3Bvb2wtV2hpdG5leSAtIEV2ZW4gZmFzdGVyIExSIHBhcnNpbmcgKDE5OTApLnBkZtIbDxwdV05TLmRhdGFPEQH2AAAAAAH2AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAu4W8fSG9yc3Bvb2wtV2hpdG5leSAtIEUjMkVFMEI1LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC7gtcO1gBFQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAACEhvcnNwb29sABAACAAAwTR+XQAAABEACAAAw7XGYQAAAAEAEAAu4W8ALZE/AANHrAAAa9gAAgBBT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkhvcnNwb29sOkhvcnNwb29sLVdoaXRuZXkgLSBFIzJFRTBCNS5wZGYAAA4AagA0AEgAbwByAHMAcABvAG8AbAAtAFcAaABpAHQAbgBlAHkAIAAtACAARQB2AGUAbgAgAGYAYQBzAHQAZQByACAATABSACAAcABhAHIAcwBpAG4AZwAgACgAMQA5ADkAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFFVc2Vycy9qZXJlbXkvUGFwZXJzL0hvcnNwb29sL0hvcnNwb29sLVdoaXRuZXkgLSBFdmVuIGZhc3RlciBMUiBwYXJzaW5nICgxOTkwKS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPcA/AEEAv4DAAMFAw4DGQMdAysDMgM7A0ADQwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANQ},
	Bdsk-Url-1 = {http://dx.doi.org/10.1002/spe.4380200602}}

@article{Bhamidipaty:Very:1998,
	Address = {New York, NY, USA},
	Author = {Achyutram Bhamidipaty and Todd A. Proebsting},
	Date-Added = {2008-01-17 22:10:11 -0500},
	Date-Modified = {2008-01-17 22:13:47 -0500},
	Doi = {http://dx.doi.org/10.1002/(SICI)1097-024X(199802)28:2<181::AID-SPE139>3.3.CO;2-W},
	Issn = {0038-0644},
	Journal = {Softw. Pract. Exper.},
	Keywords = {parsing},
	Number = {2},
	Pages = {181--190},
	Publisher = {John Wiley \& Sons, Inc.},
	Title = {Very fast YACC-compatible parsers (for very little effort)},
	Volume = {28},
	Year = {1998},
	Abstract = {We have developed a yacc-compatible parser generator that creates parsers that are 2.0 to 6.0 times faster than those generated by yacc or bison. Our tool, mule, creates directly-executable, hard-coded parsers in ANSI; yacc produces interpreted, table-driven parsers. Two attributes distinguish mule from other parser generators that create hard-coded LR parsers; mule is compatible wtih yacc (including yacc's peculiar error recovery mechanisms), and mule does absolutely none of the complex automata analysis of previous hard-coded-parser generators. Mule creates simple, fast parsers after very little analysis.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGMuLi8uLi9QYXBlcnMvQmhhbWlkaXBhdHkvQmhhbWlkaXBhdHktUHJvZWJzdGluZyAtIFZlcnkgZmFzdCBZQUNDLWNvbXBhdGlibGUgcGFyc2VycyAoZm9yICgxOTk4KS5wZGbSGw8cHVdOUy5kYXRhTxECQAAAAAACQAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALuEWH0JoYW1pZGlwYXR5LVByb2Vic3RpIzJFRTBGQy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAu4PzDtYH0UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAtCaGFtaWRpcGF0eQAAEAAIAADBNH5dAAAAEQAIAADDtchEAAAAAQAQAC7hFgAtkT8AA0esAABr2AACAERPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QmhhbWlkaXBhdHk6QmhhbWlkaXBhdHktUHJvZWJzdGkjMkVFMEZDLnBkZgAOAJYASgBCAGgAYQBtAGkAZABpAHAAYQB0AHkALQBQAHIAbwBlAGIAcwB0AGkAbgBnACAALQAgAFYAZQByAHkAIABmAGEAcwB0ACAAWQBBAEMAQwAtAGMAbwBtAHAAYQB0AGkAYgBsAGUAIABwAGEAcgBzAGUAcgBzACAAKABmAG8AcgAgACgAMQA5ADkAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGpVc2Vycy9qZXJlbXkvUGFwZXJzL0JoYW1pZGlwYXR5L0JoYW1pZGlwYXR5LVByb2Vic3RpbmcgLSBWZXJ5IGZhc3QgWUFDQy1jb21wYXRpYmxlIHBhcnNlcnMgKGZvciAoMTk5OCkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARABFQEdA2EDYwNoA3EDfAOAA44DlQOeA6MDpgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOz},
	Bdsk-Url-1 = {http://dx.doi.org/10.1002/(SICI)1097-024X(199802)28:2%3C181::AID-SPE139%3E3.3.CO;2-W}}

@article{DeRemer:Efficient:1982,
	Address = {New York, NY, USA},
	Author = {Frank DeRemer and Thomas Pennello},
	Date-Added = {2008-01-17 21:50:13 -0500},
	Date-Modified = {2008-01-17 22:14:07 -0500},
	Doi = {http://doi.acm.org/10.1145/69622.357187},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Keywords = {parsing},
	Number = {4},
	Pages = {615--649},
	Publisher = {ACM},
	Title = {Efficient Computation of LALR(1) Look-Ahead Sets},
	Volume = {4},
	Year = {1982},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGMuLi8uLi9QYXBlcnMvRGVSZW1lci9EZVJlbWVyLVBlbm5lbGxvIC0gRWZmaWNpZW50IENvbXB1dGF0aW9uIG9mIExBTFIoMSkgTG9vay1BaGVhZCBTZXRzICgxOTgyKS5wZGbSGw8cHVdOUy5kYXRhTxECQAAAAAACQAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALuB1H0RlUmVtZXItUGVubmVsbG8gLSBFIzJFRTAyMS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAu4CHDtX5mUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdEZVJlbWVyAAAQAAgAAME0fl0AAAARAAgAAMO1xLYAAAABABAALuB1AC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpEZVJlbWVyOkRlUmVtZXItUGVubmVsbG8gLSBFIzJFRTAyMS5wZGYADgCeAE4ARABlAFIAZQBtAGUAcgAtAFAAZQBuAG4AZQBsAGwAbwAgAC0AIABFAGYAZgBpAGMAaQBlAG4AdAAgAEMAbwBtAHAAdQB0AGEAdABpAG8AbgAgAG8AZgAgAEwAQQBMAFIAKAAxACkAIABMAG8AbwBrAC0AQQBoAGUAYQBkACAAUwBlAHQAcwAgACgAMQA5ADgAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGpVc2Vycy9qZXJlbXkvUGFwZXJzL0RlUmVtZXIvRGVSZW1lci1QZW5uZWxsbyAtIEVmZmljaWVudCBDb21wdXRhdGlvbiBvZiBMQUxSKDEpIExvb2stQWhlYWQgU2V0cyAoMTk4MikucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARABFQEdA2EDYwNoA3EDfAOAA44DlQOeA6MDpgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOz},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/69622.357187}}

@inproceedings{Tan:iComment:2007,
	Address = {New York, NY, USA},
	Author = {Lin Tan and Ding Yuan and Gopal Krishna and Yuanyuan Zhou},
	Booktitle = {SOSP '07: Proceedings of twenty-first ACM SIGOPS symposium on Operating systems principles},
	Date-Added = {2008-01-14 01:46:49 -0500},
	Date-Modified = {2008-01-14 01:50:26 -0500},
	Doi = {http://doi.acm.org/10.1145/1294261.1294276},
	Isbn = {978-1-59593-591-5},
	Local-Url = {file://localhost/Users/jeremy/Papers/Tan/Tan-Yuan-Krishna%20-%20-*i%7BC%7Domment%20Bugs%20or%20Bad%20Comments%3F*-%20(2007).pdf},
	Location = {Stevenson, Washington, USA},
	Pages = {145--158},
	Publisher = {ACM},
	Title = {/*i{C}omment: Bugs or Bad Comments?*/},
	Year = {2007},
	Abstract = {Commenting source code has long been a common practice in software development. Compared to source code, comments are more direct, descriptive and easy-to-understand. Comments and sourcecode provide relatively redundant and independent information regarding a program's semantic behavior. As software evolves, they can easily grow out-of-sync, indicating two problems: (1) bugs -the source code does not follow the assumptions and requirements specified by correct program comments; (2) bad comments - comments that are inconsistent with correct code, which can confuse and mislead programmers to introduce bugs in subsequent versions. Unfortunately, as most comments are written in natural language, no solution has been proposed to automatically analyze commentsand detect inconsistencies between comments and source code. This paper takes the first step in automatically analyzing commentswritten in natural language to extract implicit program rulesand use these rules to automatically detect inconsistencies between comments and source code, indicating either bugs or bad comments. Our solution, iComment, combines Natural Language Processing(NLP), Machine Learning, Statistics and Program Analysis techniques to achieve these goals. We evaluate iComment on four large code bases: Linux, Mozilla, Wine and Apache. Our experimental results show that iComment automatically extracts 1832 rules from comments with 90.8-100% accuracy and detects 60 comment-code inconsistencies, 33 newbugs and 27 bad comments, in the latest versions of the four programs. Nineteen of them (12 bugs and 7 bad comments) have already been confirmed by the corresponding developers while the others are currently being analyzed by the developers.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFMuLi8uLi9QYXBlcnMvVGFuL1Rhbi1ZdWFuLUtyaXNobmEgLSAtKml7Q31vbW1lbnQgQnVncyBvciBCYWQgQ29tbWVudHM/Ki0gKDIwMDcpLnBkZtIbDxwdV05TLmRhdGFPEQIQAAAAAAIQAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAugwsfVGFuLVl1YW4tS3Jpc2huYSAtIC0jMkU4MzA5LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC6DCcOwcDFQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAA1RhbgAAEAAIAADBNH5dAAAAEQAIAADDsLaBAAAAAQAQAC6DCwAtkT8AA0esAABr2AACADxPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6VGFuOlRhbi1ZdWFuLUtyaXNobmEgLSAtIzJFODMwOS5wZGYADgCGAEIAVABhAG4ALQBZAHUAYQBuAC0ASwByAGkAcwBoAG4AYQAgAC0AIAAtACoAaQB7AEMAfQBvAG0AbQBlAG4AdAAgAEIAdQBnAHMAIABvAHIAIABCAGEAZAAgAEMAbwBtAG0AZQBuAHQAcwA/ACoALQAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFpVc2Vycy9qZXJlbXkvUGFwZXJzL1Rhbi9UYW4tWXVhbi1LcmlzaG5hIC0gLSppe0N9b21tZW50IEJ1Z3Mgb3IgQmFkIENvbW1lbnRzPyotICgyMDA3KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBAAEFAQ0DIQMjAygDMQM8A0ADTgNVA14DYwNmAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA3M=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1294261.1294276}}

@inproceedings{Minsky:Caml:2008,
	Address = {New York, NY, USA},
	Author = {Yaron M. Minsky},
	Booktitle = {POPL '08: Proceedings of the 35th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
	Date-Added = {2008-01-14 01:45:40 -0500},
	Date-Modified = {2008-01-14 01:51:48 -0500},
	Doi = {http://doi.acm.org/10.1145/1328438.1328441},
	Isbn = {978-1-59593-689-9},
	Keywords = {functional languages},
	Local-Url = {file://localhost/Users/jeremy/Papers/Minsky/Minsky%20-%20Caml%20trading%20(2008).pdf},
	Location = {San Francisco, California, USA},
	Pages = {285--285},
	Publisher = {ACM},
	Title = {Caml trading},
	Year = {2008},
	Abstract = {Jane Street Capital is a successful proprietary trading company that has shifted from developing software in mainstream programming languages to developing software almost entirely in OCaml, a statically typed functional programming language that has only modest industrial use. The scope of the enterprise is small but growing: Jane Street now has over 20 OCaml programmers that have collectively written hundreds of thousands of lines of OCaml code. OCaml is used for building everything from trading systems to research infrastructure to user interfaces to systems administration tools. This talk will discuss the motivations behind Jane Street's adoption of OCaml, and why we think that statically typed functional programming languages are such a good fit for the world of trading and finance.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEDQuLi8uLi9QYXBlcnMvTWluc2t5L01pbnNreSAtIENhbWwgdHJhZGluZyAoMjAwOCkucGRm0hsPHB1XTlMuZGF0YU8RAbQAAAAAAbQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC6DBB9NaW5za3kgLSBDYW1sIHRyYWRpbiMyRTgzMDIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALoMCw7BwClBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGTWluc2t5ABAACAAAwTR+XQAAABEACAAAw7C2WgAAAAEAEAAugwQALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOk1pbnNreTpNaW5za3kgLSBDYW1sIHRyYWRpbiMyRTgzMDIucGRmAAAOAEIAIABNAGkAbgBzAGsAeQAgAC0AIABDAGEAbQBsACAAdAByAGEAZABpAG4AZwAgACgAMgAwADAAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASADtVc2Vycy9qZXJlbXkvUGFwZXJzL01pbnNreS9NaW5za3kgLSBDYW1sIHRyYWRpbmcgKDIwMDgpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA4QDmAO4CpgKoAq0CtgLBAsUC0wLaAuMC6ALrAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAvg=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1328438.1328441}}

@article{Abadi:Just:2007,
	Address = {New York, NY, USA},
	Author = {Mart\'{\i}n Abadi and Bruno Blanchet and C\'{e}dric Fournet},
	Date-Added = {2008-01-14 01:44:39 -0500},
	Date-Modified = {2008-01-14 01:48:44 -0500},
	Doi = {http://doi.acm.org/10.1145/1266977.1266978},
	Issn = {1094-9224},
	Journal = {ACM Trans. Inf. Syst. Secur.},
	Local-Url = {file://localhost/Users/jeremy/Papers/Abadi/Abadi-Blanchet-Fournet%20-%20Just%20fast%20keying%20in%20the%20pi%20calculus%20(2007).pdf},
	Number = {3},
	Pages = {9},
	Publisher = {ACM},
	Title = {Just fast keying in the pi calculus},
	Volume = {10},
	Year = {2007},
	Abstract = {JFK is a recent, attractive protocol for fast key establishment as part of securing IP communication. In this paper, we formally analyze this protocol in the applied pi calculus (partly in terms of observational equivalences and partly with the assistance of an automatic protocol verifier). We treat JFK's core security properties and also other properties that are rarely articulated and rigorously studied, such as plausible deniability and resistance to denial-of-service attacks. In the course of this analysis, we found some ambiguities and minor problems, such as limitations in identity protection, but we mostly obtain positive results about JFK. For this purpose, we develop ideas and techniques that should be more generally useful in the specification and verification of security protocols.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFouLi8uLi9QYXBlcnMvQWJhZGkvQWJhZGktQmxhbmNoZXQtRm91cm5ldCAtIEp1c3QgZmFzdCBrZXlpbmcgaW4gdGhlIHBpIGNhbGN1bHVzICgyMDA3KS5wZGbSGw8cHVdOUy5kYXRhTxECJgAAAAACJgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALoL+H0FiYWRpLUJsYW5jaGV0LUZvdXJuIzJFODJGQi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAugvvDsG/mUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVBYmFkaQAAEAAIAADBNH5dAAAAEQAIAADDsLY2AAAAAQAQAC6C/gAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QWJhZGk6QWJhZGktQmxhbmNoZXQtRm91cm4jMkU4MkZCLnBkZgAOAJAARwBBAGIAYQBkAGkALQBCAGwAYQBuAGMAaABlAHQALQBGAG8AdQByAG4AZQB0ACAALQAgAEoAdQBzAHQAIABmAGEAcwB0ACAAawBlAHkAaQBuAGcAIABpAG4AIAB0AGgAZQAgAHAAaQAgAGMAYQBsAGMAdQBsAHUAcwAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGFVc2Vycy9qZXJlbXkvUGFwZXJzL0FiYWRpL0FiYWRpLUJsYW5jaGV0LUZvdXJuZXQgLSBKdXN0IGZhc3Qga2V5aW5nIGluIHRoZSBwaSBjYWxjdWx1cyAoMjAwNykucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEHAQwBFAM+A0ADRQNOA1kDXQNrA3IDewOAA4MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1266977.1266978}}

@inproceedings{Renieris:Almost::1999,
	Address = {New York, NY, USA},
	Author = {Manos Renieris and Steven P. Reiss},
	Booktitle = {NPIVM '99: Proceedings of the 1999 workshop on new paradigms in information visualization and manipulation in conjunction with the eighth ACM internation conference on Information and knowledge management},
	Date-Added = {2008-01-14 01:43:28 -0500},
	Date-Modified = {2008-01-14 01:51:32 -0500},
	Doi = {http://doi.acm.org/10.1145/331770.331788},
	Isbn = {1-58113-254-9},
	Keywords = {optimization},
	Local-Url = {file://localhost/Users/jeremy/Papers/Renieris/Renieris-Reiss%20-%20Almost%20exploring%20program%20traces%20(1999).pdf},
	Location = {Kansas City, Missouri, United States},
	Pages = {70--77},
	Publisher = {ACM},
	Title = {Almost: exploring program traces},
	Year = {1999},
	Abstract = {We built a tool to visualize and explore program execution traces. Our goal was to help programmers without any prior knowledge of a program, quickly get enough knowledge about its structure so that they can make small to medium changes. In the process, a number of problems were faced and tackled concerning the efficient use of screen space, interaction with multiple concurrent views, and linking of asymmetric views.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFEuLi8uLi9QYXBlcnMvUmVuaWVyaXMvUmVuaWVyaXMtUmVpc3MgLSBBbG1vc3QgZXhwbG9yaW5nIHByb2dyYW0gdHJhY2VzICgxOTk5KS5wZGbSGw8cHVdOUy5kYXRhTxECCgAAAAACCgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALoLyH1JlbmllcmlzLVJlaXNzIC0gQWxtIzJFODJGMC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAugvDDsG9vUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAhSZW5pZXJpcwAQAAgAAME0fl0AAAARAAgAAMOwtb8AAAABABAALoLyAC2RPwADR6wAAGvYAAIAQU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpSZW5pZXJpczpSZW5pZXJpcy1SZWlzcyAtIEFsbSMyRTgyRjAucGRmAAAOAHgAOwBSAGUAbgBpAGUAcgBpAHMALQBSAGUAaQBzAHMAIAAtACAAQQBsAG0AbwBzAHQAIABlAHgAcABsAG8AcgBpAG4AZwAgAHAAcgBvAGcAcgBhAG0AIAB0AHIAYQBjAGUAcwAgACgAMQA5ADkAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFhVc2Vycy9qZXJlbXkvUGFwZXJzL1JlbmllcmlzL1JlbmllcmlzLVJlaXNzIC0gQWxtb3N0IGV4cGxvcmluZyBwcm9ncmFtIHRyYWNlcyAoMTk5OSkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAP4BAwELAxkDGwMgAykDNAM4A0YDTQNWA1sDXgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANr},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/331770.331788}}

@article{Mernik:When:2005,
	Address = {New York, NY, USA},
	Author = {Marjan Mernik and Jan Heering and Anthony M. Sloane},
	Date-Added = {2008-01-14 01:32:38 -0500},
	Date-Modified = {2008-01-14 01:36:28 -0500},
	Doi = {http://doi.acm.org/10.1145/1118890.1118892},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Keywords = {dsls, language design},
	Local-Url = {file://localhost/Users/jeremy/Papers/Mernik/Mernik-Heering-Sloane%20-%20When%20and%20how%20to%20develop%20domain-specific%20languages%20(2005).pdf},
	Number = {4},
	Pages = {316--344},
	Publisher = {ACM},
	Title = {When and how to develop domain-specific languages},
	Volume = {37},
	Year = {2005},
	Abstract = {Domain-specific languages (DSLs) are languages tailored to a specific application domain. They offer substantial gains in expressiveness and ease of use compared with general-purpose programming languages in their domain of application. DSL development is hard, requiring both domain knowledge and language development expertise. Few people have both. Not surprisingly, the decision to develop a DSL is often postponed indefinitely, if considered at all, and most DSLs never get beyond the application library stage.Although many articles have been written on the development of particular DSLs, there is very limited literature on DSL development methodologies and many questions remain regarding when and how to develop a DSL. To aid the DSL developer, we identify patterns in the decision, analysis, design, and implementation phases of DSL development. Our patterns improve and extend earlier work on DSL design patterns. We also discuss domain analysis tools and language development systems that may help to speed up DSL development. Finally, we present a number of open problems.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGguLi8uLi9QYXBlcnMvTWVybmlrL01lcm5pay1IZWVyaW5nLVNsb2FuZSAtIFdoZW4gYW5kIGhvdyB0byBkZXZlbG9wIGRvbWFpbi1zcGVjaWZpYyBsYW5ndWFnZXMgKDIwMDUpLnBkZtIbDxwdV05TLmRhdGFPEQJQAAAAAAJQAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAugtcfTWVybmlrLUhlZXJpbmctU2xvYW4jMkU4MkQ1LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC6C1cOwbQNQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABk1lcm5pawAQAAgAAME0fl0AAAARAAgAAMOws1MAAAABABAALoLXAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpNZXJuaWs6TWVybmlrLUhlZXJpbmctU2xvYW4jMkU4MkQ1LnBkZgAADgCqAFQATQBlAHIAbgBpAGsALQBIAGUAZQByAGkAbgBnAC0AUwBsAG8AYQBuAGUAIAAtACAAVwBoAGUAbgAgAGEAbgBkACAAaABvAHcAIAB0AG8AIABkAGUAdgBlAGwAbwBwACAAZABvAG0AYQBpAG4ALQBzAHAAZQBjAGkAZgBpAGMAIABsAGEAbgBnAHUAYQBnAGUAcwAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG9Vc2Vycy9qZXJlbXkvUGFwZXJzL01lcm5pay9NZXJuaWstSGVlcmluZy1TbG9hbmUgLSBXaGVuIGFuZCBob3cgdG8gZGV2ZWxvcCBkb21haW4tc3BlY2lmaWMgbGFuZ3VhZ2VzICgyMDA1KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARUBGgEiA3YDeAN9A4YDkQOVA6MDqgOzA7gDuwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAPI},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1118890.1118892}}

@article{Kelleher:Lowering:2005,
	Address = {New York, NY, USA},
	Author = {Caitlin Kelleher and Randy Pausch},
	Date-Added = {2008-01-14 01:31:01 -0500},
	Date-Modified = {2008-01-14 01:35:13 -0500},
	Doi = {http://doi.acm.org/10.1145/1089733.1089734},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Local-Url = {file://localhost/Users/jeremy/Papers/Kelleher/Kelleher-Pausch%20-%20Lowering%20the%20barriers%20to%20programming%20A%20taxonomy%20of%20programming%20(2005).pdf},
	Number = {2},
	Pages = {83--137},
	Publisher = {ACM},
	Title = {Lowering the barriers to programming: A taxonomy of programming environments and languages for novice programmers},
	Volume = {37},
	Year = {2005},
	Abstract = {Since the early 1960's, researchers have built a number of programming languages and environments with the intention of making programming accessible to a larger number of people. This article presents a taxonomy of languages and environments designed to make programming more accessible to novice programmers of all ages. The systems are organized by their primary goal, either to teach programming or to use programming to empower their users, and then, by each system's authors' approach, to making learning to program easier for novice programmers. The article explains all categories in the taxonomy, provides a brief description of the systems in each category, and suggests some avenues for future work in novice programming environments and languages.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHEuLi8uLi9QYXBlcnMvS2VsbGVoZXIvS2VsbGVoZXItUGF1c2NoIC0gTG93ZXJpbmcgdGhlIGJhcnJpZXJzIHRvIHByb2dyYW1taW5nIEEgdGF4b25vbXkgb2YgcHJvZ3JhbW1pbmcgKDIwMDUpLnBkZtIbDxwdV05TLmRhdGFPEQJqAAAAAAJqAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAugtAfS2VsbGVoZXItUGF1c2NoIC0gTG8jMkU4MkNGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC6Cz8OwbMRQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAACEtlbGxlaGVyABAACAAAwTR+XQAAABEACAAAw7CzFAAAAAEAEAAugtAALZE/AANHrAAAa9gAAgBBT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOktlbGxlaGVyOktlbGxlaGVyLVBhdXNjaCAtIExvIzJFODJDRi5wZGYAAA4AuABbAEsAZQBsAGwAZQBoAGUAcgAtAFAAYQB1AHMAYwBoACAALQAgAEwAbwB3AGUAcgBpAG4AZwAgAHQAaABlACAAYgBhAHIAcgBpAGUAcgBzACAAdABvACAAcAByAG8AZwByAGEAbQBtAGkAbgBnACAAQQAgAHQAYQB4AG8AbgBvAG0AeQAgAG8AZgAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHhVc2Vycy9qZXJlbXkvUGFwZXJzL0tlbGxlaGVyL0tlbGxlaGVyLVBhdXNjaCAtIExvd2VyaW5nIHRoZSBiYXJyaWVycyB0byBwcm9ncmFtbWluZyBBIHRheG9ub215IG9mIHByb2dyYW1taW5nICgyMDA1KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBHgEjASsDmQObA6ADqQO0A7gDxgPNA9YD2wPeAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA+s=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1089733.1089734}}

@article{Black:Object-oriented:,
	Address = {New York, NY, USA},
	Author = {A. P. Black},
	Date-Added = {2008-01-14 01:28:14 -0500},
	Date-Modified = {2008-01-14 01:30:00 -0500},
	Doi = {http://doi.acm.org/10.1145/242224.242414},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Keywords = {monads, object-oriented languages},
	Local-Url = {file://localhost/Users/jeremy/Papers/Black/Black%20-%20Object-oriented%20languages%20the%20next%20generation%20(1996).pdf},
	Month = {December},
	Number = {4},
	Pages = {149},
	Publisher = {ACM},
	Title = {Object-oriented languages: the next generation},
	Volume = {28},
	Year = {1996},
	Abstract = {This position paper outlines some important future directions for object-oriented programming languages. It was prepared as input to the object-oriented programming working group of the Workshop on Strategic Directions in Computing. It highlights the influence of Distribution, User-orientation, Monads, Types and Higher-Order programming on Object-Oriented languages.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFMuLi8uLi9QYXBlcnMvQmxhY2svQmxhY2sgLSBPYmplY3Qtb3JpZW50ZWQgbGFuZ3VhZ2VzIHRoZSBuZXh0IGdlbmVyYXRpb24gKDE5OTYpLnBkZtIbDxwdV05TLmRhdGFPEQIQAAAAAAIQAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAugrMfQmxhY2sgLSBPYmplY3Qtb3JpZW4jMkU4MkFGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC6Cr8OwaxMAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABUJsYWNrAAAQAAgAAME0fl0AAAARAAgAAMOwsWMAAAABABAALoKzAC2RPwADR6wAAGvYAAIAPk9kaW46VXNlcnM6amVyZW15OlBhcGVyczpCbGFjazpCbGFjayAtIE9iamVjdC1vcmllbiMyRTgyQUYucGRmAA4AggBAAEIAbABhAGMAawAgAC0AIABPAGIAagBlAGMAdAAtAG8AcgBpAGUAbgB0AGUAZAAgAGwAYQBuAGcAdQBhAGcAZQBzACAAdABoAGUAIABuAGUAeAB0ACAAZwBlAG4AZQByAGEAdABpAG8AbgAgACgAMQA5ADkANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFpVc2Vycy9qZXJlbXkvUGFwZXJzL0JsYWNrL0JsYWNrIC0gT2JqZWN0LW9yaWVudGVkIGxhbmd1YWdlcyB0aGUgbmV4dCBnZW5lcmF0aW9uICgxOTk2KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBAAEFAQ0DIQMjAygDMQM8A0ADTgNVA14DYwNmAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA3M=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/242224.242414}}

@article{Beszedes:Survey:2003,
	Address = {New York, NY, USA},
	Author = {\'{A}rp\'{a}d Besz\'{e}des and Rudolf Ferenc and Tibor Gyim\'{o}thy and Andr\'{e} Dolenc and Konsta Karsisto},
	Date-Added = {2008-01-14 01:22:42 -0500},
	Date-Modified = {2008-01-14 01:23:59 -0500},
	Doi = {http://doi.acm.org/10.1145/937503.937504},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Keywords = {optimization},
	Local-Url = {file://localhost/Users/jeremy/Papers/Beszedes/Beszedes-Ferenc-Gyimothy%20-%20Survey%20of%20code-size%20reduction%20methods%20(2003).pdf},
	Number = {3},
	Pages = {223--267},
	Publisher = {ACM},
	Title = {Survey of code-size reduction methods},
	Volume = {35},
	Year = {2003},
	Abstract = {Program code compression is an emerging research activity that is having an impact in several production areas such as networking and embedded systems. This is because the reduced-sized code can have a positive impact on network traffic and embedded system costs such as memory requirements and power consumption. Although code-size reduction is a relatively new research area, numerous publications already exist on it. The methods published usually have different motivations and a variety of application contexts. They may use different principles and their publications often use diverse notations. To our knowledge, there are no publications that present a good overview of this broad range of methods and give a useful assessment. This article surveys twelve methods and several related works appearing in some 50 papers published up to now. We provide extensive assessment criteria for evaluating the methods and offer a basis for comparison. We conclude that it is fairly hard to make any fair comparisons of the methods or draw conclusions about their applicability.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGEuLi8uLi9QYXBlcnMvQmVzemVkZXMvQmVzemVkZXMtRmVyZW5jLUd5aW1vdGh5IC0gU3VydmV5IG9mIGNvZGUtc2l6ZSByZWR1Y3Rpb24gbWV0aG9kcyAoMjAwMykucGRm0hsPHB1XTlMuZGF0YU8RAjoAAAAAAjoAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC6Cgh9CZXN6ZWRlcy1GZXJlbmMtR3lpbSMyRTgyN0YucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALoJ/w7BqGlBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIQmVzemVkZXMAEAAIAADBNH5dAAAAEQAIAADDsLBqAAAAAQAQAC6CggAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QmVzemVkZXM6QmVzemVkZXMtRmVyZW5jLUd5aW0jMkU4MjdGLnBkZgAADgCYAEsAQgBlAHMAegBlAGQAZQBzAC0ARgBlAHIAZQBuAGMALQBHAHkAaQBtAG8AdABoAHkAIAAtACAAUwB1AHIAdgBlAHkAIABvAGYAIABjAG8AZABlAC0AcwBpAHoAZQAgAHIAZQBkAHUAYwB0AGkAbwBuACAAbQBlAHQAaABvAGQAcwAgACgAMgAwADAAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGhVc2Vycy9qZXJlbXkvUGFwZXJzL0Jlc3plZGVzL0Jlc3plZGVzLUZlcmVuYy1HeWltb3RoeSAtIFN1cnZleSBvZiBjb2RlLXNpemUgcmVkdWN0aW9uIG1ldGhvZHMgKDIwMDMpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEOARMBGwNZA1sDYANpA3QDeAOGA40DlgObA54AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/937503.937504}}

@article{Aycock:A-brief:2003,
	Address = {New York, NY, USA},
	Author = {John Aycock},
	Date-Added = {2008-01-14 01:15:44 -0500},
	Date-Modified = {2008-04-21 01:37:03 -0400},
	Doi = {http://doi.acm.org/10.1145/857076.857077},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Keywords = {compilation; history of computing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Aycock/Aycock%20-%20A%20brief%20history%20of%20just-in-time%20(2003).pdf},
	Number = {2},
	Pages = {97--113},
	Publisher = {ACM},
	Title = {A brief history of just-in-time},
	Volume = {35},
	Year = {2003},
	Abstract = {Software systems have been using "just-in-time" compilation (JIT) techniques since the 1960s. Broadly, JIT compilation includes any translation performed dynamically, after a program has started execution. We examine the motivation behind JIT compilation and constraints imposed on JIT compilation systems, and present a classification scheme for such systems. This classification emerges as we survey forty years of JIT work, from 1960--2000.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEcuLi8uLi9QYXBlcnMvQXljb2NrL0F5Y29jayAtIEEgYnJpZWYgaGlzdG9yeSBvZiBqdXN0LWluLXRpbWUgKDIwMDMpLnBkZtIbDxwdV05TLmRhdGFPEQHsAAAAAAHsAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAugkAfQXljb2NrIC0gQSBicmllZiBoaXMjMkU4MjNGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC6CP8OwaG9QREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABkF5Y29jawAQAAgAAME0fl0AAAARAAgAAMOwrr8AAAABABAALoJAAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpBeWNvY2s6QXljb2NrIC0gQSBicmllZiBoaXMjMkU4MjNGLnBkZgAADgBoADMAQQB5AGMAbwBjAGsAIAAtACAAQQAgAGIAcgBpAGUAZgAgAGgAaQBzAHQAbwByAHkAIABvAGYAIABqAHUAcwB0AC0AaQBuAC0AdABpAG0AZQAgACgAMgAwADAAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAE5Vc2Vycy9qZXJlbXkvUGFwZXJzL0F5Y29jay9BeWNvY2sgLSBBIGJyaWVmIGhpc3Rvcnkgb2YganVzdC1pbi10aW1lICgyMDAzKS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA9AD5AQEC8QLzAvgDAQMMAxADHgMlAy4DMwM2AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA0M=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/857076.857077}}

@article{Spector:Efficient:1988,
	Address = {New York, NY, USA},
	Author = {D. Spector},
	Date-Added = {2008-01-14 01:10:52 -0500},
	Date-Modified = {2008-01-17 21:19:51 -0500},
	Doi = {http://doi.acm.org/10.1145/57669.57684},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Keywords = {parsing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Spector/Spector%20-%20Efficient%20full%20LR(I)%20parser%20generation%20(1988).pdf},
	Number = {12},
	Pages = {143--150},
	Publisher = {ACM},
	Rating = {4},
	Read = {Yes},
	Title = {Efficient full LR(I) parser generation},
	Volume = {23},
	Year = {1988},
	Abstract = {This paper proposes that full LR(1) parser generators are easier to use than the LALR(1) parser generators commonly in use, and that minimal-state full LR(1) tables are not much larger than LALR(1) tables. A method is presented for the automatic construction of minimal-state full LR(1) parser tables. The method is fast and accurate because it starts with the LR(0) table and resolves lookahead ambiguities as necessary by tracing the LR(0) table and splitting the minimum number of states, and because there is no need for generalized set manipulation.},
	Annote = {Spector clearly explains in one page what Pager spent ten pages being confusing about. Basically: Generate an LR(0) parser, throw in one token of lookahead, zero in on inadequate states, and split them to reflect the left context that suffices to disambiguate them. Spector includes output from a parser generator he wrote that employs this technique.

Spector also gives a good, concise argument for why LR(1) parser generators are better than LALR(1). His arguments against LALR(1) parser generators are still valid twenty years later.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFAuLi8uLi9QYXBlcnMvU3BlY3Rvci9TcGVjdG9yIC0gRWZmaWNpZW50IGZ1bGwgTFIoSSkgcGFyc2VyIGdlbmVyYXRpb24gKDE5ODgpLnBkZtIbDxwdV05TLmRhdGFPEQIIAAAAAAIIAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAugiMfU3BlY3RvciAtIEVmZmljaWVudCAjMkU4MjE3LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC6CF8OwZuVQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAB1NwZWN0b3IAABAACAAAwTR+XQAAABEACAAAw7CtNQAAAAEAEAAugiMALZE/AANHrAAAa9gAAgBAT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlNwZWN0b3I6U3BlY3RvciAtIEVmZmljaWVudCAjMkU4MjE3LnBkZgAOAHgAOwBTAHAAZQBjAHQAbwByACAALQAgAEUAZgBmAGkAYwBpAGUAbgB0ACAAZgB1AGwAbAAgAEwAUgAoAEkAKQAgAHAAYQByAHMAZQByACAAZwBlAG4AZQByAGEAdABpAG8AbgAgACgAMQA5ADgAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFdVc2Vycy9qZXJlbXkvUGFwZXJzL1NwZWN0b3IvU3BlY3RvciAtIEVmZmljaWVudCBmdWxsIExSKEkpIHBhcnNlciBnZW5lcmF0aW9uICgxOTg4KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAP0BAgEKAxYDGAMdAyYDMQM1A0MDSgNTA1gDWwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANo},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/57669.57684}}

@article{Appel:SSA-is-functional:1998,
	Address = {New York, NY, USA},
	Author = {Andrew W. Appel},
	Date-Added = {2007-12-23 01:26:18 -0500},
	Date-Modified = {2008-01-14 01:39:56 -0500},
	Doi = {http://doi.acm.org/10.1145/278283.278285},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Keywords = {functional languages, intermediate representations},
	Local-Url = {file://localhost/Users/jeremy/Papers/Appel/Appel%20-%20SSA%20is%20functional%20programming%20(1998).pdf},
	Number = {4},
	Pages = {17--20},
	Publisher = {ACM},
	Title = {SSA is functional programming},
	Volume = {33},
	Year = {1998},
	Abstract = {Static Single-Assignment (SSA) form is an intermediate language designed to make optimization clean and efficient for imperative-language (Fortran, C) compilers. Lambda-calculus is an intermediate language that makes optimization clean and efficient for functional-language (Scheme, ML, Haskell) compilers. The SSA community draws pictures of graphs with basic blocks and flow edges, and the functional-language community writes lexically nested functions, but (as Richard Kelsey recently pointed out [9]) they're both doing exactly the same thing in different notation.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEMuLi8uLi9QYXBlcnMvQXBwZWwvQXBwZWwgLSBTU0EgaXMgZnVuY3Rpb25hbCBwcm9ncmFtbWluZyAoMTk5OCkucGRm0hsPHB1XTlMuZGF0YU8RAeAAAAAAAeAAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2aGx9BcHBlbCAtIFNTQSBpcyBmdW5jdCMyRDlBMTgucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZoYw5Npx1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAFQXBwZWwAABAACAAAwTR+XQAAABEACAAAw5OwFwAAAAEAEAAtmhsALZE/AANHrAAAa9gAAgA+T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkFwcGVsOkFwcGVsIC0gU1NBIGlzIGZ1bmN0IzJEOUExOC5wZGYADgBiADAAQQBwAHAAZQBsACAALQAgAFMAUwBBACAAaQBzACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMQA5ADkAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAEpVc2Vycy9qZXJlbXkvUGFwZXJzL0FwcGVsL0FwcGVsIC0gU1NBIGlzIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgKDE5OTgpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgDwAPUA/QLhAuMC6ALxAvwDAAMOAxUDHgMjAyYAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADMw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/278283.278285}}

@article{Ball:Paths:1999,
	Address = {New York, NY, USA},
	Author = {Thomas Ball},
	Date-Added = {2007-12-23 01:23:34 -0500},
	Date-Modified = {2008-01-14 01:39:32 -0500},
	Doi = {http://doi.acm.org/10.1145/307903.307910},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Keywords = {functional languages, imperative languages},
	Local-Url = {file://localhost/Users/jeremy/Papers/Ball/Ball%20-%20Paths%20between%20imperative%20and%20functional%20programming%20(1999).pdf},
	Number = {2},
	Pages = {21--25},
	Publisher = {ACM},
	Title = {Paths between imperative and functional programming},
	Volume = {34},
	Year = {1999},
	Abstract = {This article explores relationships between imperative and functional programming by viewing a program as a set of paths. We argue, through a small case study, that the presence of infeasible (or unexecutable) paths makes programs harder to understand. We identify two main causes of infeasible paths, "unnecessary" sequencing and destructive update, hallmarks of an imperative programming style. Functional programming eschews sequencing and destructive update, which can result in programs with fewer infeasible paths that are easier to understand. No proofs are included. We intend to provoke discussion regarding imperative and functional programming styles.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFcuLi8uLi9QYXBlcnMvQmFsbC9CYWxsIC0gUGF0aHMgYmV0d2VlbiBpbXBlcmF0aXZlIGFuZCBmdW5jdGlvbmFsIHByb2dyYW1taW5nICgxOTk5KS5wZGbSGw8cHVdOUy5kYXRhTxECHAAAAAACHAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZoSH0JhbGwgLSBQYXRocyBiZXR3ZWVuIzJEOUEwRC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtmg3Dk2mfUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAARCYWxsABAACAAAwTR+XQAAABEACAAAw5Ov7wAAAAEAEAAtmhIALZE/AANHrAAAa9gAAgA9T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkJhbGw6QmFsbCAtIFBhdGhzIGJldHdlZW4jMkQ5QTBELnBkZgAADgCMAEUAQgBhAGwAbAAgAC0AIABQAGEAdABoAHMAIABiAGUAdAB3AGUAZQBuACAAaQBtAHAAZQByAGEAdABpAHYAZQAgAGEAbgBkACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMQA5ADkAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF5Vc2Vycy9qZXJlbXkvUGFwZXJzL0JhbGwvQmFsbCAtIFBhdGhzIGJldHdlZW4gaW1wZXJhdGl2ZSBhbmQgZnVuY3Rpb25hbCBwcm9ncmFtbWluZyAoMTk5OSkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQQBCQERAzEDMwM4A0EDTANQA14DZQNuA3MDdgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOD},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/307903.307910}}

@inproceedings{Thiemann:Unboxed:1995,
	Address = {New York, NY, USA},
	Author = {Peter J. Thiemann},
	Booktitle = {FPCA '95: Proceedings of the seventh international conference on Functional programming languages and computer architecture},
	Date-Added = {2007-12-22 21:40:38 -0500},
	Date-Modified = {2007-12-22 21:40:58 -0500},
	Doi = {http://doi.acm.org/10.1145/224164.224175},
	Isbn = {0-89791-719-7},
	Keywords = {compilation, unboxing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Thiemann/Thiemann%20-%20Unboxed%20values%20and%20polymorphic%20typing%20revisited%20(1995).pdf},
	Location = {La Jolla, California, United States},
	Pages = {24--35},
	Publisher = {ACM},
	Title = {Unboxed values and polymorphic typing revisited},
	Year = {1995},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFsuLi8uLi9QYXBlcnMvVGhpZW1hbm4vVGhpZW1hbm4gLSBVbmJveGVkIHZhbHVlcyBhbmQgcG9seW1vcnBoaWMgdHlwaW5nIHJldmlzaXRlZCAoMTk5NSkucGRm0hsPHB1XTlMuZGF0YU8RAigAAAAAAigAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2UhB9UaGllbWFubiAtIFVuYm94ZWQgdiMyRDk0ODAucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZSAw5M0x1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIVGhpZW1hbm4AEAAIAADBNH5dAAAAEQAIAADDk3sXAAAAAQAQAC2UhAAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6VGhpZW1hbm46VGhpZW1hbm4gLSBVbmJveGVkIHYjMkQ5NDgwLnBkZgAADgCMAEUAVABoAGkAZQBtAGEAbgBuACAALQAgAFUAbgBiAG8AeABlAGQAIAB2AGEAbAB1AGUAcwAgAGEAbgBkACAAcABvAGwAeQBtAG8AcgBwAGgAaQBjACAAdAB5AHAAaQBuAGcAIAByAGUAdgBpAHMAaQB0AGUAZAAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGJVc2Vycy9qZXJlbXkvUGFwZXJzL1RoaWVtYW5uL1RoaWVtYW5uIC0gVW5ib3hlZCB2YWx1ZXMgYW5kIHBvbHltb3JwaGljIHR5cGluZyByZXZpc2l0ZWQgKDE5OTUpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEIAQ0BFQNBA0MDSANRA1wDYANuA3UDfgODA4YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/224164.224175}}

@inproceedings{Shao:A-type-based:1995,
	Address = {New York, NY, USA},
	Author = {Zhong Shao and Andrew W. Appel},
	Booktitle = {PLDI '95: Proceedings of the ACM SIGPLAN 1995 conference on Programming language design and implementation},
	Date-Added = {2007-12-22 21:36:46 -0500},
	Date-Modified = {2008-01-02 18:49:53 -0500},
	Doi = {http://doi.acm.org/10.1145/207110.207123},
	Isbn = {0-89791-697-2},
	Keywords = {history of computing, compilation},
	Local-Url = {file://localhost/Users/jeremy/Papers/Shao/Shao-Appel%20-%20A%20type-based%20compiler%20for%20standard%20ML%20(1995).pdf},
	Location = {La Jolla, California, United States},
	Pages = {116--129},
	Publisher = {ACM},
	Read = {Yes},
	Title = {A type-based compiler for standard ML},
	Year = {1995},
	Abstract = {Compile-time type information should be valuable in efficient compilation of statically typed functional languages such as Standard ML. But how should type-directed compilation work in real compilers, and how much performance gain will type-based optimizations yield? In order to support more efficient data representations and gain more experience about type-directed compilation, we have implemented a new type-based middle end and back end for the Standard ML of New Jersey compiler. We describe the basic design of the new compiler, identify a number of practical issues, and then compare the performance of our new compiler with the old non-type-based compiler. Our measurement shows that a combination of several simple type-based optimizations reduces heap allocation by 36%; and improves the already-efficient code generated by the old non-type-based compiler by about 19% on a DECstation 500.},
	Annote = {I'll need to reread this one. It's pretty dense. The conclusion sheds a lot of light on why they're bothering with this, but a lot of the story seems tied up in Appel's book "Compiling with Continuations" and its development of CPS as an intermediate representation.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE8uLi8uLi9QYXBlcnMvU2hhby9TaGFvLUFwcGVsIC0gQSB0eXBlLWJhc2VkIGNvbXBpbGVyIGZvciBzdGFuZGFyZCBNTCAoMTk5NSkucGRm0hsPHB1XTlMuZGF0YU8RAgQAAAAAAgQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2UbR9TaGFvLUFwcGVsIC0gQSB0eXBlLSMyRDk0NkIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZRrw5M0GVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAEU2hhbwAQAAgAAME0fl0AAAARAAgAAMOTemkAAAABABAALZRtAC2RPwADR6wAAGvYAAIAPU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpTaGFvOlNoYW8tQXBwZWwgLSBBIHR5cGUtIzJEOTQ2Qi5wZGYAAA4AfAA9AFMAaABhAG8ALQBBAHAAcABlAGwAIAAtACAAQQAgAHQAeQBwAGUALQBiAGEAcwBlAGQAIABjAG8AbQBwAGkAbABlAHIAIABmAG8AcgAgAHMAdABhAG4AZABhAHIAZAAgAE0ATAAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFZVc2Vycy9qZXJlbXkvUGFwZXJzL1NoYW8vU2hhby1BcHBlbCAtIEEgdHlwZS1iYXNlZCBjb21waWxlciBmb3Igc3RhbmRhcmQgTUwgKDE5OTUpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD8AQEBCQMRAxMDGAMhAywDMAM+A0UDTgNTA1YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADYw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/207110.207123}}

@article{Fradet:Compilation:1991,
	Address = {New York, NY, USA},
	Author = {Pascal Fradet and Daniel Le M\'{e}tayer},
	Date-Added = {2007-12-22 21:11:18 -0500},
	Date-Modified = {2008-04-26 19:59:57 -0400},
	Doi = {http://doi.acm.org/10.1145/114005.102805},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Keywords = {compilation; abstract machines},
	Local-Url = {file://localhost/Users/jeremy/Papers/Fradet/Fradet-Metayer%20-%20Compilation%20of%20functional%20languages%20by%20program%20transformation%20(1991).pdf},
	Number = {1},
	Pages = {21--51},
	Publisher = {ACM},
	Title = {Compilation of functional languages by program transformation},
	Volume = {13},
	Year = {1991},
	Abstract = {One of the most important issues concerning functional languages is the efficiency and the correctness of their implementation. We focus on sequential implementations for conventional von Neumann computers. The compilation process is described in terms of program transformations in the functional framework. The original functional expression is transformed into a functional term that can be seen as a traditional machine code. The two main steps are the compilation of the computation rule by the introduction of continuation functions and the compilation of the environment management using combinators. The advantage of this approach is that we do not have to introduce an abstract machine, which makes correctness proofs much simpler. As far as efficiency is concerned, this approach is promising since many optimizations can be described and formally justified in the functional framework.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEG0uLi8uLi9QYXBlcnMvRnJhZGV0L0ZyYWRldC1NZXRheWVyIC0gQ29tcGlsYXRpb24gb2YgZnVuY3Rpb25hbCBsYW5ndWFnZXMgYnkgcHJvZ3JhbSB0cmFuc2Zvcm1hdGlvbiAoMTk5MSkucGRm0hsPHB1XTlMuZGF0YU8RAl4AAAAAAl4AAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2UDx9GcmFkZXQtTWV0YXllciAtIENvbSMyRDk0MEQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZQNw5MuQVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGRnJhZGV0ABAACAAAwTR+XQAAABEACAAAw5N0kQAAAAEAEAAtlA8ALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkZyYWRldDpGcmFkZXQtTWV0YXllciAtIENvbSMyRDk0MEQucGRmAAAOALQAWQBGAHIAYQBkAGUAdAAtAE0AZQB0AGEAeQBlAHIAIAAtACAAQwBvAG0AcABpAGwAYQB0AGkAbwBuACAAbwBmACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgAGwAYQBuAGcAdQBhAGcAZQBzACAAYgB5ACAAcAByAG8AZwByAGEAbQAgAHQAcgBhAG4AcwBmAG8AcgBtAGEAdABpAG8AbgAgACgAMQA5ADkAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHRVc2Vycy9qZXJlbXkvUGFwZXJzL0ZyYWRldC9GcmFkZXQtTWV0YXllciAtIENvbXBpbGF0aW9uIG9mIGZ1bmN0aW9uYWwgbGFuZ3VhZ2VzIGJ5IHByb2dyYW0gdHJhbnNmb3JtYXRpb24gKDE5OTEpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEaAR8BJwOJA4sDkAOZA6QDqAO2A70DxgPLA84AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAD2w==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/114005.102805}}

@article{Kulkarni:Fast:2005,
	Address = {New York, NY, USA},
	Author = {Prasad A. Kulkarni and Stephen R. Hines and David B. Whalley and Jason D. Hiser and Jack W. Davidson and Douglas L. Jones},
	Date-Added = {2007-12-22 21:09:24 -0500},
	Date-Modified = {2007-12-22 21:10:19 -0500},
	Doi = {http://doi.acm.org/10.1145/1071604.1071607},
	Issn = {1544-3566},
	Journal = {ACM Trans. Archit. Code Optim.},
	Keywords = {optimization phase ordering},
	Local-Url = {file://localhost/Users/jeremy/Papers/Kulkarni/Kulkarni-Hines-Whalley%20-%20Fast%20and%20efficient%20searches%20for%20effective%20optimization-phase%20(2005).pdf},
	Number = {2},
	Pages = {165--198},
	Publisher = {ACM},
	Title = {Fast and efficient searches for effective optimization-phase sequences},
	Volume = {2},
	Year = {2005},
	Abstract = {It has long been known that a fixed ordering of optimization phases will not produce the best code for every application. One approach for addressing this phase-ordering problem is to use an evolutionary algorithm to search for a specific sequence of phases for each module or function. While such searches have been shown to produce more efficient code, the approach can be extremely slow because the application is compiled and possibly executed to evaluate each sequence's effectiveness. Consequently, evolutionary or iterative compilation schemes have been promoted for compilation systems targeting embedded applications where meeting strict constraints on execution time, code size, and power consumption is paramount and longer compilation times may be tolerated in the final stage of development, when an application is compiled one last time and embedded in a product. Unfortunately, even for small embedded applications, the search process can take many hours or even days making the approach less attractive to developers. In this paper, we describe two complementary general approaches for achieving faster searches for effective optimization sequences when using a genetic algorithm. The first approach reduces the search time by avoiding unnecessary executions of the application when possible. Results indicate search time reductions of 62%;, on average, often reducing searches from hours to minutes. The second approach modifies the search so fewer generations are required to achieve the same results. Measurements show this approach decreases the average number of required generations by 59%. These improvements have the potential for making evolutionary compilation a viable choice for tuning embedded applications.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHYuLi8uLi9QYXBlcnMvS3Vsa2FybmkvS3Vsa2FybmktSGluZXMtV2hhbGxleSAtIEZhc3QgYW5kIGVmZmljaWVudCBzZWFyY2hlcyBmb3IgZWZmZWN0aXZlIG9wdGltaXphdGlvbi1waGFzZSAoMjAwNSkucGRm0hsPHB1XTlMuZGF0YU8RAnoAAAAAAnoAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2T8h9LdWxrYXJuaS1IaW5lcy1XaGFsbCMyRDkzRkIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZP7w5MtkFBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIS3Vsa2FybmkAEAAIAADBNH5dAAAAEQAIAADDk3PgAAAAAQAQAC2T8gAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6S3Vsa2Fybmk6S3Vsa2FybmktSGluZXMtV2hhbGwjMkQ5M0ZCLnBkZgAADgDCAGAASwB1AGwAawBhAHIAbgBpAC0ASABpAG4AZQBzAC0AVwBoAGEAbABsAGUAeQAgAC0AIABGAGEAcwB0ACAAYQBuAGQAIABlAGYAZgBpAGMAaQBlAG4AdAAgAHMAZQBhAHIAYwBoAGUAcwAgAGYAbwByACAAZQBmAGYAZQBjAHQAaQB2AGUAIABvAHAAdABpAG0AaQB6AGEAdABpAG8AbgAtAHAAaABhAHMAZQAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAH1Vc2Vycy9qZXJlbXkvUGFwZXJzL0t1bGthcm5pL0t1bGthcm5pLUhpbmVzLVdoYWxsZXkgLSBGYXN0IGFuZCBlZmZpY2llbnQgc2VhcmNoZXMgZm9yIGVmZmVjdGl2ZSBvcHRpbWl6YXRpb24tcGhhc2UgKDIwMDUpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBIwEoATADrgOwA7UDvgPJA80D2wPiA+sD8APzAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAABAA=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1071604.1071607}}

@inproceedings{Kulkarni:In-search:2006,
	Address = {New York, NY, USA},
	Author = {Prasad A. Kulkarni and David B. Whalley and Gary S. Tyson and Jack W. Davidson},
	Booktitle = {LCTES '06: Proceedings of the 2006 ACM SIGPLAN/SIGBED conference on Language, compilers, and tool support for embedded systems},
	Date-Added = {2007-12-22 21:07:56 -0500},
	Date-Modified = {2007-12-22 21:08:57 -0500},
	Doi = {http://doi.acm.org/10.1145/1134650.1134663},
	Isbn = {1-59593-362-X},
	Keywords = {optimization phase ordering},
	Local-Url = {file://localhost/Users/jeremy/Papers/Kulkarni/Kulkarni-Whalley-Tyson%20-%20In%20search%20of%20near-optimal%20optimization%20phase%20orderings%20(2006).pdf},
	Location = {Ottawa, Ontario, Canada},
	Pages = {83--92},
	Publisher = {ACM},
	Title = {In search of near-optimal optimization phase orderings},
	Year = {2006},
	Abstract = {Phase ordering is a long standing challenge for traditional optimizing compilers. Varying the order of applying optimization phases to a program can produce different code, with potentially significant performance variation amongst them. A key insight to addressing the phase ordering problem is that many different optimization sequences produce the same code. In an earlier study, we used this observation to restate the phase ordering problem to concentrate on finding all distinct function instances that can be produced due to different phase orderings, instead of attempting to generate code for all possible optimization sequences. Using a novel search algorithm we were able to show that it is possible to exhaustively enumerate the set of all possible function instances that can be produced by different phase orderings in our compiler for most of the functions in our benchmark suite [1]. Finding the optimal function instance within this set for almost any dynamic measure of performance still appears impractical since that would involve execution/simulation of all generated function instances. To find the dynamically optimal function instance we exploit the observation that the enumeration space for a function typically contains a very small number of distinct control flow paths. We simulate only one function instance from each group of function instances having the identical control flow, and use that information to estimate the dynamic performance of the remaining functions in that group. We further show that the estimated dynamic frequency counts obtained by using our method correlate extremely well to simulated processor cycle counts. Thus, by using our measure of dynamic frequencies to identify a small number of the best performing function instances we can often find the optimal phase ordering for a function within a reasonable amount of time. Finally, we perform a case study to evaluate how adept our genetic algorithm is for finding optimal phase orderings within our compiler, and demonstrate how the algorithm can be improved.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHAuLi8uLi9QYXBlcnMvS3Vsa2FybmkvS3Vsa2FybmktV2hhbGxleS1UeXNvbiAtIEluIHNlYXJjaCBvZiBuZWFyLW9wdGltYWwgb3B0aW1pemF0aW9uIHBoYXNlIG9yZGVyaW5ncyAoMjAwNikucGRm0hsPHB1XTlMuZGF0YU8RAmgAAAAAAmgAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2T8h9LdWxrYXJuaS1XaGFsbGV5LVR5cyMyRDkzRUUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZPuw5MtVlBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIS3Vsa2FybmkAEAAIAADBNH5dAAAAEQAIAADDk3OmAAAAAQAQAC2T8gAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6S3Vsa2Fybmk6S3Vsa2FybmktV2hhbGxleS1UeXMjMkQ5M0VFLnBkZgAADgC2AFoASwB1AGwAawBhAHIAbgBpAC0AVwBoAGEAbABsAGUAeQAtAFQAeQBzAG8AbgAgAC0AIABJAG4AIABzAGUAYQByAGMAaAAgAG8AZgAgAG4AZQBhAHIALQBvAHAAdABpAG0AYQBsACAAbwBwAHQAaQBtAGkAegBhAHQAaQBvAG4AIABwAGgAYQBzAGUAIABvAHIAZABlAHIAaQBuAGcAcwAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHdVc2Vycy9qZXJlbXkvUGFwZXJzL0t1bGthcm5pL0t1bGthcm5pLVdoYWxsZXktVHlzb24gLSBJbiBzZWFyY2ggb2YgbmVhci1vcHRpbWFsIG9wdGltaXphdGlvbiBwaGFzZSBvcmRlcmluZ3MgKDIwMDYpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBHQEiASoDlgOYA50DpgOxA7UDwwPKA9MD2APbAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA+g=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1134650.1134663}}

@article{Kumar:When:2004,
	Address = {New York, NY, USA},
	Author = {K. V. Seshu Kumar},
	Date-Added = {2007-12-22 21:06:22 -0500},
	Date-Modified = {2008-04-26 20:00:38 -0400},
	Doi = {http://doi.acm.org/10.1145/981009.981015},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Keywords = {compilation, optimization, virtual machines; abstract machines},
	Local-Url = {file://localhost/Users/jeremy/Papers/Kumar/Kumar%20-%20When%20and%20what%20to%20compile-optimize%20in%20a%20virtual%20machine%3F%20(2004).pdf},
	Number = {3},
	Pages = {38--45},
	Publisher = {ACM},
	Title = {When and what to compile/optimize in a virtual machine?},
	Volume = {39},
	Year = {2004},
	Abstract = {To speed up the computation of some of the object languages, virtual machines use dynamic compilation. But due to compilation taking place during user application runtime, one has to choose which methods to compile, so that the compile time has little impact on the total runtime of the actual application. In order to achieve this, we have to use an estimate to determine the process of compilation. Current virtual machines use run time information such as number of calls made to this method, size of the method and as well as number of times the back edges taken to determine the hotness of a method. They use this information against some threshold which does not have any relationship with the method that is being considered for compilation.

Detecting the hot routines is very important from the perspective of performance since optimized methods run 10 times faster than the interpreted version. In this paper we propose a new technique called relative estimation for determining the hotness of the functions. For each method in the application, we estimate the cost/benefits for compilation or optimization by doing method analysis. We select the methods for compilation or optimization initially based on the above metrics using the proposed relative estimation technique. Later on we use the online profile information such as backedge counters and invocation counts to adjust the relative estimation process itself. We have performed experiments to validate the effectiveness of the proposed method on SPECjvm98 benchmark suite and found that up to 4% performance improvement in the application execution time occurs.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEF0uLi8uLi9QYXBlcnMvS3VtYXIvS3VtYXIgLSBXaGVuIGFuZCB3aGF0IHRvIGNvbXBpbGUtb3B0aW1pemUgaW4gYSB2aXJ0dWFsIG1hY2hpbmU/ICgyMDA0KS5wZGbSGw8cHVdOUy5kYXRhTxECLgAAAAACLgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZPgH0t1bWFyIC0gV2hlbiBhbmQgd2hhIzJEOTNENi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtk9bDkyy2UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVLdW1hcgAAEAAIAADBNH5dAAAAEQAIAADDk3MGAAAAAQAQAC2T4AAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6S3VtYXI6S3VtYXIgLSBXaGVuIGFuZCB3aGEjMkQ5M0Q2LnBkZgAOAJYASgBLAHUAbQBhAHIAIAAtACAAVwBoAGUAbgAgAGEAbgBkACAAdwBoAGEAdAAgAHQAbwAgAGMAbwBtAHAAaQBsAGUALQBvAHAAdABpAG0AaQB6AGUAIABpAG4AIABhACAAdgBpAHIAdAB1AGEAbAAgAG0AYQBjAGgAaQBuAGUAPwAgACgAMgAwADAANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGRVc2Vycy9qZXJlbXkvUGFwZXJzL0t1bWFyL0t1bWFyIC0gV2hlbiBhbmQgd2hhdCB0byBjb21waWxlLW9wdGltaXplIGluIGEgdmlydHVhbCBtYWNoaW5lPyAoMjAwNCkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQoBDwEXA0kDSwNQA1kDZANoA3YDfQOGA4sDjgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOb},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/981009.981015}}

@article{Sansom:Formally:1997,
	Address = {New York, NY, USA},
	Author = {Patrick M. Sansom and Peyton Jones, Simon L. },
	Date-Added = {2007-12-22 21:03:49 -0500},
	Date-Modified = {2008-04-17 17:55:32 -0400},
	Doi = {http://doi.acm.org/10.1145/244795.244802},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Keywords = {profiling},
	Local-Url = {file://localhost/Users/jeremy/Papers/Sansom/Sansom-Jones%20-%20Formally%20based%20profiling%20for%20higher-order%20functional%20(1997).pdf},
	Number = {2},
	Pages = {334--385},
	Publisher = {ACM},
	Title = {Formally based profiling for higher-order functional languages},
	Volume = {19},
	Year = {1997},
	Abstract = {We present the first source-level profiler for a compiled, nonstrict, higher-order, purely functional language capable of measuring time as well as space usage. Our profiler is implemented in a production-quality optimizing compiler for Haskell and can successfully profile large applications. A unique feature of our approach is that we give a formal specification of the attribution of execution costs to cost centers. This specification enables us to discuss our design decisions in a precise framework, prove properties about the attribution of costs, and examine to effects of different program transformations on the attribution of costs. Since it is not obvious how to map this specification onto a particular implementation, we also present an implementation-oriented operational semantics, and prove it equivalent to the specification.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGIuLi8uLi9QYXBlcnMvU2Fuc29tL1NhbnNvbS1Kb25lcyAtIEZvcm1hbGx5IGJhc2VkIHByb2ZpbGluZyBmb3IgaGlnaGVyLW9yZGVyIGZ1bmN0aW9uYWwgKDE5OTcpLnBkZtIbDxwdV05TLmRhdGFPEQI+AAAAAAI+AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtk8UfU2Fuc29tLUpvbmVzIC0gRm9ybWEjMkQ5M0MzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC2Tw8OTLFJQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABlNhbnNvbQAQAAgAAME0fl0AAAARAAgAAMOTcqIAAAABABAALZPFAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpTYW5zb206U2Fuc29tLUpvbmVzIC0gRm9ybWEjMkQ5M0MzLnBkZgAADgCeAE4AUwBhAG4AcwBvAG0ALQBKAG8AbgBlAHMAIAAtACAARgBvAHIAbQBhAGwAbAB5ACAAYgBhAHMAZQBkACAAcAByAG8AZgBpAGwAaQBuAGcAIABmAG8AcgAgAGgAaQBnAGgAZQByAC0AbwByAGQAZQByACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgACgAMQA5ADkANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGlVc2Vycy9qZXJlbXkvUGFwZXJzL1NhbnNvbS9TYW5zb20tSm9uZXMgLSBGb3JtYWxseSBiYXNlZCBwcm9maWxpbmcgZm9yIGhpZ2hlci1vcmRlciBmdW5jdGlvbmFsICgxOTk3KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQ8BFAEcA14DYANlA24DeQN9A4sDkgObA6ADowAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOw},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/244795.244802}}

@inproceedings{Cardelli:Compiling:1984,
	Address = {New York, NY, USA},
	Author = {Luca Cardelli},
	Booktitle = {LFP '84: Proceedings of the 1984 ACM Symposium on LISP and functional programming},
	Date-Added = {2007-12-22 20:58:15 -0500},
	Date-Modified = {2008-04-26 19:58:26 -0400},
	Doi = {http://doi.acm.org/10.1145/800055.802037},
	Isbn = {0-89791-142-3},
	Keywords = {history of computing, compilation; abstract machines},
	Local-Url = {file://localhost/Users/jeremy/Papers/Cardelli/Cardelli%20-%20Compiling%20a%20functional%20language%20(1984).pdf},
	Location = {Austin, Texas, United States},
	Pages = {208--217},
	Publisher = {ACM},
	Rating = {2},
	Read = {Yes},
	Title = {Compiling a functional language},
	Year = {1984},
	Abstract = {This paper summarizes my experience in implementing a compiler for a functional language. The language is ML(1) [Milner 84] and the compiler was first implemented in 1980 as a personal project when I was a postgraduate student at the University of Edinburgh(2). At the time, I was familiar with programming language semantics but knew very little about compiler technology; interpreters had been my main programming concern. Major influences in the design of this compiler have been [Steele 77] [Steele 78] and the implementation folklore for statically and dynamically scoped dialects of Lisp [Allen 78]. As a result, the internal structure of the compiler is fairly unorthodox, if compared for example with [Aho 78]. Anyway, a compiler for a language like ML has to be different. ML is interactive, statically scoped, strongly typed, polymorphic, and has first class higher-order functions, type inference and dynamic allocation. These features preclude many well-known implementation styles, particularly the ones used for Lisp (because of static scoping), the Algol family (because of functional values) and C (because of nested scoping and strong typing). The interaction of these features is what gives ML its ``character'', and makes compilation challenging. The compiler has been recently partially converted to the new ML standard. The major points of interest which are discussed in this paper are: (a) the interactive interpreter-like usage; (b) the polymorphic type inference algorithm; (c) the compilation of pattern matching; (d) the optimization of the representation of user defined data types; (e) the compilation of functional closures, function application and variable access; (f) the intermediate abstract machine and its formal operational semantics; (g) modules and type-safe separate compilation.},
	Annote = {Regards functional compilation as distinct from imperative, and considers techniques such as register allocation to be a "mistake in functional languages because of frequent context switching" (209). In building her compiler, Cardelli drew primarily on Lisp compilation experience and folklore, rather than imperative compilation theory and technique as exemplified in the dragon book.

The module system was still under construction at the time. Already uses unboxed representations for small values (booleans, small ints, etc.). Discusses pattern-matching via discrimination trees in some detail. Correctly observes that how to represent the many datatypes, particularly closures, is an important issue. Argues for use of an abstract machine in order to simplify the process of compilation, and seems particularly fond of using a typefree machine. Her functional abstract machine (FAM) is basically an SECD machine, though it uses several other stacks for different purposes.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEsuLi8uLi9QYXBlcnMvQ2FyZGVsbGkvQ2FyZGVsbGkgLSBDb21waWxpbmcgYSBmdW5jdGlvbmFsIGxhbmd1YWdlICgxOTg0KS5wZGbSGw8cHVdOUy5kYXRhTxEB+AAAAAAB+AACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZOmH0NhcmRlbGxpIC0gQ29tcGlsaW5nIzJEOTNBMi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtk6LDkys+UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAhDYXJkZWxsaQAQAAgAAME0fl0AAAARAAgAAMOTcY4AAAABABAALZOmAC2RPwADR6wAAGvYAAIAQU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpDYXJkZWxsaTpDYXJkZWxsaSAtIENvbXBpbGluZyMyRDkzQTIucGRmAAAOAGwANQBDAGEAcgBkAGUAbABsAGkAIAAtACAAQwBvAG0AcABpAGwAaQBuAGcAIABhACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgAGwAYQBuAGcAdQBhAGcAZQAgACgAMQA5ADgANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFJVc2Vycy9qZXJlbXkvUGFwZXJzL0NhcmRlbGxpL0NhcmRlbGxpIC0gQ29tcGlsaW5nIGEgZnVuY3Rpb25hbCBsYW5ndWFnZSAoMTk4NCkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPgA/QEFAwEDAwMIAxEDHAMgAy4DNQM+A0MDRgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANT},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/800055.802037}}

@article{Webber:Optimization:1995,
	Address = {New York, NY, USA},
	Author = {Adam Webber},
	Date-Added = {2007-12-22 20:52:19 -0500},
	Date-Modified = {2007-12-22 20:57:44 -0500},
	Doi = {http://doi.acm.org/10.1145/201059.201067},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Keywords = {optimization},
	Local-Url = {file://localhost/Users/jeremy/Papers/Webber/Webber%20-%20Optimization%20of%20functional%20programs%20by%20grammar%20thinning%20(1995).pdf},
	Number = {2},
	Pages = {293--330},
	Publisher = {ACM},
	Title = {Optimization of functional programs by grammar thinning},
	Volume = {17},
	Year = {1995},
	Abstract = {We describe a new technique for optimizing first-order functional programs. Programs are represented as graph grammars, and optimization proceeds by counterexample: when a graph generated by the grammar is found to contain an unnecessary computation, the optimizer attempts to reformulates the grammar so that it never again generates any graph that contains that counterexample. This kind of program reformulation corresponds to an interesting problem on context-free grammars. Our reformulation technique is derived from an (approximate) solution to this CFG problem. An optimizer called Thinner is the proof of concept for this technique. Thinner is a fully automatic, source-to-source optimizer for a Lisp-like language of purely functional, first-order programs. Thinner rediscovers a wide variety of common compiler optimizations. It also finds other more exotic transformations, including the well-known Fibonacci reformulation and the Knuth-Morris-Pratt optimization.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEF8uLi8uLi9QYXBlcnMvV2ViYmVyL1dlYmJlciAtIE9wdGltaXphdGlvbiBvZiBmdW5jdGlvbmFsIHByb2dyYW1zIGJ5IGdyYW1tYXIgdGhpbm5pbmcgKDE5OTUpLnBkZtIbDxwdV05TLmRhdGFPEQI0AAAAAAI0AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtk3YfV2ViYmVyIC0gT3B0aW1pemF0aW8jMkQ5MzcyLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC2TcsOTKklQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABldlYmJlcgAQAAgAAME0fl0AAAARAAgAAMOTcJkAAAABABAALZN2AC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpXZWJiZXI6V2ViYmVyIC0gT3B0aW1pemF0aW8jMkQ5MzcyLnBkZgAADgCYAEsAVwBlAGIAYgBlAHIAIAAtACAATwBwAHQAaQBtAGkAegBhAHQAaQBvAG4AIABvAGYAIABmAHUAbgBjAHQAaQBvAG4AYQBsACAAcAByAG8AZwByAGEAbQBzACAAYgB5ACAAZwByAGEAbQBtAGEAcgAgAHQAaABpAG4AbgBpAG4AZwAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGZVc2Vycy9qZXJlbXkvUGFwZXJzL1dlYmJlci9XZWJiZXIgLSBPcHRpbWl6YXRpb24gb2YgZnVuY3Rpb25hbCBwcm9ncmFtcyBieSBncmFtbWFyIHRoaW5uaW5nICgxOTk1KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBDAERARkDUQNTA1gDYQNsA3ADfgOFA44DkwOWAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA6M=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/201059.201067}}

@inproceedings{Marlow:Making:2004,
	Address = {New York, NY, USA},
	Author = {Simon Marlow and Simon Peyton Jones},
	Booktitle = {ICFP '04: Proceedings of the ninth ACM SIGPLAN international conference on Functional programming},
	Date-Added = {2007-12-22 20:48:03 -0500},
	Date-Modified = {2008-04-17 17:56:52 -0400},
	Doi = {http://doi.acm.org/10.1145/1016850.1016856},
	Isbn = {1-58113-905-5},
	Keywords = {optimization, functional languages},
	Local-Url = {file://localhost/Users/jeremy/Papers/Marlow/Marlow-Jones%20-%20Making%20a%20fast%20curry%20push-enter%20vs.%20eval-apply%20(2004).pdf},
	Location = {Snow Bird, UT, USA},
	Pages = {4--15},
	Publisher = {ACM},
	Title = {Making a fast curry: push/enter vs. eval/apply for higher-order languages},
	Year = {2004},
	Abstract = {Higher-order languages that encourage currying are implemented using one of two basic evaluation models: push/enter or eval/apply. Implementors use their intuition and qualitative judgements to choose one model or the other. Our goal in this paper is to provide, for the first time, a more substantial basis for this choice, based on our qualitative and quantitative experience of implementing both models in a state-of-the-art compiler for Haskell. Our conclusion is simple, and contradicts our initial intuition: compiled implementations should use eval/apply.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFsuLi8uLi9QYXBlcnMvTWFybG93L01hcmxvdy1Kb25lcyAtIE1ha2luZyBhIGZhc3QgY3VycnkgcHVzaC1lbnRlciB2cy4gZXZhbC1hcHBseSAoMjAwNCkucGRm0hsPHB1XTlMuZGF0YU8RAigAAAAAAigAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2TVB9NYXJsb3ctSm9uZXMgLSBNYWtpbiMyRDkzNTIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZNSw5MpJFBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGTWFybG93ABAACAAAwTR+XQAAABEACAAAw5NvdAAAAAEAEAAtk1QALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOk1hcmxvdzpNYXJsb3ctSm9uZXMgLSBNYWtpbiMyRDkzNTIucGRmAAAOAJAARwBNAGEAcgBsAG8AdwAtAEoAbwBuAGUAcwAgAC0AIABNAGEAawBpAG4AZwAgAGEAIABmAGEAcwB0ACAAYwB1AHIAcgB5ACAAcAB1AHMAaAAtAGUAbgB0AGUAcgAgAHYAcwAuACAAZQB2AGEAbAAtAGEAcABwAGwAeQAgACgAMgAwADAANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGJVc2Vycy9qZXJlbXkvUGFwZXJzL01hcmxvdy9NYXJsb3ctSm9uZXMgLSBNYWtpbmcgYSBmYXN0IGN1cnJ5IHB1c2gtZW50ZXIgdnMuIGV2YWwtYXBwbHkgKDIwMDQpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEIAQ0BFQNBA0MDSANRA1wDYANuA3UDfgODA4YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1016850.1016856}}

@article{Douence:A-systematic:1998,
	Address = {New York, NY, USA},
	Author = {R\'{e}mi Douence and Pascal Fradet},
	Date-Added = {2007-12-22 20:46:59 -0500},
	Date-Modified = {2008-04-26 19:58:54 -0400},
	Doi = {http://doi.acm.org/10.1145/276393.276397},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Keywords = {functional languages; abstract machines},
	Local-Url = {file://localhost/Users/jeremy/Papers/Douence/Douence-Fradet%20-%20A%20systematic%20study%20of%20functional%20language%20implementations%20(1998).pdf},
	Number = {2},
	Pages = {344--387},
	Publisher = {ACM},
	Title = {A systematic study of functional language implementations},
	Volume = {20},
	Year = {1998},
	Abstract = {We introduce a unified framework to describe, relate, compare, and classify functional language implementations. The compilation process is expressed as a succession of program transformations in the common framework. At each step, different transformations model fundamental choices. A benefit of this approach is to structure and decompose the implementation process. The correctness proofs can be tackled independently for each step and amount to proving program transformations in the functional world. This approach also paves the way to formal comparisons by making it possible to estimate the complexity of individual transformations or compositions of them. Our study aims at covering the whole known design space of sequential functional language implementations. In particular, we consider call-by-value, call-by-name, call-by-need reduction strategies as well as environment- and graph-based implementations. We describe for each compilation step the diverse alternatives as program transformations. In some cases, we illustrate how to compare or relate compilation techniques, express global optimizations, or hybrid implementations. We also provide a classification of well-known abstract machines.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGouLi8uLi9QYXBlcnMvRG91ZW5jZS9Eb3VlbmNlLUZyYWRldCAtIEEgc3lzdGVtYXRpYyBzdHVkeSBvZiBmdW5jdGlvbmFsIGxhbmd1YWdlIGltcGxlbWVudGF0aW9ucyAoMTk5OCkucGRm0hsPHB1XTlMuZGF0YU8RAlYAAAAAAlYAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2TSR9Eb3VlbmNlLUZyYWRldCAtIEEgcyMyRDkzNDYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZNGw5Moz1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAHRG91ZW5jZQAAEAAIAADBNH5dAAAAEQAIAADDk28fAAAAAQAQAC2TSQAtkT8AA0esAABr2AACAEBPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6RG91ZW5jZTpEb3VlbmNlLUZyYWRldCAtIEEgcyMyRDkzNDYucGRmAA4ArABVAEQAbwB1AGUAbgBjAGUALQBGAHIAYQBkAGUAdAAgAC0AIABBACAAcwB5AHMAdABlAG0AYQB0AGkAYwAgAHMAdAB1AGQAeQAgAG8AZgAgAGYAdQBuAGMAdABpAG8AbgBhAGwAIABsAGEAbgBnAHUAYQBnAGUAIABpAG0AcABsAGUAbQBlAG4AdABhAHQAaQBvAG4AcwAgACgAMQA5ADkAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHFVc2Vycy9qZXJlbXkvUGFwZXJzL0RvdWVuY2UvRG91ZW5jZS1GcmFkZXQgLSBBIHN5c3RlbWF0aWMgc3R1ZHkgb2YgZnVuY3Rpb25hbCBsYW5ndWFnZSBpbXBsZW1lbnRhdGlvbnMgKDE5OTgpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBFwEcASQDfgOAA4UDjgOZA50DqwOyA7sDwAPDAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA9A=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/276393.276397}}

@inproceedings{Nederhof:Efficient:1996,
	Address = {Morristown, NJ, USA},
	Author = {Mark-Jan Nederhof and Giorgio Satta},
	Booktitle = {Proceedings of the 34th annual meeting on Association for Computational Linguistics},
	Date-Added = {2007-12-22 20:28:27 -0500},
	Date-Modified = {2007-12-22 20:32:55 -0500},
	Doi = {http://dx.doi.org/10.3115/981863.981895},
	Keywords = {parsing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Nederhof/Nederhof-Satta%20-%20Efficient%20tabular%20LR%20parsing%20(1996).pdf},
	Location = {Santa Cruz, California},
	Pages = {239--246},
	Publisher = {Association for Computational Linguistics},
	Title = {Efficient tabular LR parsing},
	Year = {1996},
	Abstract = {We give a new treatment of tabular LR parsing, which is an alternative to Tomita's generalized LR algorithm. The advantage is twofold. Firstly, our treatment is conceptually more attractive because it uses simpler concepts, such as grammar transformations and standard tabulation techniques also know as chart parsing. Secondly, the static and dynamic complexity of parsing, both in space and time, is significantly reduced.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE4uLi8uLi9QYXBlcnMvTmVkZXJob2YvTmVkZXJob2YtU2F0dGEgLSBFZmZpY2llbnQgdGFidWxhciBMUiBwYXJzaW5nICgxOTk2KS5wZGbSGw8cHVdOUy5kYXRhTxECAgAAAAACAgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZLtH05lZGVyaG9mLVNhdHRhIC0gRWZmIzJEOTJFOS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkunDkyRsUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAhOZWRlcmhvZgAQAAgAAME0fl0AAAARAAgAAMOTarwAAAABABAALZLtAC2RPwADR6wAAGvYAAIAQU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpOZWRlcmhvZjpOZWRlcmhvZi1TYXR0YSAtIEVmZiMyRDkyRTkucGRmAAAOAHIAOABOAGUAZABlAHIAaABvAGYALQBTAGEAdAB0AGEAIAAtACAARQBmAGYAaQBjAGkAZQBuAHQAIAB0AGEAYgB1AGwAYQByACAATABSACAAcABhAHIAcwBpAG4AZwAgACgAMQA5ADkANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFVVc2Vycy9qZXJlbXkvUGFwZXJzL05lZGVyaG9mL05lZGVyaG9mLVNhdHRhIC0gRWZmaWNpZW50IHRhYnVsYXIgTFIgcGFyc2luZyAoMTk5NikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD7AQABCAMOAxADFQMeAykDLQM7A0IDSwNQA1MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADYA==},
	Bdsk-Url-1 = {http://dx.doi.org/10.3115/981863.981895}}

@inproceedings{Wyk:Context-aware:2007,
	Address = {New York, NY, USA},
	Author = {Eric R. Van Wyk and August C. Schwerdfeger},
	Booktitle = {GPCE '07: Proceedings of the 6th international conference on Generative programming and component engineering},
	Date-Added = {2007-12-22 20:28:09 -0500},
	Date-Modified = {2007-12-22 20:33:22 -0500},
	Doi = {http://doi.acm.org/10.1145/1289971.1289983},
	Isbn = {978-1-59593-855-8},
	Keywords = {parsing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Wyk/Wyk-Schwerdfeger%20-%20Context-aware%20scanning%20for%20parsing%20extensible%20languages%20(2007).pdf},
	Location = {Salzburg, Austria},
	Pages = {63--72},
	Publisher = {ACM},
	Title = {Context-aware scanning for parsing extensible languages},
	Year = {2007},
	Abstract = {This paper introduces new parsing and context-aware scanning algorithms in which the scanner uses contextual information to disambiguate lexical syntax. The parser uses a slightly modified LR-style algorithm that passes to the scanner the set of valid symbols that the scanner may return at that point in parsing. This set is those terminals whose entries in the parse table for the current parse state are shift, reduce, or accept, but not error. The scanner then only returns tokens in this set. An analysis is given that can statically verify that the scanner will never return more than one token for a single input. Context-aware scanning is especially useful when parsing and scanning extensible languages in which domain specific languages can be embedded. It has been used in extensible versions of Java 1.4 and ANSI C. We illustrate this approach with a declarative specification of a subset of Java and extensions that embed SQL queries and Boolean expression tables into Java.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGYuLi8uLi9QYXBlcnMvV3lrL1d5ay1TY2h3ZXJkZmVnZXIgLSBDb250ZXh0LWF3YXJlIHNjYW5uaW5nIGZvciBwYXJzaW5nIGV4dGVuc2libGUgbGFuZ3VhZ2VzICgyMDA3KS5wZGbSGw8cHVdOUy5kYXRhTxECSgAAAAACSgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZLhH1d5ay1TY2h3ZXJkZmVnZXIgLSBDIzJEOTJERi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkt/DkyRBUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAANXeWsAABAACAAAwTR+XQAAABEACAAAw5NqkQAAAAEAEAAtkuEALZE/AANHrAAAa9gAAgA8T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOld5azpXeWstU2Nod2VyZGZlZ2VyIC0gQyMyRDkyREYucGRmAA4ArABVAFcAeQBrAC0AUwBjAGgAdwBlAHIAZABmAGUAZwBlAHIAIAAtACAAQwBvAG4AdABlAHgAdAAtAGEAdwBhAHIAZQAgAHMAYwBhAG4AbgBpAG4AZwAgAGYAbwByACAAcABhAHIAcwBpAG4AZwAgAGUAeAB0AGUAbgBzAGkAYgBsAGUAIABsAGEAbgBnAHUAYQBnAGUAcwAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG1Vc2Vycy9qZXJlbXkvUGFwZXJzL1d5ay9XeWstU2Nod2VyZGZlZ2VyIC0gQ29udGV4dC1hd2FyZSBzY2FubmluZyBmb3IgcGFyc2luZyBleHRlbnNpYmxlIGxhbmd1YWdlcyAoMjAwNykucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgETARgBIANuA3ADdQN+A4kDjQObA6IDqwOwA7MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADwA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1289971.1289983}}

@article{Gray:Canonical:1973,
	Address = {New York, NY, USA},
	Author = {James N. Gray and Michael A. Harrison},
	Date-Added = {2007-12-22 20:27:11 -0500},
	Date-Modified = {2007-12-22 20:32:46 -0500},
	Doi = {http://doi.acm.org/10.1145/321752.321755},
	Issn = {0004-5411},
	Journal = {J. ACM},
	Keywords = {parsing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Gray/Gray-Harrison%20-%20Canonical%20Precedence%20Schemes%20(1973).pdf},
	Number = {2},
	Pages = {214--234},
	Publisher = {ACM},
	Title = {Canonical Precedence Schemes},
	Volume = {20},
	Year = {1973},
	Abstract = {A general theory of canonical precedence analysis is defined and studied. The familiar types of precedence analysis such as operator precedence or simple precedence occur as special cases of this theory. Among the theoretical results obtained are a characterization of the structure of precedence relations and the relation of canonical precedence schemes to operator sets.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEkuLi8uLi9QYXBlcnMvR3JheS9HcmF5LUhhcnJpc29uIC0gQ2Fub25pY2FsIFByZWNlZGVuY2UgU2NoZW1lcyAoMTk3MykucGRm0hsPHB1XTlMuZGF0YU8RAfIAAAAAAfIAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2TAB9HcmF5LUhhcnJpc29uIC0gQ2FubyMyRDkyRkQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZL9w5MkwVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAER3JheQAQAAgAAME0fl0AAAARAAgAAMOTaxEAAAABABAALZMAAC2RPwADR6wAAGvYAAIAPU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpHcmF5OkdyYXktSGFycmlzb24gLSBDYW5vIzJEOTJGRC5wZGYAAA4AcAA3AEcAcgBhAHkALQBIAGEAcgByAGkAcwBvAG4AIAAtACAAQwBhAG4AbwBuAGkAYwBhAGwAIABQAHIAZQBjAGUAZABlAG4AYwBlACAAUwBjAGgAZQBtAGUAcwAgACgAMQA5ADcAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFBVc2Vycy9qZXJlbXkvUGFwZXJzL0dyYXkvR3JheS1IYXJyaXNvbiAtIENhbm9uaWNhbCBQcmVjZWRlbmNlIFNjaGVtZXMgKDE5NzMpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD2APsBAwL5AvsDAAMJAxQDGAMmAy0DNgM7Az4AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADSw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/321752.321755}}

@inproceedings{Pager:The-lane:1973,
	Address = {New York, NY, USA},
	Author = {David Pager},
	Booktitle = {STOC '73: Proceedings of the fifth annual ACM symposium on Theory of computing},
	Date-Added = {2007-12-22 20:26:54 -0500},
	Date-Modified = {2008-01-17 21:17:29 -0500},
	Doi = {http://doi.acm.org/10.1145/800125.804048},
	Keywords = {parsing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Pager/Pager%20-%20The%20lane%20tracing%20algorithm%20for%20constructing%20LR(k)%20(1973).pdf},
	Location = {Austin, Texas, United States},
	Pages = {172--181},
	Publisher = {ACM},
	Rating = {3},
	Read = {Yes},
	Title = {The lane tracing algorithm for constructing LR(k) parsers},
	Year = {1973},
	Abstract = {The paper presents, as far as the author is aware, the first practical general method for constructing LR(k) parsers. It has been used, without computational difficulty, to produce LR(1), LR(2) and LR(3) parsers for grammars of the size of ALGOL.},
	Annote = {Pager's description of LR(0) parsing is the most lucid I've read thus far. Unfortunately, he's confusing when it comes to describing his new ideas. That's likely due to lack of oversight (it is a non-refereed tech report) and Pager still trying to figure out how best to describe his idea. This tech report grew up to be a publication in Acta Informatica.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFcuLi8uLi9QYXBlcnMvUGFnZXIvUGFnZXIgLSBUaGUgbGFuZSB0cmFjaW5nIGFsZ29yaXRobSBmb3IgY29uc3RydWN0aW5nIExSKGspICgxOTczKS5wZGbSGw8cHVdOUy5kYXRhTxECHAAAAAACHAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZL5H1BhZ2VyIC0gVGhlIGxhbmUgdHJhIzJEOTJGNy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkvfDkySuUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVQYWdlcgAAEAAIAADBNH5dAAAAEQAIAADDk2r+AAAAAQAQAC2S+QAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6UGFnZXI6UGFnZXIgLSBUaGUgbGFuZSB0cmEjMkQ5MkY3LnBkZgAOAIoARABQAGEAZwBlAHIAIAAtACAAVABoAGUAIABsAGEAbgBlACAAdAByAGEAYwBpAG4AZwAgAGEAbABnAG8AcgBpAHQAaABtACAAZgBvAHIAIABjAG8AbgBzAHQAcgB1AGMAdABpAG4AZwAgAEwAUgAoAGsAKQAgACgAMQA5ADcAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF5Vc2Vycy9qZXJlbXkvUGFwZXJzL1BhZ2VyL1BhZ2VyIC0gVGhlIGxhbmUgdHJhY2luZyBhbGdvcml0aG0gZm9yIGNvbnN0cnVjdGluZyBMUihrKSAoMTk3MykucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQQBCQERAzEDMwM4A0EDTANQA14DZQNuA3MDdgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOD},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/800125.804048}}

@inproceedings{Lammel:Design:2002,
	Address = {New York, NY, USA},
	Author = {Ralf L\"{a}mmel and Joost Visser},
	Booktitle = {RULE '02: Proceedings of the 2002 ACM SIGPLAN workshop on Rule-based programming},
	Date-Added = {2007-12-22 20:17:47 -0500},
	Date-Modified = {2007-12-22 20:19:09 -0500},
	Doi = {http://doi.acm.org/10.1145/570186.570187},
	Isbn = {1-58113-606-4},
	Local-Url = {file://localhost/Users/jeremy/Papers/Lammel/Lammel-Visser%20-%20Design%20patterns%20for%20functional%20strategic%20programming%20(2002).pdf},
	Location = {Pittsburgh, Pennsylvania},
	Pages = {1--14},
	Publisher = {ACM},
	Title = {Design patterns for functional strategic programming},
	Year = {2002},
	Abstract = {We believe that design patterns can be an effective means of consolidating and communicating program construction expertise for functional programming, just as they have proven to be in object-oriented programming. The emergence of combinator libraries that develop a specific domain or programming idiom has intensified, rather than reduced, the need for design patterns.In previous work, we introduced the fundamentals and a supporting combinator library for functional strategic programming. This is an idiom for (general purpose) generic programming based on the notion of a functional strategy: a first-class generic function that can not only be applied to terms of any type, but which also allows generic traversal into subterms and can be customised with type-specific behaviour.This paper seeks to provide practising functional programmers with pragmatic guidance in crafting their own generic programs using functional strategies. To this end, we propose a novel description format for functional design patterns, and we initiate a catalogue of strategy design patterns. These design patterns aim at consolidating strategic programming expertise in accessible form.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGMuLi8uLi9QYXBlcnMvTGFtbWVsL0xhbW1lbC1WaXNzZXIgLSBEZXNpZ24gcGF0dGVybnMgZm9yIGZ1bmN0aW9uYWwgc3RyYXRlZ2ljIHByb2dyYW1taW5nICgyMDAyKS5wZGbSGw8cHVdOUy5kYXRhTxECQAAAAAACQAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZKpH0xhbW1lbC1WaXNzZXIgLSBEZXNpIzJEOTJBNy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkqfDkyG2UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZMYW1tZWwAEAAIAADBNH5dAAAAEQAIAADDk2gGAAAAAQAQAC2SqQAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6TGFtbWVsOkxhbW1lbC1WaXNzZXIgLSBEZXNpIzJEOTJBNy5wZGYAAA4AoABPAEwAYQBtAG0AZQBsAC0AVgBpAHMAcwBlAHIAIAAtACAARABlAHMAaQBnAG4AIABwAGEAdAB0AGUAcgBuAHMAIABmAG8AcgAgAGYAdQBuAGMAdABpAG8AbgBhAGwAIABzAHQAcgBhAHQAZQBnAGkAYwAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMgAwADAAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGpVc2Vycy9qZXJlbXkvUGFwZXJzL0xhbW1lbC9MYW1tZWwtVmlzc2VyIC0gRGVzaWduIHBhdHRlcm5zIGZvciBmdW5jdGlvbmFsIHN0cmF0ZWdpYyBwcm9ncmFtbWluZyAoMjAwMikucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARABFQEdA2EDYwNoA3EDfAOAA44DlQOeA6MDpgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOz},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/570186.570187}}

@inproceedings{Burchett:Lowering:2007,
	Address = {New York, NY, USA},
	Author = {Kimberley Burchett and Gregory H. Cooper and Shriram Krishnamurthi},
	Booktitle = {PEPM '07: Proceedings of the 2007 ACM SIGPLAN symposium on Partial evaluation and semantics-based program manipulation},
	Date-Added = {2007-12-22 20:14:17 -0500},
	Date-Modified = {2008-04-25 02:14:12 -0400},
	Doi = {http://doi.acm.org/10.1145/1244381.1244393},
	Isbn = {978-1-59593-620-2},
	Keywords = {reactive programming, optimization, static analysis},
	Local-Url = {file://localhost/Users/jeremy/Papers/Burchett/Burchett-Cooper-Krishnamurthi%20-%20Lowering%20a%20static%20optimization%20technique%20for%20transparent%20(2007).pdf},
	Location = {Nice, France},
	Pages = {71--80},
	Publisher = {ACM},
	Title = {Lowering: a static optimization technique for transparent functional reactivity},
	Year = {2007},
	Abstract = {Functional Reactive Programming (FRP) extends traditional functional programming with dataflow evaluation, making it possible to write interactive programs in a declarative style. An FRP language creates a dynamic graph of data dependencies and reacts to changes by propagating updates through the graph. In a transparent FRP language, the primitive operators are implicitly lifted, so they construct graph nodes when they are applied to time-varying values. This model has some attractive properties, but it tends to produce a large graph that is costly to maintain. In this paper, we develop a transformation we call lowering, which improves performance by reducing the size of the graph. We present a static analysis that guides the sound application of this optimization, and we present benchmark results that demonstrate dramatic improvements in both speed and memory usage for real programs.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHkuLi8uLi9QYXBlcnMvQnVyY2hldHQvQnVyY2hldHQtQ29vcGVyLUtyaXNobmFtdXJ0aGkgLSBMb3dlcmluZyBhIHN0YXRpYyBvcHRpbWl6YXRpb24gdGVjaG5pcXVlIGZvciB0cmFuc3BhcmVudCAoMjAwNykucGRm0hsPHB1XTlMuZGF0YU8RAoIAAAAAAoIAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2Seh9CdXJjaGV0dC1Db29wZXItS3JpcyMyRDIyMTAucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALSIQw4b9mVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIQnVyY2hldHQAEAAIAADBNH5dAAAAEQAIAADDh0PpAAAAAQAQAC2SegAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QnVyY2hldHQ6QnVyY2hldHQtQ29vcGVyLUtyaXMjMkQyMjEwLnBkZgAADgDIAGMAQgB1AHIAYwBoAGUAdAB0AC0AQwBvAG8AcABlAHIALQBLAHIAaQBzAGgAbgBhAG0AdQByAHQAaABpACAALQAgAEwAbwB3AGUAcgBpAG4AZwAgAGEAIABzAHQAYQB0AGkAYwAgAG8AcAB0AGkAbQBpAHoAYQB0AGkAbwBuACAAdABlAGMAaABuAGkAcQB1AGUAIABmAG8AcgAgAHQAcgBhAG4AcwBwAGEAcgBlAG4AdAAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAIBVc2Vycy9qZXJlbXkvUGFwZXJzL0J1cmNoZXR0L0J1cmNoZXR0LUNvb3Blci1LcmlzaG5hbXVydGhpIC0gTG93ZXJpbmcgYSBzdGF0aWMgb3B0aW1pemF0aW9uIHRlY2huaXF1ZSBmb3IgdHJhbnNwYXJlbnQgKDIwMDcpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEmASsBMwO5A7sDwAPJA9QD2APmA+0D9gP7A/4AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAECw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1244381.1244393}}

@inproceedings{Swadi:A-monadic:2006,
	Address = {New York, NY, USA},
	Author = {Kedar Swadi and Walid Taha and Oleg Kiselyov and Emir Pasalic},
	Booktitle = {PEPM '06: Proceedings of the 2006 ACM SIGPLAN symposium on Partial evaluation and semantics-based program manipulation},
	Date-Added = {2007-12-22 20:10:38 -0500},
	Date-Modified = {2008-01-14 01:37:22 -0500},
	Doi = {http://doi.acm.org/10.1145/1111542.1111570},
	Isbn = {1-59593-196-1},
	Keywords = {monads, optimization},
	Local-Url = {file://localhost/Users/jeremy/Papers/Swadi/Swadi-Taha-Kiselyov%20-%20A%20monadic%20approach%20for%20avoiding%20code%20duplication%20(2006).pdf},
	Location = {Charleston, South Carolina},
	Pages = {160--169},
	Publisher = {ACM},
	Title = {A monadic approach for avoiding code duplication when staging memoized functions},
	Year = {2006},
	Abstract = {Building program generators that do not duplicate generated code can be challenging. At the same time, code duplication can easily increase both generation time and runtime of generated programs by an exponential factor. We identify an instance of this problem that can arise when memoized functions are staged. Without addressing this problem, it would be impossible to effectively stage dynamic programming algorithms. Intuitively, direct staging undoes the effect of memoization. To solve this problem once and for all, and for any function that uses memoization, we propose a staged monadic combinator library. Experimental results confirm that the library works as expected. Preliminary results also indicate that the library is useful even when memoization is not used.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGQuLi8uLi9QYXBlcnMvU3dhZGkvU3dhZGktVGFoYS1LaXNlbHlvdiAtIEEgbW9uYWRpYyBhcHByb2FjaCBmb3IgYXZvaWRpbmcgY29kZSBkdXBsaWNhdGlvbiAoMjAwNikucGRm0hsPHB1XTlMuZGF0YU8RAkQAAAAAAkQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2Sjh9Td2FkaS1UYWhhLUtpc2VseW92ICMyRDkyOEMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZKMw5MhP1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAFU3dhZGkAABAACAAAwTR+XQAAABEACAAAw5NnjwAAAAEAEAAtko4ALZE/AANHrAAAa9gAAgA+T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlN3YWRpOlN3YWRpLVRhaGEtS2lzZWx5b3YgIzJEOTI4Qy5wZGYADgCkAFEAUwB3AGEAZABpAC0AVABhAGgAYQAtAEsAaQBzAGUAbAB5AG8AdgAgAC0AIABBACAAbQBvAG4AYQBkAGkAYwAgAGEAcABwAHIAbwBhAGMAaAAgAGYAbwByACAAYQB2AG8AaQBkAGkAbgBnACAAYwBvAGQAZQAgAGQAdQBwAGwAaQBjAGEAdABpAG8AbgAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGtVc2Vycy9qZXJlbXkvUGFwZXJzL1N3YWRpL1N3YWRpLVRhaGEtS2lzZWx5b3YgLSBBIG1vbmFkaWMgYXBwcm9hY2ggZm9yIGF2b2lkaW5nIGNvZGUgZHVwbGljYXRpb24gKDIwMDYpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBEQEWAR4DZgNoA20DdgOBA4UDkwOaA6MDqAOrAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA7g=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1111542.1111570}}

@inproceedings{Hutton:Fold:1998,
	Address = {New York, NY, USA},
	Author = {Graham Hutton},
	Booktitle = {ICFP '98: Proceedings of the third ACM SIGPLAN international conference on Functional programming},
	Date-Added = {2007-12-22 20:08:57 -0500},
	Date-Modified = {2007-12-22 20:11:26 -0500},
	Doi = {http://doi.acm.org/10.1145/289423.289457},
	Isbn = {1-58113-024-4},
	Local-Url = {file://localhost/Users/jeremy/Papers/Hutton/Hutton%20-%20Fold%20and%20unfold%20for%20program%20semantics%20(1998).pdf},
	Location = {Baltimore, Maryland, United States},
	Pages = {280--288},
	Publisher = {ACM},
	Title = {Fold and unfold for program semantics},
	Year = {1998},
	Abstract = {In this paper we explain how recursion operators can be used to structure and reason about program semantics within a functional language. In particular, we show how the recursion operator fold can be used to structure denotational semantics, how the dual recursion operator unfold can be used to structure operational semantics, and how algebraic properties of these operators can be used to reason about program semantics. The techniques are explained with the aid of two main examples, the first concerning arithmetic expressions, and the second concerning Milner's concurrent language CCS. The aim of the paper is to give functional programmers new insights into recursion operators, program semantics, and the relationships between them.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE0uLi8uLi9QYXBlcnMvSHV0dG9uL0h1dHRvbiAtIEZvbGQgYW5kIHVuZm9sZCBmb3IgcHJvZ3JhbSBzZW1hbnRpY3MgKDE5OTgpLnBkZtIbDxwdV05TLmRhdGFPEQH+AAAAAAH+AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtkmAfSHV0dG9uIC0gRm9sZCBhbmQgdW4jMkQ5MjVFLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC2SXsOTH+FQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABkh1dHRvbgAQAAgAAME0fl0AAAARAAgAAMOTZjEAAAABABAALZJgAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpIdXR0b246SHV0dG9uIC0gRm9sZCBhbmQgdW4jMkQ5MjVFLnBkZgAADgB0ADkASAB1AHQAdABvAG4AIAAtACAARgBvAGwAZAAgAGEAbgBkACAAdQBuAGYAbwBsAGQAIABmAG8AcgAgAHAAcgBvAGcAcgBhAG0AIABzAGUAbQBhAG4AdABpAGMAcwAgACgAMQA5ADkAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFRVc2Vycy9qZXJlbXkvUGFwZXJzL0h1dHRvbi9IdXR0b24gLSBGb2xkIGFuZCB1bmZvbGQgZm9yIHByb2dyYW0gc2VtYW50aWNzICgxOTk4KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA+gD/AQcDCQMLAxADGQMkAygDNgM9A0YDSwNOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA1s=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/289423.289457}}

@article{Paakki:Attribute:1995,
	Address = {New York, NY, USA},
	Author = {Jukka Paakki},
	Date-Added = {2007-12-22 20:08:48 -0500},
	Date-Modified = {2008-01-14 01:38:24 -0500},
	Doi = {http://doi.acm.org/10.1145/210376.197409},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Keywords = {attribute grammars},
	Local-Url = {file://localhost/Users/jeremy/Papers/Paakki/Paakki%20-%20Attribute%20grammar%20paradigms---a%20high-level%20methodology%20(1995).pdf},
	Number = {2},
	Pages = {196--255},
	Publisher = {ACM},
	Title = {Attribute grammar paradigms---a high-level methodology in language implementation},
	Volume = {27},
	Year = {1995},
	Abstract = {Attribute grammars are a formalism for specifying programming languages. They have been applied to a great number of systems automatically producing language implementations from their specifications. The systems and their specification languages can be evaluated and classified according to their level of application support, linguistic characteristics, and degree of automation.A survey of attribute grammar-based specification languages is given. The modern advanced specification languages extend the core attribute grammar model with concepts and primitives from established programming paradigms. The main ideas behind the developed attribute grammar paradigms are discussed, and representative specification languages are presented with a common example grammar. The presentation is founded on mapping elements of attribute grammars to their counterparts in programming languages. This methodology of integrating two problem-solving disciplines together is explored with a classification of the paradigms into structured, modular, object-oriented, logic, and functional attribute grammars. The taxonomy is complemented by introducing approaches based on an implicit parallel or incremental attribute evaluation paradigm.  },
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEF4uLi8uLi9QYXBlcnMvUGFha2tpL1BhYWtraSAtIEF0dHJpYnV0ZSBncmFtbWFyIHBhcmFkaWdtcy0tLWEgaGlnaC1sZXZlbCBtZXRob2RvbG9neSAoMTk5NSkucGRm0hsPHB1XTlMuZGF0YU8RAjIAAAAAAjIAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2ShR9QYWFra2kgLSBBdHRyaWJ1dGUgZyMyRDkyODIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZKCw5MhH1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGUGFha2tpABAACAAAwTR+XQAAABEACAAAw5NnbwAAAAEAEAAtkoUALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlBhYWtraTpQYWFra2kgLSBBdHRyaWJ1dGUgZyMyRDkyODIucGRmAAAOAJYASgBQAGEAYQBrAGsAaQAgAC0AIABBAHQAdAByAGkAYgB1AHQAZQAgAGcAcgBhAG0AbQBhAHIAIABwAGEAcgBhAGQAaQBnAG0AcwAtAC0ALQBhACAAaABpAGcAaAAtAGwAZQB2AGUAbAAgAG0AZQB0AGgAbwBkAG8AbABvAGcAeQAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGVVc2Vycy9qZXJlbXkvUGFwZXJzL1BhYWtraS9QYWFra2kgLSBBdHRyaWJ1dGUgZ3JhbW1hciBwYXJhZGlnbXMtLS1hIGhpZ2gtbGV2ZWwgbWV0aG9kb2xvZ3kgKDE5OTUpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBCwEQARgDTgNQA1UDXgNpA20DewOCA4sDkAOTAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA6A=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/210376.197409}}

@inproceedings{Gibbons:Design:2006,
	Address = {New York, NY, USA},
	Author = {Jeremy Gibbons},
	Booktitle = {WGP '06: Proceedings of the 2006 ACM SIGPLAN workshop on Generic programming},
	Date-Added = {2007-12-22 20:06:01 -0500},
	Date-Modified = {2007-12-22 20:08:02 -0500},
	Doi = {http://doi.acm.org/10.1145/1159861.1159863},
	Isbn = {1-59593-492-6},
	Local-Url = {file://localhost/Users/jeremy/Papers/Gibbons/Gibbons%20-%20Design%20patterns%20as%20higher-order%20datatype-generic%20programs%20(2006).pdf},
	Location = {Portland, Oregon, USA},
	Pages = {1--12},
	Publisher = {ACM},
	Title = {Design patterns as higher-order datatype-generic programs},
	Year = {2006},
	Abstract = {Design patterns are reusable abstractions in object-oriented software. However, using current mainstream programming languages, these elements can only be expressed extra-linguistically: as prose, pictures, and prototypes. We believe that this is not inherent in the patterns themselves, but evidence of a lack of expressivity in the languages of today. We expect that, in the languages of the future, the code parts of design patterns will be expressible as reusable library components. Indeed, we claim that the languages of tomorrow will suffice; the future is not far away. All that is needed, in addition to commonly-available features, are higher-order and datatype-generic constructs; these features are already or nearly available now. We argue the case by presenting higher-order datatype-generic programs capturing ORIGAMI, a small suite of patterns for recursive data structures.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGMuLi8uLi9QYXBlcnMvR2liYm9ucy9HaWJib25zIC0gRGVzaWduIHBhdHRlcm5zIGFzIGhpZ2hlci1vcmRlciBkYXRhdHlwZS1nZW5lcmljIHByb2dyYW1zICgyMDA2KS5wZGbSGw8cHVdOUy5kYXRhTxECQAAAAAACQAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZI8H0dpYmJvbnMgLSBEZXNpZ24gcGF0IzJEOTIzOS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkjnDkx8XUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdHaWJib25zAAAQAAgAAME0fl0AAAARAAgAAMOTZWcAAAABABAALZI8AC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpHaWJib25zOkdpYmJvbnMgLSBEZXNpZ24gcGF0IzJEOTIzOS5wZGYADgCeAE4ARwBpAGIAYgBvAG4AcwAgAC0AIABEAGUAcwBpAGcAbgAgAHAAYQB0AHQAZQByAG4AcwAgAGEAcwAgAGgAaQBnAGgAZQByAC0AbwByAGQAZQByACAAZABhAHQAYQB0AHkAcABlAC0AZwBlAG4AZQByAGkAYwAgAHAAcgBvAGcAcgBhAG0AcwAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGpVc2Vycy9qZXJlbXkvUGFwZXJzL0dpYmJvbnMvR2liYm9ucyAtIERlc2lnbiBwYXR0ZXJucyBhcyBoaWdoZXItb3JkZXIgZGF0YXR5cGUtZ2VuZXJpYyBwcm9ncmFtcyAoMjAwNikucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARABFQEdA2EDYwNoA3EDfAOAA44DlQOeA6MDpgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOz},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1159861.1159863}}

@inproceedings{Turbak:Cycle:2001,
	Address = {New York, NY, USA},
	Author = {Franklyn Turbak and J. B. Wells},
	Booktitle = {PPDP '01: Proceedings of the 3rd ACM SIGPLAN international conference on Principles and practice of declarative programming},
	Date-Added = {2007-12-22 20:02:35 -0500},
	Date-Modified = {2007-12-22 20:08:24 -0500},
	Doi = {http://doi.acm.org/10.1145/773184.773200},
	Isbn = {1-58113-388-X},
	Local-Url = {file://localhost/Users/jeremy/Papers/Turbak/Turbak-Wells%20-%20Cycle%20therapy%20a%20prescription%20for%20fold%20and%20unfold%20(2001).pdf},
	Location = {Florence, Italy},
	Pages = {137--149},
	Publisher = {ACM},
	Title = {Cycle therapy: a prescription for fold and unfold on regular trees},
	Year = {2001},
	Abstract = {Cyclic data structures can be tricky to create and manipulate in declarative programming languages. In a declarative setting, a natural way to view cyclic structures is as denoting regular trees, those trees which may be infinite but have only a finite number of distinct subtrees. This paper shows how to implement the unfold (anamorphism) operator in both eager and lazy languages so as to create cyclic structures when the result is a regular tree as opposed to merely infinite lazy structures. The usual fold (catamorphism) operator when used with a strict combining function on any infinite tree yields an undefined result. As an alternative, this paper defines and show how to implement a cycfold operator with more useful semantics when used with a strict function on cyclic structures representing regular trees. This paper also introduces an abstract data type (cycamores) to simplify the use of cyclic structures representing regular trees in both eager and lazy languages. Implementions of cycamores in both SML and Haskell are presented.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEF4uLi8uLi9QYXBlcnMvVHVyYmFrL1R1cmJhay1XZWxscyAtIEN5Y2xlIHRoZXJhcHkgYSBwcmVzY3JpcHRpb24gZm9yIGZvbGQgYW5kIHVuZm9sZCAoMjAwMSkucGRm0hsPHB1XTlMuZGF0YU8RAjIAAAAAAjIAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2SAx9UdXJiYWstV2VsbHMgLSBDeWNsZSMyRDkyMDEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZIBw5MeEFBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGVHVyYmFrABAACAAAwTR+XQAAABEACAAAw5NkYAAAAAEAEAAtkgMALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlR1cmJhazpUdXJiYWstV2VsbHMgLSBDeWNsZSMyRDkyMDEucGRmAAAOAJYASgBUAHUAcgBiAGEAawAtAFcAZQBsAGwAcwAgAC0AIABDAHkAYwBsAGUAIAB0AGgAZQByAGEAcAB5ACAAYQAgAHAAcgBlAHMAYwByAGkAcAB0AGkAbwBuACAAZgBvAHIAIABmAG8AbABkACAAYQBuAGQAIAB1AG4AZgBvAGwAZAAgACgAMgAwADAAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGVVc2Vycy9qZXJlbXkvUGFwZXJzL1R1cmJhay9UdXJiYWstV2VsbHMgLSBDeWNsZSB0aGVyYXB5IGEgcHJlc2NyaXB0aW9uIGZvciBmb2xkIGFuZCB1bmZvbGQgKDIwMDEpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBCwEQARgDTgNQA1UDXgNpA20DewOCA4sDkAOTAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA6A=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/773184.773200}}

@article{Hudak:Conception:1989,
	Address = {New York, NY, USA},
	Author = {Paul Hudak},
	Date-Added = {2007-12-22 19:56:05 -0500},
	Date-Modified = {2008-01-02 18:46:01 -0500},
	Doi = {http://doi.acm.org/10.1145/72551.72554},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Keywords = {history of computing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Hudak/Hudak%20-%20Conception,%20evolution,%20and%20application%20of%20functional%20programming%20(1989).pdf},
	Number = {3},
	Pages = {359--411},
	Publisher = {ACM},
	Rating = {5},
	Read = {Yes},
	Title = {Conception, evolution, and application of functional programming languages},
	Volume = {21},
	Year = {1989},
	Abstract = {The foundations of functional programming languages are examined from both historical and technical perspectives. Their evolution is traced through several critical periods: early work on lambda calculus and combinatory calculus, Lisp, Iswim, FP, ML, and modern functional languages such as Miranda1 and Haskell. The fundamental premises on which the functional programming methodology stands are critically analyzed with respect to philosophical, theoretical, and pragmatic concerns. Particular attention is paid to the main features that characterize modern functional languages: higher-order functions, lazy evaluation, equations and pattern matching, strong static typing and type inference, and data abstraction. In addition, current research areas---such as parallelism, nondeterminism, input/output, and state-oriented computations---are examined with the goal of predicting the future development and application of functional languages.},
	Annote = {Tremendously useful. Quickly moves on from Lisp, and also points out how Lisp isn't really functional so much as a major influence on functional languages. Very valuable for its lucid introduction to lambda calculus basics, including typed lambda calculi. Distinguishes between normal-order reduction and its specific implementation as lazy evaluation. Argues strongly for lazy evaluation being practically useful as well as theoretically. Addresses annotated functional languages (for parallelism or the like) as "parafunctional languages"; also touches briefly on dataflow languages and machines and mentions functional-logic programming in passing as an appealing but at the time not really very viable approach.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGYuLi8uLi9QYXBlcnMvSHVkYWsvSHVkYWsgLSBDb25jZXB0aW9uLCBldm9sdXRpb24sIGFuZCBhcHBsaWNhdGlvbiBvZiBmdW5jdGlvbmFsIHByb2dyYW1taW5nICgxOTg5KS5wZGbSGw8cHVdOUy5kYXRhTxECSgAAAAACSgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZF5H0h1ZGFrIC0gQ29uY2VwdGlvbiwgIzI5Rjg3Qi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp+HsAAAAAAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVIdWRhawAAEAAIAADBNH5dAAAAEQAIAAAAAAAAAAAAAQAQAC2ReQAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6SHVkYWs6SHVkYWsgLSBDb25jZXB0aW9uLCAjMjlGODdCLnBkZgAOAKgAUwBIAHUAZABhAGsAIAAtACAAQwBvAG4AYwBlAHAAdABpAG8AbgAsACAAZQB2AG8AbAB1AHQAaQBvAG4ALAAgAGEAbgBkACAAYQBwAHAAbABpAGMAYQB0AGkAbwBuACAAbwBmACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMQA5ADgAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG1Vc2Vycy9qZXJlbXkvUGFwZXJzL0h1ZGFrL0h1ZGFrIC0gQ29uY2VwdGlvbiwgZXZvbHV0aW9uLCBhbmQgYXBwbGljYXRpb24gb2YgZnVuY3Rpb25hbCBwcm9ncmFtbWluZyAoMTk4OSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgETARgBIANuA3ADdQN+A4kDjQObA6IDqwOwA7MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADwA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/72551.72554}}

@inproceedings{Wadler:Monads:1995,
	Address = {London, UK},
	Author = {Wadler, Philip},
	Booktitle = {Advanced Functional Programming},
	Date-Added = {2007-12-20 19:50:42 -0500},
	Date-Modified = {2007-12-22 19:54:28 -0500},
	Editor = {Jeuring, Johan and Meijer, Erik},
	Keywords = {monads, input-output},
	Local-Url = {file://localhost/Users/jeremy/Papers/Wadler/Wadler%20-%20Monads%20for%20functional%20programming%20(1995).pdf},
	Month = {May},
	Pages = {24--52},
	Publisher = {Springer-Verlag},
	Rating = {3},
	Read = {Yes},
	Series = {Lecture Notes in Computer Science},
	Title = {Monads for functional programming},
	Url = {http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf},
	Volume = {925},
	Year = {1995},
	Abstract = {The use of monads to structure functional programs is described. Moands provide a convenient framework for simulating efects found in other languages, such as global state, exception handling, output, or non-determinism. Three case studies are looked at in detail: how monads ease the modification of a simple evaluator; how monads act as the basis of a datatype of arrays subject to in-place update; and how monads can be used to build parsers.},
	Annote = {Opens with a very lucid discussion of pure versus impure: pure === lambda calculus (easy to reason about), impure === lambda calculus + effects (sometimes enables more compact expression). Shows how monads enable simulation of effects while retaining purity, and derives the monad laws without reference to category theory.

Also gives a good high-level overview of what a pure functional program is (a set of equations), and so the good and bad of being pure: all data flow is (painfully) explicit. 

Raises an interesting question for compile-time optimization: just because we can perform an optimization, should we? What if a program's feasibility depends on the use of that optimization? Is it then time to migrate that optimization from being the compiler's responsibility to the programmer's/language's? When do we cross the line from optimization and simple improvement to a real, marked change?},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEkuLi8uLi9QYXBlcnMvV2FkbGVyL1dhZGxlciAtIE1vbmFkcyBmb3IgZnVuY3Rpb25hbCBwcm9ncmFtbWluZyAoMTk5NSkucGRm0hsPHB1XTlMuZGF0YU8RAfIAAAAAAfIAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2ReB9XYWRsZXIgLSBNb25hZHMgZm9yICMyOUY4OTUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKfiVAAAAAAAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGV2FkbGVyABAACAAAwTR+XQAAABEACAAAAAAAAAAAAAEAEAAtkXgALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOldhZGxlcjpXYWRsZXIgLSBNb25hZHMgZm9yICMyOUY4OTUucGRmAAAOAGwANQBXAGEAZABsAGUAcgAgAC0AIABNAG8AbgBhAGQAcwAgAGYAbwByACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFBVc2Vycy9qZXJlbXkvUGFwZXJzL1dhZGxlci9XYWRsZXIgLSBNb25hZHMgZm9yIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgKDE5OTUpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD2APsBAwL5AvsDAAMJAxQDGAMmAy0DNgM7Az4AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADSw==},
	Bdsk-Url-1 = {http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf}}

@book{Cooper:Engineering:2004,
	Address = {San Francisco},
	Author = {Cooper, Keith D. and Torczon, Linda},
	Date-Added = {2007-12-15 17:09:56 -0500},
	Date-Modified = {2008-02-10 11:14:27 -0500},
	Keywords = {compilation},
	Publisher = {Morgan Kaufmann Publishers},
	Rating = {3},
	Read = {Yes},
	Title = {Engineering a Compiler},
	Year = {2004}}

@book{Scott:Programming:2006,
	Address = {San Francisco},
	Author = {Scott, Michael L.},
	Date-Added = {2007-12-15 17:03:52 -0500},
	Date-Modified = {2008-04-03 12:58:15 -0400},
	Edition = {Second},
	Publisher = {Morgan Kaufmann Publishers},
	Title = {Programming Language Pragmatics},
	Year = {2006}}

@inproceedings{Hudak:A-history:2007,
	Address = {New York},
	Author = {Paul Hudak and John Hughes and Peyton Jones, Simon and Philip Wadler},
	Booktitle = {HOPL III: Proceedings of the third ACM SIGPLAN conference on History of programming languages},
	Date-Added = {2007-12-13 14:58:46 -0500},
	Date-Modified = {2007-12-22 19:54:28 -0500},
	Doi = {http://doi.acm.org/10.1145/1238844.1238856},
	Isbn = {978-1-59593-766-X},
	Keywords = {history of computing, haskell},
	Local-Url = {file://localhost/Users/jeremy/Papers/Hudak/Hudak-Hughes-Peyton%20Jones%20-%20A%20history%20of%20%7BH%7Daskell%20being%20lazy%20with%20(2007).pdf},
	Location = {San Diego, California},
	Pages = {12-1--12-55},
	Publisher = {ACM},
	Rating = {4},
	Read = {Yes},
	Title = {A history of {H}askell: being lazy with class},
	Year = {2007},
	Abstract = {This paper describes the history of Haskell, including its genesis and principles, technical contributions, implementations and tools, and applications and impact.},
	Annote = {Its discussion of implementations and history is particularly helpful for orienting one to Haskell, since there are a lot of compiler/interpreter hangers-on and a lot of history that I haven't seen anywhere else. The section towards the end on Haskell's influence is also very interesting: functional-logic languages, constraint-based programming, functional reactive programming. Neat stuff.

Also includes a concise introduction to Haskell I/O before and after monads.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGAuLi8uLi9QYXBlcnMvSHVkYWsvSHVkYWstSHVnaGVzLVBleXRvbiBKb25lcyAtIEEgaGlzdG9yeSBvZiB7SH1hc2tlbGwgYmVpbmcgbGF6eSB3aXRoICgyMDA3KS5wZGbSGw8cHVdOUy5kYXRhTxECOAAAAAACOAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZF5H0h1ZGFrLUh1Z2hlcy1QZXl0b24gIzI5Rjg3Qy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp+HwAAAAAAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVIdWRhawAAEAAIAADBNH5dAAAAEQAIAAAAAAAAAAAAAQAQAC2ReQAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6SHVkYWs6SHVkYWstSHVnaGVzLVBleXRvbiAjMjlGODdDLnBkZgAOAJwATQBIAHUAZABhAGsALQBIAHUAZwBoAGUAcwAtAFAAZQB5AHQAbwBuACAASgBvAG4AZQBzACAALQAgAEEAIABoAGkAcwB0AG8AcgB5ACAAbwBmACAAewBIAH0AYQBzAGsAZQBsAGwAIABiAGUAaQBuAGcAIABsAGEAegB5ACAAdwBpAHQAaAAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGdVc2Vycy9qZXJlbXkvUGFwZXJzL0h1ZGFrL0h1ZGFrLUh1Z2hlcy1QZXl0b24gSm9uZXMgLSBBIGhpc3Rvcnkgb2Yge0h9YXNrZWxsIGJlaW5nIGxhenkgd2l0aCAoMjAwNykucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgENARIBGgNWA1gDXQNmA3EDdQODA4oDkwOYA5sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1238844.1238856}}

@inproceedings{Peyton-Jones:Tackling:2000,
	Author = {Peyton Jones, Simon L.},
	Booktitle = {2000 Marktoberdorf Summer School},
	Date-Added = {2007-12-12 09:58:16 -0500},
	Date-Modified = {2007-12-22 19:54:28 -0500},
	Keywords = {haskell, monads, input-output, foreign-function interface, lazy evaluation},
	Local-Url = {file://localhost/Users/jeremy/Papers/Peyton%20Jones/Peyton%20Jones%20-%20Tackling%20the%20awkward%20squad%20monadic%20input-output,%20(2000).pdf},
	Rating = {3},
	Read = {Yes},
	Title = {Tackling the awkward squad: monadic input/output, concurrency, exceptions, and foreign-language calls in {H}askell},
	Url = {http://research.microsoft.com/Users/simonpj/papers/marktoberdorf.ps.gz},
	Year = {2000},
	Abstract = {Functional programming may be beautiful, but to write real applications we must grapple with awkward real-world issues: input/output, robustness, concurrency, and interfacing to programs written in other languages.

These lecture notes give an overview of the techniques that have been developed by the Haskell community to address these problems. I introduce various proposed extensions to Haskell along the way, and I offer an operational semantics that explains what these extensions mean.},
	Annote = {Provides a clear introduction to the I/O monad and why it is useful. Introduces briefly the stream model it replaced. Also discusses explicitly parallelizing Haskell via Concurrent Haskell, using IORefs and MVars, exceptions, and the Haskell foreign-function interface and related issues. Valuable as well for its step-by-step development of an operational semantics for these issues.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGQuLi8uLi9QYXBlcnMvUGV5dG9uIEpvbmVzL1BleXRvbiBKb25lcyAtIFRhY2tsaW5nIHRoZSBhd2t3YXJkIHNxdWFkIG1vbmFkaWMgaW5wdXQtb3V0cHV0LCAoMjAwMCkucGRm0hsPHB1XTlMuZGF0YU8RAkQAAAAAAkQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2Reh9QZXl0b24gSm9uZXMgLSBUYWNrbCMyOUY4OTgucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKfiYAAAAAAAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAMUGV5dG9uIEpvbmVzABAACAAAwTR+XQAAABEACAAAAAAAAAAAAAEAEAAtkXoALZE/AANHrAAAa9gAAgBFT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlBleXRvbiBKb25lczpQZXl0b24gSm9uZXMgLSBUYWNrbCMyOUY4OTgucGRmAAAOAJYASgBQAGUAeQB0AG8AbgAgAEoAbwBuAGUAcwAgAC0AIABUAGEAYwBrAGwAaQBuAGcAIAB0AGgAZQAgAGEAdwBrAHcAYQByAGQAIABzAHEAdQBhAGQAIABtAG8AbgBhAGQAaQBjACAAaQBuAHAAdQB0AC0AbwB1AHQAcAB1AHQALAAgACgAMgAwADAAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGtVc2Vycy9qZXJlbXkvUGFwZXJzL1BleXRvbiBKb25lcy9QZXl0b24gSm9uZXMgLSBUYWNrbGluZyB0aGUgYXdrd2FyZCBzcXVhZCBtb25hZGljIGlucHV0LW91dHB1dCwgKDIwMDApLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBEQEWAR4DZgNoA20DdgOBA4UDkwOaA6MDqAOrAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA7g=},
	Bdsk-Url-1 = {http://research.microsoft.com/Users/simonpj/papers/marktoberdorf.ps.gz}}

@comment{BibDesk Static Groups{
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>group name</key>
		<string>Abstract Machines</string>
		<key>keys</key>
		<string>Hudak:A-combinator-based:1984,Johnsson:Efficient:2004,P.-J.-Koopman:A-fresh:1989,Cardelli:Compiling:1984,Peyton-Jones:The-Spineless:1989,Chitnis:Rationalized:1993,Shi:Virtual:2008,Ohori:An-Unboxed:1997,Danvy:A-journey:2003,Reynolds:Definitional:1972,Reid:Putting:1999,Mountjoy:The-Spineless:1999,Hammond:The-Spineless:1993,Shao:A-type-based:1995,Marlow:Faster:2007,Ager:A-functional:2003,Reynolds:Definitional:1998,Peyton-Jones:Implementing:1992,Encina:Formally:2003,Argo:Improving:1989,Biernacka:A-concrete:2007,Choi:Compiling:2001,Douence:A-systematic:1998,Meijer:Down:1993,Philip-J.-Koopman:Cache:1992,Burn:The-spineless:1988,Douence:The-next:2007,Fradet:Compilation:1991,Fairbairn:TIM::1987</string>
	</dict>
	<dict>
		<key>group name</key>
		<string>deforestation</string>
		<key>keys</key>
		<string>Chitil:Type:1999,Elliott:Simply:2008,Mu:Algebra:2008,Gill:A-short:1993</string>
	</dict>
	<dict>
		<key>group name</key>
		<string>NCF Thesis</string>
		<key>keys</key>
		<string>Hudak:Conception:1989,Wyk:Context-aware:2007,Stoyan:Early:1984,Richards:An-overview:1984,Hovemeyer:Finding:2004,Barendregt:Types:1990,Milner:The-Definition:1990,Bannerjee:Loop:1993,Grune:Parsing:2007,Herken:The-Universal:1995,Pottier:Menhir:2007,McKinna:Why-dependent:2006,Bravenboer:Declarative:2006,Scott:Programming:2006,Hindley:The-principal:1969,Turner:Miranda:1985,Kulkarni:Fast:2005,Pierce:Types:2002,Steele-Jr.:The-evolution:1993,Peyton-Jones:Wearing:2003,Wadler:Monads:1995,Iverson:A-programming:1962,McPeak:Elkhound:2002,Paakki:Attribute:1995,McBride:Functional:2004,Olszewski:Churchs:2006,Peyton-Jones:Tackling:2000,Gordon:From:2000,Damas:Principal:1982,Pager:The-lane:1973,Milner:The-Definition:1997,Gansner:The-Standard:2002,Turner:Church:2006,Milner:Commentary:1990,Landin:The-next:1966,Turing:On-Computable:1937,Turner:The-semantic:1981,Backus:Can-programming:1978,Cooper:Engineering:2004,Bravenboer:Concrete:2004,Sestoft:Demonstrating:2002,Lattner:LLVM:2002,Zima:Supercompilers:1991,Hines:Using:2005,Bravenboer:Preventing:2007,Pierce:Advanced:2005,Aho:Principles:1977,Aho:Compilers:1986,Aho:Compilers:2006,Cardelli:On-understanding:1985,Parr:ANTLR:1995,Cousineau:A-brief:1996,Visser:Scannerless:1997,Hennessy:Computer:2006,Wolfe:High-Performance:1996,Patterson:Computer:2007,Spector:Efficient:1988,Hudak:A-history:2007,Turner:SASL:1976,Wadler:Why-no-one-uses:1998,Peyton-Jones:Haskell:2003,Thompson:Type:1991,Hopcroft:Introduction:2007,Layer:Lisp:1991,Brand:Disambiguation:2002,Demaine:Cache-Oblivious:2002,Bannerjee:Loop:1994,Curry:Modified:1969,Altenkirch:Why-Dependent:2005,Bannerjee:Dependence:1988,Muchnick:Advanced:1997,Barendregt:The-Lambda:1984,McCarthy:LISP:1980,Altenkirch:Observational:2007</string>
	</dict>
	<dict>
		<key>group name</key>
		<string>STG</string>
		<key>keys</key>
		<string>Choi:STG-JVM:2001,Reid:Putting:1999,Hammond:The-Spineless:1993,Peyton-Jones:The-Spineless:1989,Peyton-Jones:Unboxed:1991,Peyton-Jones:Implementing:1992,Mountjoy:The-Spineless:1999,Mehnert:STG-slides:2004</string>
	</dict>
	<dict>
		<key>group name</key>
		<string>Textbooks</string>
		<key>keys</key>
		<string>Aho:Principles:1977,Patterson:Computer:2007,Barendregt:The-Lambda:1984,Muchnick:Advanced:1997,Alagic:Relational:1986,Hopcroft:Introduction:2007,Aho:Compilers:1986,Hennessy:Computer:2006,Scott:Programming:2006,Thompson:Type:1991,Jones:Garbage:1996,Aho:Compilers:2006,Cooper:Engineering:2004</string>
	</dict>
</array>
</plist>
}}

@comment{BibDesk Smart Groups{
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>conditions</key>
		<array>
			<dict>
				<key>comparison</key>
				<integer>4</integer>
				<key>key</key>
				<string>Abstract</string>
				<key>value</key>
				<string></string>
				<key>version</key>
				<string>1</string>
			</dict>
		</array>
		<key>conjunction</key>
		<integer>0</integer>
		<key>group name</key>
		<string>Abstract missing</string>
	</dict>
	<dict>
		<key>conditions</key>
		<array>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Journal</string>
				<key>value</key>
				<string>csur</string>
				<key>version</key>
				<string>1</string>
			</dict>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Journal</string>
				<key>value</key>
				<string>comput. surv.</string>
				<key>version</key>
				<string>1</string>
			</dict>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Journal</string>
				<key>value</key>
				<string>survey</string>
				<key>version</key>
				<string>1</string>
			</dict>
		</array>
		<key>conjunction</key>
		<integer>1</integer>
		<key>group name</key>
		<string>CSUR</string>
	</dict>
	<dict>
		<key>conditions</key>
		<array>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Url</string>
				<key>value</key>
				<string>~</string>
				<key>version</key>
				<string>1</string>
			</dict>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Url</string>
				<key>value</key>
				<string>$</string>
				<key>version</key>
				<string>1</string>
			</dict>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Url</string>
				<key>value</key>
				<string>#</string>
				<key>version</key>
				<string>1</string>
			</dict>
		</array>
		<key>conjunction</key>
		<integer>1</integer>
		<key>group name</key>
		<string>Problem URLs</string>
	</dict>
	<dict>
		<key>conditions</key>
		<array>
			<dict>
				<key>comparison</key>
				<integer>4</integer>
				<key>key</key>
				<string>Read</string>
				<key>value</key>
				<string>No</string>
				<key>version</key>
				<string>1</string>
			</dict>
		</array>
		<key>conjunction</key>
		<integer>0</integer>
		<key>group name</key>
		<string>Unread</string>
	</dict>
</array>
</plist>
}}
