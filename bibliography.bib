
%% Created for jeremy at 2008-02-10 17:21:17 -0500 


%% Saved with string encoding Western (ASCII) 



@book{Muchnick:Advanced:1997,
	Author = {Muchnick, Steven S.},
	Date-Added = {2008-02-10 11:11:29 -0500},
	Date-Modified = {2008-02-10 12:15:06 -0500},
	Isbn = {978--1-55860--320--4},
	Keywords = {compilation},
	Publisher = {Academic Press},
	Title = {Advanced Compiler Design and Implementation},
	Year = {1997}}

@inproceedings{Bravenboer:Declarative:2006,
	Address = {New York, NY, USA},
	Author = {Martin Bravenboer and \'{E}ric Tanter and Eelco Visser},
	Booktitle = {OOPSLA '06: Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications},
	Date-Added = {2008-01-19 09:25:07 -0500},
	Date-Modified = {2008-01-19 09:38:17 -0500},
	Doi = {http://doi.acm.org/10.1145/1167473.1167491},
	Isbn = {1-59593-348-4},
	Keywords = {parsing},
	Location = {Portland, Oregon, USA},
	Pages = {209--228},
	Publisher = {ACM},
	Title = {Declarative, formal, and extensible syntax definition for aspect{J}},
	Year = {2006},
	Abstract = {Aspect-Oriented Programming (AOP) is attracting attention from both research and industry, as illustrated by the ever-growing popularity of AspectJ, the de facto standard AOP extension of Java. From a compiler construction perspective AspectJ is interesting as it is a typical example of compositional language, ie a language composed of a number of separate languages with different syntactical styles: in addition to plain Java, AspectJ includes a language for defining pointcuts and one for defining advices. Language composition represents a non-trivial challenge for conventional parsing techniques. First, combining several languages with different lexical syntax leads to considerable complexity in the lexical states to processed. Second, as new language features for AOP are being explored, many research proposals are concerned with further extending the AspectJ language, resulting in a need for an extensible syntax definition.This paper shows how scannerless parsing elegantly addresses the issues encountered by conventional techniques when parsing AspectJ . We present the design of a modular, extensible, and formal definition of the lexical and context-free aspects of the AspectJ syntax in the Syntax Definition Formalism SDF, which is implemented by a scannerless, generalized-LR parser (SGLR). We introduce grammar mixins as a novel application of SDF's modularity features, which allows the declarative definition of different keyword policies and combination of extensions. We illustrate the modular extensibility of our definition with syntax extensions taken from current research on aspect languages. Finally, benchmarks show the reasonable performance of scannerless generalized-LR parsing for this grammar.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHMuLi8uLi9QYXBlcnMvQnJhdmVuYm9lci9CcmF2ZW5ib2VyLVRhbnRlci1WaXNzZXIgLSBEZWNsYXJhdGl2ZSwgZm9ybWFsLCBhbmQgZXh0ZW5zaWJsZSBzeW50YXggZGVmaW5pdGlvbiAoMjAwNikucGRm0hsPHB1XTlMuZGF0YU8RAnAAAAAAAnAAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC7rBx9CcmF2ZW5ib2VyLVRhbnRlci1WaSMyRUVCMkEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALusqw7d0slBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAKQnJhdmVuYm9lcgAQAAgAAME0fl0AAAARAAgAAMO3uwIAAAABABAALusHAC2RPwADR6wAAGvYAAIAQ09kaW46VXNlcnM6amVyZW15OlBhcGVyczpCcmF2ZW5ib2VyOkJyYXZlbmJvZXItVGFudGVyLVZpIzJFRUIyQS5wZGYAAA4AuABbAEIAcgBhAHYAZQBuAGIAbwBlAHIALQBUAGEAbgB0AGUAcgAtAFYAaQBzAHMAZQByACAALQAgAEQAZQBjAGwAYQByAGEAdABpAHYAZQAsACAAZgBvAHIAbQBhAGwALAAgAGEAbgBkACAAZQB4AHQAZQBuAHMAaQBiAGwAZQAgAHMAeQBuAHQAYQB4ACAAZABlAGYAaQBuAGkAdABpAG8AbgAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHpVc2Vycy9qZXJlbXkvUGFwZXJzL0JyYXZlbmJvZXIvQnJhdmVuYm9lci1UYW50ZXItVmlzc2VyIC0gRGVjbGFyYXRpdmUsIGZvcm1hbCwgYW5kIGV4dGVuc2libGUgc3ludGF4IGRlZmluaXRpb24gKDIwMDYpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEgASUBLQOhA6MDqAOxA7wDwAPOA9UD3gPjA+YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAD8w==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1167473.1167491}}

@book{Hopcroft:Introduction:2007,
	Author = {Hopcroft, John E. and Motwani, Rajeev and Ullman, Jeffrey D.},
	Date-Added = {2008-02-08 18:53:33 -0500},
	Date-Modified = {2008-02-10 14:43:14 -0500},
	Edition = {Third},
	Isbn = {978--0--23--146225--1},
	Month = {July},
	Publisher = {Addison-Wesley Higher Education},
	Title = {Introduction to Automata Theory, Languages, and Computation},
	Url = {http://infolab.stanford.edu/~ullman/ialc.html},
	Year = {2007},
	Bdsk-Url-1 = {http://infolab.stanford.edu/~ullman/ialc.html}}

@inproceedings{Pager:The-lane:1973,
	Address = {New York, NY, USA},
	Author = {David Pager},
	Booktitle = {STOC '73: Proceedings of the fifth annual ACM symposium on Theory of computing},
	Date-Added = {2007-12-22 20:26:54 -0500},
	Date-Modified = {2008-01-17 21:17:29 -0500},
	Doi = {http://doi.acm.org/10.1145/800125.804048},
	Keywords = {parsing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Pager/Pager%20-%20The%20lane%20tracing%20algorithm%20for%20constructing%20LR(k)%20(1973).pdf},
	Location = {Austin, Texas, United States},
	Pages = {172--181},
	Publisher = {ACM},
	Rating = {3},
	Read = {Yes},
	Title = {The lane tracing algorithm for constructing LR(k) parsers},
	Year = {1973},
	Abstract = {The paper presents, as far as the author is aware, the first practical general method for constructing LR(k) parsers. It has been used, without computational difficulty, to produce LR(1), LR(2) and LR(3) parsers for grammars of the size of ALGOL.},
	Annote = {Pager's description of LR(0) parsing is the most lucid I've read thus far. Unfortunately, he's confusing when it comes to describing his new ideas. That's likely due to lack of oversight (it is a non-refereed tech report) and Pager still trying to figure out how best to describe his idea. This tech report grew up to be a publication in Acta Informatica.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFcuLi8uLi9QYXBlcnMvUGFnZXIvUGFnZXIgLSBUaGUgbGFuZSB0cmFjaW5nIGFsZ29yaXRobSBmb3IgY29uc3RydWN0aW5nIExSKGspICgxOTczKS5wZGbSGw8cHVdOUy5kYXRhTxECHAAAAAACHAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZL5H1BhZ2VyIC0gVGhlIGxhbmUgdHJhIzJEOTJGNy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkvfDkySuUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVQYWdlcgAAEAAIAADBNH5dAAAAEQAIAADDk2r+AAAAAQAQAC2S+QAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6UGFnZXI6UGFnZXIgLSBUaGUgbGFuZSB0cmEjMkQ5MkY3LnBkZgAOAIoARABQAGEAZwBlAHIAIAAtACAAVABoAGUAIABsAGEAbgBlACAAdAByAGEAYwBpAG4AZwAgAGEAbABnAG8AcgBpAHQAaABtACAAZgBvAHIAIABjAG8AbgBzAHQAcgB1AGMAdABpAG4AZwAgAEwAUgAoAGsAKQAgACgAMQA5ADcAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF5Vc2Vycy9qZXJlbXkvUGFwZXJzL1BhZ2VyL1BhZ2VyIC0gVGhlIGxhbmUgdHJhY2luZyBhbGdvcml0aG0gZm9yIGNvbnN0cnVjdGluZyBMUihrKSAoMTk3MykucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQQBCQERAzEDMwM4A0EDTANQA14DZQNuA3MDdgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOD},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/800125.804048}}

@inproceedings{Hines:Using:2005,
	Address = {New York, NY, USA},
	Author = {Stephen Hines and Prasad Kulkarni and David Whalley and Jack Davidson},
	Booktitle = {EMSOFT '05: Proceedings of the 5th ACM international conference on Embedded software},
	Date-Added = {2008-02-04 20:41:39 -0500},
	Date-Modified = {2008-02-04 20:45:28 -0500},
	Doi = {http://doi.acm.org/10.1145/1086228.1086251},
	Isbn = {1-59593-091-4},
	Keywords = {optimization phase ordering},
	Location = {Jersey City, NJ, USA},
	Pages = {114--123},
	Publisher = {ACM},
	Title = {Using de-optimization to re-optimize code},
	Year = {2005},
	Abstract = {The nature of embedded systems development places a great deal of importance on meeting strict requirements in areas such as static code size, power consumption, and execution time. In order to meet these requirements, embedded developers frequently generate and tune assembly code for applications by hand, despite the disadvantages of coding at a low level. The phase ordering problem is a well-known problem affecting the design of optimizing compilers. Hand-tuned code is susceptible to an analogous problem to phase ordering due to the process of iterative refinement, but there has been little research in mitigating its effect on the quality of the generated code. This paper presents an extension of the VISTA framework for investigating the effect and potential benefit of performing de-optimization before re-optimizing assembly code. The design and implementation of algorithms for de-optimization of both loop-invariant code motion and register allocation, along with results of experiments regarding de-optimization and re-optimization of previously generated assembly code are also presented.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGAuLi8uLi9QYXBlcnMvSGluZXMvSGluZXMtS3Vsa2FybmktV2hhbGxleSAtIFVzaW5nIGRlLW9wdGltaXphdGlvbiB0byByZS1vcHRpbWl6ZSBjb2RlICgyMDA1KS5wZGbSGw8cHVdOUy5kYXRhTxECOAAAAAACOAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAL9j2H0hpbmVzLUt1bGthcm5pLVdoYWxsIzJGRDhFQy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv2OzDzSjwUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVIaW5lcwAAEAAIAADBNH5dAAAAEQAIAADDzW9AAAAAAQAQAC/Y9gAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6SGluZXM6SGluZXMtS3Vsa2FybmktV2hhbGwjMkZEOEVDLnBkZgAOAJwATQBIAGkAbgBlAHMALQBLAHUAbABrAGEAcgBuAGkALQBXAGgAYQBsAGwAZQB5ACAALQAgAFUAcwBpAG4AZwAgAGQAZQAtAG8AcAB0AGkAbQBpAHoAYQB0AGkAbwBuACAAdABvACAAcgBlAC0AbwBwAHQAaQBtAGkAegBlACAAYwBvAGQAZQAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGdVc2Vycy9qZXJlbXkvUGFwZXJzL0hpbmVzL0hpbmVzLUt1bGthcm5pLVdoYWxsZXkgLSBVc2luZyBkZS1vcHRpbWl6YXRpb24gdG8gcmUtb3B0aW1pemUgY29kZSAoMjAwNSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgENARIBGgNWA1gDXQNmA3EDdQODA4oDkwOYA5sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1086228.1086251}}

@inproceedings{Bravenboer:Preventing:2007,
	Address = {New York, NY, USA},
	Author = {Martin Bravenboer and Eelco Dolstra and Eelco Visser},
	Booktitle = {GPCE '07: Proceedings of the 6th international conference on Generative programming and component engineering},
	Date-Added = {2008-01-19 09:34:02 -0500},
	Date-Modified = {2008-01-19 09:38:17 -0500},
	Doi = {http://doi.acm.org/10.1145/1289971.1289975},
	Isbn = {978-1-59593-855-8},
	Keywords = {parsing},
	Location = {Salzburg, Austria},
	Pages = {3--12},
	Publisher = {ACM},
	Title = {Preventing injection attacks with syntax embeddings},
	Year = {2007},
	Abstract = {Software written in one language often needs to construct sentences in another language, such as SQL queries, XML output, or shell command invocations. This is almost always done using unhygienic string manipulation, the concatenation of constants and client-supplied strings. A client can then supply specially crafted input that causes the constructed sentence to be interpreted in an unintended way, leading to an injection attack. We describe a more natural style of programming that yields code that is impervious to injections by construction. Our approach embeds the grammars of the guest languages (e.g., SQL) into that of the host language (e.g., Java) and automatically generates code that maps the embedded language to constructs in the host language that reconstruct the embedded sentences, adding escaping functions where appropriate. This approach is generic, meaning that it can be applied with relative ease to any combination of host and guest languages.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGcuLi8uLi9QYXBlcnMvQnJhdmVuYm9lci9CcmF2ZW5ib2VyLURvbHN0cmEtVmlzc2VyIC0gUHJldmVudGluZyBpbmplY3Rpb24gYXR0YWNrcyB3aXRoIHN5bnRheCAoMjAwNykucGRm0hsPHB1XTlMuZGF0YU8RAkwAAAAAAkwAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC7rBx9CcmF2ZW5ib2VyLURvbHN0cmEtViMyRUVCM0QucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALus9w7d07FBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAKQnJhdmVuYm9lcgAQAAgAAME0fl0AAAARAAgAAMO3uzwAAAABABAALusHAC2RPwADR6wAAGvYAAIAQ09kaW46VXNlcnM6amVyZW15OlBhcGVyczpCcmF2ZW5ib2VyOkJyYXZlbmJvZXItRG9sc3RyYS1WIzJFRUIzRC5wZGYAAA4AoABPAEIAcgBhAHYAZQBuAGIAbwBlAHIALQBEAG8AbABzAHQAcgBhAC0AVgBpAHMAcwBlAHIAIAAtACAAUAByAGUAdgBlAG4AdABpAG4AZwAgAGkAbgBqAGUAYwB0AGkAbwBuACAAYQB0AHQAYQBjAGsAcwAgAHcAaQB0AGgAIABzAHkAbgB0AGEAeAAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG5Vc2Vycy9qZXJlbXkvUGFwZXJzL0JyYXZlbmJvZXIvQnJhdmVuYm9lci1Eb2xzdHJhLVZpc3NlciAtIFByZXZlbnRpbmcgaW5qZWN0aW9uIGF0dGFja3Mgd2l0aCBzeW50YXggKDIwMDcpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEUARkBIQNxA3MDeAOBA4wDkAOeA6UDrgOzA7YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADww==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1289971.1289975}}

@article{Kulkarni:Fast:2005,
	Address = {New York, NY, USA},
	Author = {Prasad A. Kulkarni and Stephen R. Hines and David B. Whalley and Jason D. Hiser and Jack W. Davidson and Douglas L. Jones},
	Date-Added = {2007-12-22 21:09:24 -0500},
	Date-Modified = {2007-12-22 21:10:19 -0500},
	Doi = {http://doi.acm.org/10.1145/1071604.1071607},
	Issn = {1544-3566},
	Journal = {ACM Trans. Archit. Code Optim.},
	Keywords = {optimization phase ordering},
	Local-Url = {file://localhost/Users/jeremy/Papers/Kulkarni/Kulkarni-Hines-Whalley%20-%20Fast%20and%20efficient%20searches%20for%20effective%20optimization-phase%20(2005).pdf},
	Number = {2},
	Pages = {165--198},
	Publisher = {ACM},
	Title = {Fast and efficient searches for effective optimization-phase sequences},
	Volume = {2},
	Year = {2005},
	Abstract = {It has long been known that a fixed ordering of optimization phases will not produce the best code for every application. One approach for addressing this phase-ordering problem is to use an evolutionary algorithm to search for a specific sequence of phases for each module or function. While such searches have been shown to produce more efficient code, the approach can be extremely slow because the application is compiled and possibly executed to evaluate each sequence's effectiveness. Consequently, evolutionary or iterative compilation schemes have been promoted for compilation systems targeting embedded applications where meeting strict constraints on execution time, code size, and power consumption is paramount and longer compilation times may be tolerated in the final stage of development, when an application is compiled one last time and embedded in a product. Unfortunately, even for small embedded applications, the search process can take many hours or even days making the approach less attractive to developers. In this paper, we describe two complementary general approaches for achieving faster searches for effective optimization sequences when using a genetic algorithm. The first approach reduces the search time by avoiding unnecessary executions of the application when possible. Results indicate search time reductions of 62%;, on average, often reducing searches from hours to minutes. The second approach modifies the search so fewer generations are required to achieve the same results. Measurements show this approach decreases the average number of required generations by 59%. These improvements have the potential for making evolutionary compilation a viable choice for tuning embedded applications.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHYuLi8uLi9QYXBlcnMvS3Vsa2FybmkvS3Vsa2FybmktSGluZXMtV2hhbGxleSAtIEZhc3QgYW5kIGVmZmljaWVudCBzZWFyY2hlcyBmb3IgZWZmZWN0aXZlIG9wdGltaXphdGlvbi1waGFzZSAoMjAwNSkucGRm0hsPHB1XTlMuZGF0YU8RAnoAAAAAAnoAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2T8h9LdWxrYXJuaS1IaW5lcy1XaGFsbCMyRDkzRkIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZP7w5MtkFBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIS3Vsa2FybmkAEAAIAADBNH5dAAAAEQAIAADDk3PgAAAAAQAQAC2T8gAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6S3Vsa2Fybmk6S3Vsa2FybmktSGluZXMtV2hhbGwjMkQ5M0ZCLnBkZgAADgDCAGAASwB1AGwAawBhAHIAbgBpAC0ASABpAG4AZQBzAC0AVwBoAGEAbABsAGUAeQAgAC0AIABGAGEAcwB0ACAAYQBuAGQAIABlAGYAZgBpAGMAaQBlAG4AdAAgAHMAZQBhAHIAYwBoAGUAcwAgAGYAbwByACAAZQBmAGYAZQBjAHQAaQB2AGUAIABvAHAAdABpAG0AaQB6AGEAdABpAG8AbgAtAHAAaABhAHMAZQAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAH1Vc2Vycy9qZXJlbXkvUGFwZXJzL0t1bGthcm5pL0t1bGthcm5pLUhpbmVzLVdoYWxsZXkgLSBGYXN0IGFuZCBlZmZpY2llbnQgc2VhcmNoZXMgZm9yIGVmZmVjdGl2ZSBvcHRpbWl6YXRpb24tcGhhc2UgKDIwMDUpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBIwEoATADrgOwA7UDvgPJA80D2wPiA+sD8APzAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAABAA=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1071604.1071607}}

@inproceedings{Bravenboer:Concrete:2004,
	Address = {New York, NY, USA},
	Author = {Martin Bravenboer and Eelco Visser},
	Booktitle = {OOPSLA '04: Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications},
	Date-Added = {2008-01-19 09:34:24 -0500},
	Date-Modified = {2008-01-19 09:38:17 -0500},
	Doi = {http://doi.acm.org/10.1145/1028976.1029007},
	Isbn = {1-58113-831-9},
	Keywords = {parsing},
	Location = {Vancouver, BC, Canada},
	Pages = {365--383},
	Publisher = {ACM},
	Title = {Concrete syntax for objects: domain-specific language embedding and assimilation without restrictions},
	Year = {2004},
	Abstract = {Application programmer's interfaces give access to domain knowledge encapsulated in class libraries without providing the appropriate notation for expressing domain composition. Since object-oriented languages are designed for extensibility and reuse, the language constructs are often sufficient for expressing domain abstractions at the semantic level. However, they do not provide the right abstractions at the syntactic level. In this paper we describe MetaBorg, a method for providing <i>concrete syntax</i> for domain abstractions to application programmers. The method consists of <i>embedding</i> domain-specific languages in a general purpose host language and <i>assimilating</i> the embedded domain code into the surrounding host code. Instead of extending the implementation of the host language, the assimilation phase implements domain abstractions in terms of existing APIs leaving the host language undisturbed. Indeed, MetaBorg can be considered a method for promoting APIs to the language level. The method is supported by proven and available technology, i.e. the syntax definition formalism SDF and the program transformation language and toolset Stratego/XT. We illustrate the method with applications in three domains: code generation, XML generation, and user-interface construction.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGwuLi8uLi9QYXBlcnMvQnJhdmVuYm9lci9CcmF2ZW5ib2VyLVZpc3NlciAtIENvbmNyZXRlIHN5bnRheCBmb3Igb2JqZWN0czogZG9tYWluLXNwZWNpZmljIGxhbmd1YWdlICgyMDA0KS5wZGbSGw8cHVdOUy5kYXRhTxECXAAAAAACXAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALusHH0JyYXZlbmJvZXItVmlzc2VyIC0gIzJFRUI0NC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAu60TDt3U9UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAApCcmF2ZW5ib2VyABAACAAAwTR+XQAAABEACAAAw7e7jQAAAAEAEAAu6wcALZE/AANHrAAAa9gAAgBDT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkJyYXZlbmJvZXI6QnJhdmVuYm9lci1WaXNzZXIgLSAjMkVFQjQ0LnBkZgAADgCqAFQAQgByAGEAdgBlAG4AYgBvAGUAcgAtAFYAaQBzAHMAZQByACAALQAgAEMAbwBuAGMAcgBlAHQAZQAgAHMAeQBuAHQAYQB4ACAAZgBvAHIAIABvAGIAagBlAGMAdABzAC8AIABkAG8AbQBhAGkAbgAtAHMAcABlAGMAaQBmAGkAYwAgAGwAYQBuAGcAdQBhAGcAZQAgACgAMgAwADAANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHNVc2Vycy9qZXJlbXkvUGFwZXJzL0JyYXZlbmJvZXIvQnJhdmVuYm9lci1WaXNzZXIgLSBDb25jcmV0ZSBzeW50YXggZm9yIG9iamVjdHM6IGRvbWFpbi1zcGVjaWZpYyBsYW5ndWFnZSAoMjAwNCkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEZAR4BJgOGA4gDjQOWA6EDpQOzA7oDwwPIA8sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAD2A==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1028976.1029007}}

@inproceedings{Wyk:Context-aware:2007,
	Address = {New York, NY, USA},
	Author = {Eric R. Van Wyk and August C. Schwerdfeger},
	Booktitle = {GPCE '07: Proceedings of the 6th international conference on Generative programming and component engineering},
	Date-Added = {2007-12-22 20:28:09 -0500},
	Date-Modified = {2007-12-22 20:33:22 -0500},
	Doi = {http://doi.acm.org/10.1145/1289971.1289983},
	Isbn = {978-1-59593-855-8},
	Keywords = {parsing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Wyk/Wyk-Schwerdfeger%20-%20Context-aware%20scanning%20for%20parsing%20extensible%20languages%20(2007).pdf},
	Location = {Salzburg, Austria},
	Pages = {63--72},
	Publisher = {ACM},
	Title = {Context-aware scanning for parsing extensible languages},
	Year = {2007},
	Abstract = {This paper introduces new parsing and context-aware scanning algorithms in which the scanner uses contextual information to disambiguate lexical syntax. The parser uses a slightly modified LR-style algorithm that passes to the scanner the set of valid symbols that the scanner may return at that point in parsing. This set is those terminals whose entries in the parse table for the current parse state are shift, reduce, or accept, but not error. The scanner then only returns tokens in this set. An analysis is given that can statically verify that the scanner will never return more than one token for a single input. Context-aware scanning is especially useful when parsing and scanning extensible languages in which domain specific languages can be embedded. It has been used in extensible versions of Java 1.4 and ANSI C. We illustrate this approach with a declarative specification of a subset of Java and extensions that embed SQL queries and Boolean expression tables into Java.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGYuLi8uLi9QYXBlcnMvV3lrL1d5ay1TY2h3ZXJkZmVnZXIgLSBDb250ZXh0LWF3YXJlIHNjYW5uaW5nIGZvciBwYXJzaW5nIGV4dGVuc2libGUgbGFuZ3VhZ2VzICgyMDA3KS5wZGbSGw8cHVdOUy5kYXRhTxECSgAAAAACSgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZLhH1d5ay1TY2h3ZXJkZmVnZXIgLSBDIzJEOTJERi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkt/DkyRBUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAANXeWsAABAACAAAwTR+XQAAABEACAAAw5NqkQAAAAEAEAAtkuEALZE/AANHrAAAa9gAAgA8T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOld5azpXeWstU2Nod2VyZGZlZ2VyIC0gQyMyRDkyREYucGRmAA4ArABVAFcAeQBrAC0AUwBjAGgAdwBlAHIAZABmAGUAZwBlAHIAIAAtACAAQwBvAG4AdABlAHgAdAAtAGEAdwBhAHIAZQAgAHMAYwBhAG4AbgBpAG4AZwAgAGYAbwByACAAcABhAHIAcwBpAG4AZwAgAGUAeAB0AGUAbgBzAGkAYgBsAGUAIABsAGEAbgBnAHUAYQBnAGUAcwAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG1Vc2Vycy9qZXJlbXkvUGFwZXJzL1d5ay9XeWstU2Nod2VyZGZlZ2VyIC0gQ29udGV4dC1hd2FyZSBzY2FubmluZyBmb3IgcGFyc2luZyBleHRlbnNpYmxlIGxhbmd1YWdlcyAoMjAwNykucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgETARgBIANuA3ADdQN+A4kDjQObA6IDqwOwA7MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADwA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1289971.1289983}}

@article{Spector:Efficient:1988,
	Address = {New York, NY, USA},
	Author = {D. Spector},
	Date-Added = {2008-01-14 01:10:52 -0500},
	Date-Modified = {2008-01-17 21:19:51 -0500},
	Doi = {http://doi.acm.org/10.1145/57669.57684},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Keywords = {parsing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Spector/Spector%20-%20Efficient%20full%20LR(I)%20parser%20generation%20(1988).pdf},
	Number = {12},
	Pages = {143--150},
	Publisher = {ACM},
	Rating = {4},
	Read = {Yes},
	Title = {Efficient full LR(I) parser generation},
	Volume = {23},
	Year = {1988},
	Abstract = {This paper proposes that full LR(1) parser generators are easier to use than the LALR(1) parser generators commonly in use, and that minimal-state full LR(1) tables are not much larger than LALR(1) tables. A method is presented for the automatic construction of minimal-state full LR(1) parser tables. The method is fast and accurate because it starts with the LR(0) table and resolves lookahead ambiguities as necessary by tracing the LR(0) table and splitting the minimum number of states, and because there is no need for generalized set manipulation.},
	Annote = {Spector clearly explains in one page what Pager spent ten pages being confusing about. Basically: Generate an LR(0) parser, throw in one token of lookahead, zero in on inadequate states, and split them to reflect the left context that suffices to disambiguate them. Spector includes output from a parser generator he wrote that employs this technique.

Spector also gives a good, concise argument for why LR(1) parser generators are better than LALR(1). His arguments against LALR(1) parser generators are still valid twenty years later.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFAuLi8uLi9QYXBlcnMvU3BlY3Rvci9TcGVjdG9yIC0gRWZmaWNpZW50IGZ1bGwgTFIoSSkgcGFyc2VyIGdlbmVyYXRpb24gKDE5ODgpLnBkZtIbDxwdV05TLmRhdGFPEQIIAAAAAAIIAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAugiMfU3BlY3RvciAtIEVmZmljaWVudCAjMkU4MjE3LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC6CF8OwZuVQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAB1NwZWN0b3IAABAACAAAwTR+XQAAABEACAAAw7CtNQAAAAEAEAAugiMALZE/AANHrAAAa9gAAgBAT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlNwZWN0b3I6U3BlY3RvciAtIEVmZmljaWVudCAjMkU4MjE3LnBkZgAOAHgAOwBTAHAAZQBjAHQAbwByACAALQAgAEUAZgBmAGkAYwBpAGUAbgB0ACAAZgB1AGwAbAAgAEwAUgAoAEkAKQAgAHAAYQByAHMAZQByACAAZwBlAG4AZQByAGEAdABpAG8AbgAgACgAMQA5ADgAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFdVc2Vycy9qZXJlbXkvUGFwZXJzL1NwZWN0b3IvU3BlY3RvciAtIEVmZmljaWVudCBmdWxsIExSKEkpIHBhcnNlciBnZW5lcmF0aW9uICgxOTg4KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAP0BAgEKAxYDGAMdAyYDMQM1A0MDSgNTA1gDWwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANo},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/57669.57684}}

@book{Cooper:Engineering:2004,
	Address = {San Francisco},
	Author = {Cooper, Keith D. and Torczon, Linda},
	Date-Added = {2007-12-15 17:09:56 -0500},
	Date-Modified = {2008-02-10 11:14:27 -0500},
	Keywords = {compilation},
	Publisher = {Morgan Kaufmann Publishers},
	Rating = {3},
	Read = {Yes},
	Title = {Engineering a Compiler},
	Year = {2004}}

@techreport{McPeak:Elkhound:2002,
	Address = {Berkeley, California, USA},
	Author = {McPeak, Scott},
	Date-Added = {2008-02-10 12:54:30 -0500},
	Date-Modified = {2008-02-10 14:43:23 -0500},
	Institution = {University of California, Berkeley},
	Keywords = {parsing},
	Month = {December},
	Number = {UCB/CSD--2--1214},
	Title = {Elkhound: {A} Fast, Practical {GLR} Parser Generator},
	Url = {http://www.cs.berkeley.edu/~smcpeak/elkhound/},
	Year = {2002},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFguLi8uLi9QYXBlcnMvTWNQZWFrL01jUGVhayAtIEVsa2hvdW5kOiBBIEZhc3QsIFByYWN0aWNhbCBHTFIgUGFyc2VyIEdlbmVyYXRvciAoMjAwMikucGRm0hsPHB1XTlMuZGF0YU8RAiAAAAAAAiAAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADAS+B9NY1BlYWsgLSBFbGtob3VuZC8gQSMyRTdGRkQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALn/9w7BQaQAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGTWNQZWFrABAACAAAwTR+XQAAABEACAAAw7CWuQAAAAEAEAAwEvgALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOk1jUGVhazpNY1BlYWsgLSBFbGtob3VuZC8gQSMyRTdGRkQucGRmAAAOAIoARABNAGMAUABlAGEAawAgAC0AIABFAGwAawBoAG8AdQBuAGQALwAgAEEAIABGAGEAcwB0ACwAIABQAHIAYQBjAHQAaQBjAGEAbAAgAEcATABSACAAUABhAHIAcwBlAHIAIABHAGUAbgBlAHIAYQB0AG8AcgAgACgAMgAwADAAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF9Vc2Vycy9qZXJlbXkvUGFwZXJzL01jUGVhay9NY1BlYWsgLSBFbGtob3VuZDogQSBGYXN0LCBQcmFjdGljYWwgR0xSIFBhcnNlciBHZW5lcmF0b3IgKDIwMDIpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBBQEKARIDNgM4Az0DRgNRA1UDYwNqA3MDeAN7AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA4g=}}

@manual{Pottier:Menhir:2007,
	Author = {Pottier, Fran{\c c}ois and R{\'e}gis-Gianis, Yann},
	Date-Added = {2008-02-10 13:29:59 -0500},
	Date-Modified = {2008-02-10 14:43:37 -0500},
	Keywords = {parsing},
	Month = {December},
	Organization = {INRIA},
	Title = {Menhir Reference Manual},
	Url = {http://cristal.inria.fr/~fpottier/menhir/},
	Year = {2007}}

@book{Grune:Parsing:2007,
	Author = {Grune, Dick and Jacobs, Ceriel J.\ H.},
	Date-Added = {2008-02-10 14:04:15 -0500},
	Date-Modified = {2008-02-10 14:08:47 -0500},
	Edition = {Second},
	Isbn = {978--0--387--20248--8},
	Keywords = {parsing},
	Note = {Complete first edition available online at \url{http://www.cs.vu.nl/$\sim$dick/PTAPG.html}},
	Publisher = {Spring-Verlag},
	Title = {Parsing Techniques: {A} Practical Guide},
	Year = {2007}}

@article{Parr:ANTLR:1995,
	Address = {New York, NY, USA},
	Author = {T. J. Parr and R. W. Quong},
	Date-Added = {2008-02-10 13:49:52 -0500},
	Date-Modified = {2008-02-10 14:10:28 -0500},
	Doi = {http://dx.doi.org/10.1002/spe.4380250705},
	Issn = {0038-0644},
	Journal = {Softw. Pract. Exper.},
	Keywords = {parsing},
	Note = {Current information on ANTLR is available from \url{http://www.antlr.org/}},
	Number = {7},
	Pages = {789--810},
	Publisher = {John Wiley \& Sons, Inc.},
	Title = {{ANTLR}: {A} predicated-{LL}($k$) parser generator},
	Url = {http://www.antlr.org/article/1055550346383/antlr.pdf},
	Volume = {25},
	Year = {1995},
	Abstract = {Despite the parsing power of LR/LALR algorithms, e.g. YACC, programmers often choose to write recursive-descent parsers by hand to obtain increased flexibility, better error handling, and ease of debugging. We introduce ANTLR, a public-domain parser generator that combines the flexibility of hand-coded parsing with the convenience of a parser generator, which is a component of PCCTS. ANTLR has many features that make it easier to use than other language tools. Most important, ANTLR provides predicates which let the programmer systematically direct the parse via arbitrary expressions using semantic and syntactic context; in practice, the use of predicates eliminates the need to hand-tweak the ANTLR output, even for difficult parsing problems. ANTLR also integrates the description of lexical and syntactic analysis, accepts LL(k) grammars for k > 1 with extended BNF notation, and can automatically generate abstract syntax trees.
ANTLR is widely used, with over 1000 registered industrial and academic users in 37 countries. It has been ported to many popular systems such as the PC, Macintosh, and a variety of UNIX platforms; a commercial C++ front-end has been developed as a result of one of our industrial collaborations.},
	Bdsk-Url-1 = {http://dx.doi.org/10.1002/spe.4380250705},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFYuLi8uLi9QYXBlcnMvUGFyci9QYXJyLVF1b25nIC0gQU5UTFI6IEEgcHJlZGljYXRlZC1MTCgkayQpIHBhcnNlciBnZW5lcmF0b3IgKDE5OTUpLnBkZtIbDxwdV05TLmRhdGFPEQIaAAAAAAIaAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAwFAQfUGFyci1RdW9uZyAtIEFOVExSLyAjMzAxM0Y1LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAT9cPUslQAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABFBhcnIAEAAIAADBNH5dAAAAEQAIAADD1PikAAAAAQAQADAUBAAtkT8AA0esAABr2AACAD1PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6UGFycjpQYXJyLVF1b25nIC0gQU5UTFIvICMzMDEzRjUucGRmAAAOAIoARABQAGEAcgByAC0AUQB1AG8AbgBnACAALQAgAEEATgBUAEwAUgAvACAAQQAgAHAAcgBlAGQAaQBjAGEAdABlAGQALQBMAEwAKAAkAGsAJAApACAAcABhAHIAcwBlAHIAIABnAGUAbgBlAHIAYQB0AG8AcgAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF1Vc2Vycy9qZXJlbXkvUGFwZXJzL1BhcnIvUGFyci1RdW9uZyAtIEFOVExSOiBBIHByZWRpY2F0ZWQtTEwoJGskKSBwYXJzZXIgZ2VuZXJhdG9yICgxOTk1KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQMBCAEQAy4DMAM1Az4DSQNNA1sDYgNrA3ADcwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOA}}

@book{Aho:Compilers:2006,
	Author = {Aho, Alfred V. and Sethi, Ravi and Ullman, Jeffrey D. and Lam, Monica S.},
	Date-Added = {2008-02-10 14:28:34 -0500},
	Date-Modified = {2008-02-10 14:37:19 -0500},
	Edition = {Second},
	Isbn = {978--0--321--48681--1},
	Month = {August},
	Note = {Also known as the ``Purple Dragon''},
	Publisher = {Addison-Wesley Higher Education},
	Title = {Compilers: {P}rinciples, Techniques, and Tools},
	Year = {2006}}

@comment{BibDesk Static Groups{
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>group name</key>
		<string>NCF Thesis</string>
		<key>keys</key>
		<string>Pottier:Menhir:2007,Aho:Compilers:2006,Muchnick:Advanced:1997,Bravenboer:Declarative:2006,Hopcroft:Introduction:2007,Pager:The-lane:1973,Parr:ANTLR:1995,Hines:Using:2005,Bravenboer:Preventing:2007,Kulkarni:Fast:2005,Bravenboer:Concrete:2004,Wyk:Context-aware:2007,McPeak:Elkhound:2002,Grune:Parsing:2007,Spector:Efficient:1988,Cooper:Engineering:2004</string>
	</dict>
	<dict>
		<key>group name</key>
		<string>Textbooks</string>
		<key>keys</key>
		<string>Cooper:Engineering:2004,Muchnick:Advanced:1997,Scott:Programming:2006,Hopcroft:Introduction:2007</string>
	</dict>
</array>
</plist>
}}

@comment{BibDesk Smart Groups{
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>conditions</key>
		<array>
			<dict>
				<key>comparison</key>
				<integer>4</integer>
				<key>key</key>
				<string>Abstract</string>
				<key>value</key>
				<string></string>
				<key>version</key>
				<string>1</string>
			</dict>
		</array>
		<key>conjunction</key>
		<integer>0</integer>
		<key>group name</key>
		<string>Abstract missing</string>
	</dict>
	<dict>
		<key>conditions</key>
		<array>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Journal</string>
				<key>value</key>
				<string>csur</string>
				<key>version</key>
				<string>1</string>
			</dict>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Journal</string>
				<key>value</key>
				<string>comput. surv.</string>
				<key>version</key>
				<string>1</string>
			</dict>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Journal</string>
				<key>value</key>
				<string>survey</string>
				<key>version</key>
				<string>1</string>
			</dict>
		</array>
		<key>conjunction</key>
		<integer>1</integer>
		<key>group name</key>
		<string>CSUR</string>
	</dict>
	<dict>
		<key>conditions</key>
		<array>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Url</string>
				<key>value</key>
				<string>~</string>
				<key>version</key>
				<string>1</string>
			</dict>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Url</string>
				<key>value</key>
				<string>$</string>
				<key>version</key>
				<string>1</string>
			</dict>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Url</string>
				<key>value</key>
				<string>#</string>
				<key>version</key>
				<string>1</string>
			</dict>
		</array>
		<key>conjunction</key>
		<integer>1</integer>
		<key>group name</key>
		<string>Problem URLs</string>
	</dict>
	<dict>
		<key>conditions</key>
		<array>
			<dict>
				<key>comparison</key>
				<integer>4</integer>
				<key>key</key>
				<string>Read</string>
				<key>value</key>
				<string>No</string>
				<key>version</key>
				<string>1</string>
			</dict>
		</array>
		<key>conjunction</key>
		<integer>0</integer>
		<key>group name</key>
		<string>Unread</string>
	</dict>
</array>
</plist>
}}
