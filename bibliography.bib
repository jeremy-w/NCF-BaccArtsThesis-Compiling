
%% Created for jeremy at 2008-04-21 07:01:13 -0400 


%% Saved with string encoding Western (ASCII) 



@article{Cohen:A-view:1988,
	Address = {New York, NY, USA},
	Author = {Jacques Cohen},
	Date-Added = {2008-04-21 06:59:03 -0400},
	Date-Modified = {2008-04-21 07:00:10 -0400},
	Doi = {http://doi.acm.org/10.1145/35043.35045},
	Issn = {0001-0782},
	Journal = {Commun. ACM},
	Number = {1},
	Pages = {26--36},
	Publisher = {ACM},
	Title = {A view of the origins and development of Prolog},
	Volume = {31},
	Year = {1988},
	Abstract = {This paper explores the origins of Prolog based on the views rising mainly from the language processing perspective. With this intent we first describe the related research efforts and their significant computer literature in the mid-1960s. We then show that those existing circumstances would very naturally lead to the development of a language like Prolog.},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/35043.35045},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFUuLi8uLi9QYXBlcnMvQ29oZW4vQ29oZW4gLSBBIHZpZXcgb2YgdGhlIG9yaWdpbnMgYW5kIGRldmVsb3BtZW50IG9mIFByb2xvZyAoMTk4OCkucGRm0hsPHB1XTlMuZGF0YU8RAhYAAAAAAhYAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADfDGx9Db2hlbiAtIEEgdmlldyBvZiB0aCMzN0FFNzgucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN654xDGm11BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAFQ29oZW4AABAACAAAwTR+XQAAABEACAAAxDHfFwAAAAEAEAA3wxsALZE/AANHrAAAa9gAAgA+T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkNvaGVuOkNvaGVuIC0gQSB2aWV3IG9mIHRoIzM3QUU3OC5wZGYADgCGAEIAQwBvAGgAZQBuACAALQAgAEEAIAB2AGkAZQB3ACAAbwBmACAAdABoAGUAIABvAHIAaQBnAGkAbgBzACAAYQBuAGQAIABkAGUAdgBlAGwAbwBwAG0AZQBuAHQAIABvAGYAIABQAHIAbwBsAG8AZwAgACgAMQA5ADgAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFxVc2Vycy9qZXJlbXkvUGFwZXJzL0NvaGVuL0NvaGVuIC0gQSB2aWV3IG9mIHRoZSBvcmlnaW5zIGFuZCBkZXZlbG9wbWVudCBvZiBQcm9sb2cgKDE5ODgpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgECAQcBDwMpAysDMAM5A0QDSANWA10DZgNrA24AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADew==}}

@article{Landin:The-next:1966,
	Address = {New York, NY, USA},
	Author = {P. J. Landin},
	Date-Added = {2008-04-21 06:55:37 -0400},
	Date-Modified = {2008-04-21 06:56:36 -0400},
	Doi = {http://doi.acm.org/10.1145/365230.365257},
	Issn = {0001-0782},
	Journal = {Commun. ACM},
	Number = {3},
	Pages = {157--166},
	Publisher = {ACM},
	Title = {The next 700 programming languages},
	Volume = {9},
	Year = {1966},
	Abstract = {A family of unimplemented computing languages is described that is intended to span differences of application area by a unified framework. This framework dictates the rules about the uses of user-coined names, and the conventions about characterizing functional relationships. Within this framework the design of a specific language splits into two independent parts. One is the choice of written appearances of programs (or more generally, their physical representation). The other is the choice of the abstract entities (such as numbers, character-strings, list of them, functional relations among them) that can be referred to in the language. The system is biased towards "expressions" rather than "statements." It includes a nonprocedural (purely functional) subsystem that aims to expand the class of users' needs that can be met by a single print-instruction, without sacrificing the important properties that make conventional right-hand-side expressions easy to construct and understand.},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/365230.365257},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEouLi8uLi9QYXBlcnMvTGFuZGluL0xhbmRpbiAtIFRoZSBuZXh0IDcwMCBwcm9ncmFtbWluZyBsYW5ndWFnZXMgKDE5NjYpLnBkZtIbDxwdV05TLmRhdGFPEQH2AAAAAAH2AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAA3wv4fTGFuZGluIC0gVGhlIG5leHQgNzAjMzdDMkZCLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADfC+8Qx60NQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABkxhbmRpbgAQAAgAAME0fl0AAAARAAgAAMQyI4MAAAABABAAN8L+AC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpMYW5kaW46TGFuZGluIC0gVGhlIG5leHQgNzAjMzdDMkZCLnBkZgAADgBuADYATABhAG4AZABpAG4AIAAtACAAVABoAGUAIABuAGUAeAB0ACAANwAwADAAIABwAHIAbwBnAHIAYQBtAG0AaQBuAGcAIABsAGEAbgBnAHUAYQBnAGUAcwAgACgAMQA5ADYANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFFVc2Vycy9qZXJlbXkvUGFwZXJzL0xhbmRpbi9MYW5kaW4gLSBUaGUgbmV4dCA3MDAgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzICgxOTY2KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPcA/AEEAv4DAAMFAw4DGQMdAysDMgM7A0ADQwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANQ}}

@book{Iverson:A-programming:1962,
	Address = {New York, NY, USA},
	Author = {Kenneth E. Iverson},
	Date-Added = {2008-04-21 06:53:58 -0400},
	Date-Modified = {2008-04-21 06:54:00 -0400},
	Isbn = {0-471430-14-5},
	Publisher = {John Wiley \& Sons, Inc.},
	Source = {Library of Congress Catalog Card Number: 62-15180},
	Title = {A programming language},
	Year = {1962}}

@incollection{Hodges:Did-Church:2006,
	Author = {Andrew Hodges},
	Booktitle = {Church's {T}hesis after 70 Years},
	Date-Added = {2008-04-19 02:26:53 -0400},
	Date-Modified = {2008-04-21 01:37:03 -0400},
	Editor = {Adam Olszewski and Jan Wole{'n}ski and Robert Janusz},
	Isbn = {3-938793-09-0},
	Keywords = {history of computing},
	Location = {Berlin},
	Publisher = {ontos verlag},
	Series = {Mathematical Logic},
	Title = {Did {C}hurch and {T}uring have a thesis about machines?},
	Url = {http://www.turing.org.uk/publications/ct70.html},
	Volume = {1},
	Year = {2006},
	Abstract = {This article draws attention to a central dispute in the interpretation of Church's Thesis. More precisely, we are concerned with the Church--Turing thesis, as it emerged in 1936 when Church endorsed Turing's characterization of the concept of effective calculability. (The article by Sieg in this volume details this history. It is valuable also to note from Krajewski, also in this volume, that the word 'thesis' was used only in 1952.) This controversy has a \textit{scientic} aspect, concerning the nature of the physical world and what can be done with it. It has a \textit{historical} aspect, to do with the 'confluence of ideas in 1936'. We shall focus on the historical question, but it is the continuing and serious scientific question that lends potency to the history.},
	Annote = {The publisher itself, both in English and German, insists on spelling its name in all lowercase, and so we have followed suit.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFEuLi8uLi9QYXBlcnMvSG9kZ2VzL0hvZGdlcyAtIERpZCBDaHVyY2ggYW5kIFR1cmluZyBoYXZlIGEgdGhlc2lzIGFib3V0ICgyMDA2KS5wZGbSGw8cHVdOUy5kYXRhTxECCgAAAAACCgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAN3MZH0hvZGdlcyAtIERpZCBDaHVyY2ggIzM3NzJDNS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3csXELwdmAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZIb2RnZXMAEAAIAADBNH5dAAAAEQAIAADELz+mAAAAAQAQADdzGQAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6SG9kZ2VzOkhvZGdlcyAtIERpZCBDaHVyY2ggIzM3NzJDNS5wZGYAAA4AfAA9AEgAbwBkAGcAZQBzACAALQAgAEQAaQBkACAAQwBoAHUAcgBjAGgAIABhAG4AZAAgAFQAdQByAGkAbgBnACAAaABhAHYAZQAgAGEAIAB0AGgAZQBzAGkAcwAgAGEAYgBvAHUAdAAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFhVc2Vycy9qZXJlbXkvUGFwZXJzL0hvZGdlcy9Ib2RnZXMgLSBEaWQgQ2h1cmNoIGFuZCBUdXJpbmcgaGF2ZSBhIHRoZXNpcyBhYm91dCAoMjAwNikucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAP4BAwELAxkDGwMgAykDNAM4A0YDTQNWA1sDXgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANr},
	Bdsk-Url-1 = {http://www.turing.org.uk/publications/ct70.html}}

@book{Olszewski:Churchs:2006,
	Date-Added = {2008-04-19 02:08:21 -0400},
	Date-Modified = {2008-04-19 02:20:41 -0400},
	Editor = {Adam Olszewski and Jan Wole{'n}ski and Robert Janusz},
	Isbn = {3-938793-09-0},
	Location = {Berlin},
	Publisher = {ontos verlag},
	Series = {Mathematical Logic},
	Title = {Church's Thesis after 70 Years},
	Url = {http://www.ontos-verlag.de/Buchreihen-ML-Olszewski.php},
	Volume = {1},
	Year = {2006},
	Abstract = {Church's Thesis was first published by Alonzo Church in 1935. The thesis is a proposition that identifies two notions: an intuitive notion of an effectively computable function defined in natural numbers with the notion of a recursive function. Despite many efforts by prominent scientists, Church's Thesis has never been falsified. There exists a vast literature concerning the thesis. The aim of this book is to provide a one-volume summary of the state of research on Church's Thesis. These include the following:  different formulations of the thesis, Church's Thesis and intuitionism, Church's Thesis and intensional mathematics, Church's Thesis and physics, the epistemic status of the thesis, Church's Thesis and philosophy of mind, provability of Church's thesis and Church's thesis and functional programming.},
	Annote = {The publisher itself, both in English and German, insists on spelling its name in all lowercase, and so we have followed suit.},
	Bdsk-Url-1 = {http://www.ontos-verlag.de/Buchreihen-ML-Olszewski.php}}

@misc{Schwartzbach:Polymorphic:1995,
	Author = {Schwartzbach, Michael I.},
	Date-Added = {2008-04-18 12:56:38 -0400},
	Date-Modified = {2008-04-18 12:57:08 -0400},
	Homepage = {http://www.daimi.au.dk/~mis/},
	Howpublished = {Lecture notes, published online},
	Month = {March},
	Note = {Also given as an invited lecture in June 1995 as BRICS LS-95-3.},
	Title = {Polymorphic type inference},
	Year = {1995},
	Abstract = {We will present a tiny functional language and

  gradually enrich its type system. We shall cover the basic Curry-Hindley
  system and Wand's constraint-based algorithm for monomorphic type inference;
  briefly observe the Curry-Howard isomorphism and notice that logical

  formalism may serve as the inspiration for new type rules; present the
  polymorphic Milner system and the Damas-Milner algorithm for polymorphic type
  inference; see the Milner-Mycroft system for polymorphic recursion; and

  sketch the development of higher type systems. We will touch upon the
  relationship between types and logic and show how rules from logic may give
  inspiration for new type rules. En route we shall encounter the curious

  discovery that two algorithmic problems for type systems, which have been
  implemented in popular programming languages, have turned out to be
  respectively complete for exponential time and undecidable.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE4uLi8uLi9QYXBlcnMvU2Nod2FydHpiYWNoL1NjaHdhcnR6YmFjaCAtIFBvbHltb3JwaGljIHR5cGUgaW5mZXJlbmNlICgxOTk1KS5wZGbSGw8cHVdOUy5kYXRhTxECAgAAAAACAgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAANoFOH1NjaHdhcnR6YmFjaCAtIFBvbHltIzM2ODE0Ny5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2gUfELks/UERGIHBydncAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAxTY2h3YXJ0emJhY2gAEAAIAADBNH5dAAAAEQAIAADELoN/AAAAAQAQADaBTgAtkT8AA0esAABr2AACAEVPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6U2Nod2FydHpiYWNoOlNjaHdhcnR6YmFjaCAtIFBvbHltIzM2ODE0Ny5wZGYAAA4AagA0AFMAYwBoAHcAYQByAHQAegBiAGEAYwBoACAALQAgAFAAbwBsAHkAbQBvAHIAcABoAGkAYwAgAHQAeQBwAGUAIABpAG4AZgBlAHIAZQBuAGMAZQAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFVVc2Vycy9qZXJlbXkvUGFwZXJzL1NjaHdhcnR6YmFjaC9TY2h3YXJ0emJhY2ggLSBQb2x5bW9ycGhpYyB0eXBlIGluZmVyZW5jZSAoMTk5NSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD7AQABCAMOAxADFQMeAykDLQM7A0IDSwNQA1MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADYA==}}

@book{Felleisen:How:2003,
	Author = {Felleisen, Matthias and Findler, Robert Bruce and Flatt, Matthew and Krishnamurthi, Shriram},
	Date-Added = {2008-04-18 12:56:38 -0400},
	Date-Modified = {2008-04-18 12:58:47 -0400},
	Month = {Sept},
	Note = {Published online at \url{http://www.htdp.org/}},
	Publisher = {MIT Press},
	Title = {How to Design Programs},
	Url = {http://www.htdp.org/},
	Year = {2003},
	Bdsk-Url-1 = {http://www.htdp.org/}}

@incollection{Turner:Church:2006,
	Author = {David Turner},
	Booktitle = {Church's Thesis after 70 Years},
	Date-Added = {2008-04-18 12:56:38 -0400},
	Date-Modified = {2008-04-19 02:23:18 -0400},
	Editor = {Olszewski, A.},
	Location = {Berlin},
	Pages = {518--544},
	Publisher = {ontos verlag},
	Title = {Church's Thesis and Functional Programming},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGAuLi8uLi9QYXBlcnMvVHVybmVyL1R1cm5lciAtIENodXJjaCdzIFRoZXNpcyBhbmQgRnVuY3Rpb25hbCBQcm9ncmFtbWluZyAocHAgNTE4LS01NDQpICgyMDA2KS5wZGbSGw8cHVdOUy5kYXRhTxECOAAAAAACOAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAANoFUH1R1cm5lciAtIENodXJjaCdzIFRoIzM2ODExQy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2gRzELh9uAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZUdXJuZXIAEAAIAADBNH5dAAAAEQAIAADELleuAAAAAQAQADaBVAAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6VHVybmVyOlR1cm5lciAtIENodXJjaCdzIFRoIzM2ODExQy5wZGYAAA4AmgBMAFQAdQByAG4AZQByACAALQAgAEMAaAB1AHIAYwBoACcAcwAgAFQAaABlAHMAaQBzACAAYQBuAGQAIABGAHUAbgBjAHQAaQBvAG4AYQBsACAAUAByAG8AZwByAGEAbQBtAGkAbgBnACAAKABwAHAAIAA1ADEAOAAtAC0ANQA0ADQAKQAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGdVc2Vycy9qZXJlbXkvUGFwZXJzL1R1cm5lci9UdXJuZXIgLSBDaHVyY2gncyBUaGVzaXMgYW5kIEZ1bmN0aW9uYWwgUHJvZ3JhbW1pbmcgKHBwIDUxOC0tNTQ0KSAoMjAwNikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgENARIBGgNWA1gDXQNmA3EDdQODA4oDkwOYA5sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqA==}}

@inproceedings{Meijer:Functional:1991,
	Address = {New York, NY, USA},
	Author = {Erik Meijer and Maarten Fokkinga and Ross Paterson},
	Booktitle = {Proceedings of the 5th ACM conference on Functional programming languages and computer architecture},
	Date-Added = {2008-04-18 12:52:53 -0400},
	Date-Modified = {2008-04-18 12:54:04 -0400},
	Isbn = {0-387-54396-1},
	Location = {Cambridge, Massachusetts, United States},
	Pages = {124--144},
	Publisher = {Springer-Verlag New York, Inc.},
	Title = {Functional programming with bananas, lenses, envelopes and barbed wire},
	Year = {1991},
	Abstract = {We develop a calculus for lazy functional programming based on recursion operators associated with data type definitions. For these operators we derive various algebraic laws that are useful in deriving and manipulating programs. We shall show that all example functions in Bird and Wadler's "Introduction to Functional Programming" can be expressed using these operators.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGYuLi8uLi9QYXBlcnMvTWVpamVyL01laWplci1Gb2traW5nYS1QYXRlcnNvbiAtIEZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgd2l0aCBiYW5hbmFzLCBsZW5zZXMsICgxOTkxKS5wZGbSGw8cHVdOUy5kYXRhTxECSgAAAAACSgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAANoEgH01laWplci1Gb2traW5nYS1QYXRlIzM2ODExQS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2gRrELh9qAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZNZWlqZXIAEAAIAADBNH5dAAAAEQAIAADELleqAAAAAQAQADaBIAAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6TWVpamVyOk1laWplci1Gb2traW5nYS1QYXRlIzM2ODExQS5wZGYAAA4ApgBSAE0AZQBpAGoAZQByAC0ARgBvAGsAawBpAG4AZwBhAC0AUABhAHQAZQByAHMAbwBuACAALQAgAEYAdQBuAGMAdABpAG8AbgBhAGwAIABwAHIAbwBnAHIAYQBtAG0AaQBuAGcAIAB3AGkAdABoACAAYgBhAG4AYQBuAGEAcwAsACAAbABlAG4AcwBlAHMALAAgACgAMQA5ADkAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG1Vc2Vycy9qZXJlbXkvUGFwZXJzL01laWplci9NZWlqZXItRm9ra2luZ2EtUGF0ZXJzb24gLSBGdW5jdGlvbmFsIHByb2dyYW1taW5nIHdpdGggYmFuYW5hcywgbGVuc2VzLCAoMTk5MSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgETARgBIANuA3ADdQN+A4kDjQObA6IDqwOwA7MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADwA==}}

@article{Hutton:A-tutorial:1999,
	Address = {New York, NY, USA},
	Author = {Graham Hutton},
	Date-Added = {2008-04-18 12:52:53 -0400},
	Date-Modified = {2008-04-18 12:54:04 -0400},
	Doi = {http://dx.doi.org/10.1017/S0956796899003500},
	Issn = {0956-7968},
	Journal = {J. Funct. Program.},
	Number = {4},
	Pages = {355--372},
	Publisher = {Cambridge University Press},
	Title = {A tutorial on the universality and expressiveness of fold},
	Volume = {9},
	Year = {1999},
	Abstract = {

In functional programming, \textit{fold} is a standard operator that encapsulates a simple pattern of recursion for processing lists. This article is a tutorial on two key aspects of the fold operator for lists. First of all, we emphasize the use of the \textit{universal property} of fold both as a \textit{proof principle} that avoids the need for inductive proofs, and as a \textit{definition principle} that guides the transformation of recursive functions into definitions using fold. Secondly, we show that even though the pattern of recursion encapsulated by fold is simple, in a language with tuples and functions as first-class values the fold operator has greater \textit{expressive power} than might first be expected.

},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGEuLi8uLi9QYXBlcnMvSHV0dG9uL0h1dHRvbiAtIEEgdHV0b3JpYWwgb24gdGhlIHVuaXZlcnNhbGl0eSBhbmQgZXhwcmVzc2l2ZW5lc3Mgb2YgZm9sZCAoMTk5OSkucGRm0hsPHB1XTlMuZGF0YU8RAjoAAAAAAjoAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2SYB9IdXR0b24gLSBBIHR1dG9yaWFsICMzNjgxMUIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANoEbxC4fbgAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGSHV0dG9uABAACAAAwTR+XQAAABEACAAAxC5XrgAAAAEAEAAtkmAALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkh1dHRvbjpIdXR0b24gLSBBIHR1dG9yaWFsICMzNjgxMUIucGRmAAAOAJwATQBIAHUAdAB0AG8AbgAgAC0AIABBACAAdAB1AHQAbwByAGkAYQBsACAAbwBuACAAdABoAGUAIAB1AG4AaQB2AGUAcgBzAGEAbABpAHQAeQAgAGEAbgBkACAAZQB4AHAAcgBlAHMAcwBpAHYAZQBuAGUAcwBzACAAbwBmACAAZgBvAGwAZAAgACgAMQA5ADkAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGhVc2Vycy9qZXJlbXkvUGFwZXJzL0h1dHRvbi9IdXR0b24gLSBBIHR1dG9yaWFsIG9uIHRoZSB1bml2ZXJzYWxpdHkgYW5kIGV4cHJlc3NpdmVuZXNzIG9mIGZvbGQgKDE5OTkpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEOARMBGwNZA1sDYANpA3QDeAOGA40DlgObA54AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqw==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1017/S0956796899003500}}

@misc{Altenkirch:Why-Dependent:2005,
	Author = {Thorsten Altenkirch and Conor McBride and James McKinna},
	Date-Added = {2008-04-16 22:12:18 -0400},
	Date-Modified = {2008-04-16 22:13:42 -0400},
	Howpublished = {Manuscript, available online},
	Keywords = {manuscript},
	Month = {April},
	Title = {Why Dependent Types Matter},
	Year = {2005},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFouLi8uLi9QYXBlcnMvQWx0ZW5raXJjaC9BbHRlbmtpcmNoLU1jQnJpZGUtTWNLaW5uYSAtIFdoeSBEZXBlbmRlbnQgVHlwZXMgTWF0dGVyICgyMDA1KS5wZGbSGw8cHVdOUy5kYXRhTxECJgAAAAACJgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAMfYoH0FsdGVua2lyY2gtTWNCcmlkZS1NIzMxRjYwMC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAx9gDELCl/UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAApBbHRlbmtpcmNoABAACAAAwTR+XQAAABEACAAAxCxhvwAAAAEAEAAx9igALZE/AANHrAAAa9gAAgBDT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkFsdGVua2lyY2g6QWx0ZW5raXJjaC1NY0JyaWRlLU0jMzFGNjAwLnBkZgAADgCGAEIAQQBsAHQAZQBuAGsAaQByAGMAaAAtAE0AYwBCAHIAaQBkAGUALQBNAGMASwBpAG4AbgBhACAALQAgAFcAaAB5ACAARABlAHAAZQBuAGQAZQBuAHQAIABUAHkAcABlAHMAIABNAGEAdAB0AGUAcgAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGFVc2Vycy9qZXJlbXkvUGFwZXJzL0FsdGVua2lyY2gvQWx0ZW5raXJjaC1NY0JyaWRlLU1jS2lubmEgLSBXaHkgRGVwZW5kZW50IFR5cGVzIE1hdHRlciAoMjAwNSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEHAQwBFAM+A0ADRQNOA1kDXQNrA3IDewOAA4MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkA==}}

@article{McKinna:Why-dependent:2006,
	Address = {New York, NY, USA},
	Author = {James McKinna},
	Date-Added = {2008-04-16 22:09:54 -0400},
	Date-Modified = {2008-04-16 22:10:12 -0400},
	Doi = {http://doi.acm.org/10.1145/1111320.1111038},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {1},
	Pages = {1--1},
	Publisher = {ACM},
	Title = {Why dependent types matter},
	Volume = {41},
	Year = {2006},
	Abstract = {Language designers have in recent years proposed a wealth of richer type systems for programming which seek to extend the range of statically enforced guarantees on data and code. Most such proposals have been evolutionary extensions of ML or Haskell, offering programmers a balanced compromise between expressive strength and existing well-understood technology. Typically they revolve around type- or kind-indexed types such as GADTs, supported by limited equality reasoning at the type-checking level, thus separating the dynamic behaviour of programs from the (simpler) static behaviour of indexing information occurring in their types.I want to argue in this talk for a more radical departure from such practice by examining full spectrum type dependency, lifting such restrictions on the data upon which types may depend. Conor McBride and I designed the language EPIGRAM for experiments in programming with inductive families of data (of which GADTs are a special case). Using it for illustration, I will explore some of the possibilities and challenges afforded by full spectrum type dependency at the static and dynamic level:
\begin{itemize}
\item types directly support modelling complex invariants in terms of other data (rather than their types), with a Curry-Howard flavour of data-as-evidence; such complexity is on a 'pay-as-you-go' basis, while keeping type annotations and other syntactic overheads to a minimum;
\item data decomposition steps, e.g. case analysis, furnish more informative interactions between types and values during typechecking; such steps may moreover be abstractly specified by their types, and thus user definable; this supports a style of programming embracing 'learning by testing', views, and Burstall's 'hand simulation plus a little induction';
\item the absence of a rigid phase distinction need not lead to type-passing or excessive run-time overhead; effectful computation, in particular partiality, can be incorporated via variations on existing ideas such as monads.
\end{itemize}
This talk is based on joint work with Conor McBride, Edwin Brady and Thorsten Altenkirch.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEQuLi8uLi9QYXBlcnMvTWNLaW5uYS9NY0tpbm5hIC0gV2h5IGRlcGVuZGVudCB0eXBlcyBtYXR0ZXIgKDIwMDYpLnBkZtIbDxwdV05TLmRhdGFPEQHkAAAAAAHkAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAx9hwfTWNLaW5uYSAtIFdoeSBkZXBlbmQjMzFGNjFCLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADH2G8QsKiNQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAB01jS2lubmEAABAACAAAwTR+XQAAABEACAAAxCxiYwAAAAEAEAAx9hwALZE/AANHrAAAa9gAAgBAT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOk1jS2lubmE6TWNLaW5uYSAtIFdoeSBkZXBlbmQjMzFGNjFCLnBkZgAOAGAALwBNAGMASwBpAG4AbgBhACAALQAgAFcAaAB5ACAAZABlAHAAZQBuAGQAZQBuAHQAIAB0AHkAcABlAHMAIABtAGEAdAB0AGUAcgAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAEtVc2Vycy9qZXJlbXkvUGFwZXJzL01jS2lubmEvTWNLaW5uYSAtIFdoeSBkZXBlbmRlbnQgdHlwZXMgbWF0dGVyICgyMDA2KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPEA9gD+AuYC6ALtAvYDAQMFAxMDGgMjAygDKwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAM4},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1111320.1111038}}

@article{McBride:The-view:2004,
	Address = {New York, NY, USA},
	Author = {Conor McBride and James McKinna},
	Date-Added = {2008-04-16 21:46:02 -0400},
	Date-Modified = {2008-04-16 21:50:29 -0400},
	Doi = {http://dx.doi.org/10.1017/S0956796803004829},
	Issn = {0956-7968},
	Journal = {J. Funct. Program.},
	Number = {1},
	Pages = {69--111},
	Publisher = {Cambridge University Press},
	Title = {The view from the left},
	Volume = {14},
	Year = {2004},
	Abstract = {Pattern matching has proved an extremely powerful and durable notion in functional programming. This paper contributes a new programming notation for type theory which elaborates the notion in various ways.

Firstly, as is by now quite well-known in the type theory community, definition by pattern matching becomes a more discriminating tool in the presence of dependent types, since it refines the explanation of types as well as values. This becomes all the more true in the presence of the rich class of datatypes known as inductive families (Dybjer, 1991).

Secondly, as proposed by Peyton Jones (1997) for Haskell, and independently rediscovered by us, subsidiary case analyses on the results of intermediate computations, which commonly take place on the right-hand side of definitions by pattern matching, should rather be handled on the left. In simply-typed languages, this subsumes the trivial case of Boolean guards; in our setting it becomes yet more powerful.

Thirdly, elementary pattern matching decompositions have a well-defined interface given by a dependent type; they correspond to the statement of an induction principle for the datatype. More general, user-definable decompositions may be defined which also have types of the same general form. Elementary pattern matching may therefore be recast in abstract form, with a semantics given by translation. Such abstract decompositions of data generalize Wadler's (1987) notion of `view'. The programmer wishing to introduce a new view of a type $\mathit{T}$, and exploit it directly in pattern matching, may do so via a standard programming idiom. The type theorist, looking through the Curry--Howard lens, may see this as proving a theorem, one which establishes the validity of a new induction principle for $\mathit{T}$.

We develop enough syntax and semantics to account for this high-level style of programming in dependent type theory. We close with the development of a typechecker for the simply-typed lambda calculus, which furnishes a view of raw terms as either being well-typed, or containing an error. The implementation of this view is \textit{ipso facto} a proof that typechecking is decidable.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEguLi8uLi9QYXBlcnMvTWNCcmlkZS9NY0JyaWRlLU1jS2lubmEgLSBUaGUgdmlldyBmcm9tIHRoZSBsZWZ0ICgyMDA0KS5wZGbSGw8cHVdOUy5kYXRhTxEB8AAAAAAB8AACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAMfWOH01jQnJpZGUtTWNLaW5uYSAtIFRoIzMxRjU4MS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAx9YHELCMpAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdNY0JyaWRlAAAQAAgAAME0fl0AAAARAAgAAMQsW2kAAAABABAAMfWOAC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpNY0JyaWRlOk1jQnJpZGUtTWNLaW5uYSAtIFRoIzMxRjU4MS5wZGYADgBoADMATQBjAEIAcgBpAGQAZQAtAE0AYwBLAGkAbgBuAGEAIAAtACAAVABoAGUAIAB2AGkAZQB3ACAAZgByAG8AbQAgAHQAaABlACAAbABlAGYAdAAgACgAMgAwADAANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAE9Vc2Vycy9qZXJlbXkvUGFwZXJzL01jQnJpZGUvTWNCcmlkZS1NY0tpbm5hIC0gVGhlIHZpZXcgZnJvbSB0aGUgbGVmdCAoMjAwNCkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD1APoBAgL2AvgC/QMGAxEDFQMjAyoDMwM4AzsAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADSA==},
	Bdsk-Url-1 = {http://dx.doi.org/10.1017/S0956796803004829}}

@misc{McBride:The-view:2001,
	Author = {Conor McBride and James McKinna},
	Date-Added = {2008-04-16 21:45:58 -0400},
	Date-Modified = {2008-04-16 22:14:04 -0400},
	Howpublished = {Manuscript, available online},
	Keywords = {manuscript},
	Month = {Dec},
	Note = {Very different, early version of later J. Functional Programming paper. McKinna published online with note that ``we still think it worth reading as one of the only introductions to our perspective on \textit{interactive} program development.''},
	Title = {The view from the left (early draft)},
	Url = {http://www.dcs.st-and.ac.uk/~james/},
	Year = {2001},
	Abstract = {Interactive, refinement-style proof construction in type theory has several things to offer the programmer seeking to exploit languages with dependent types.

Firstly, as is by now quite well-known, definition by pattern matching becomes a more discriminating tool for problem-solving, since it refines the explanation of types as well as values. This corresponds to the instantiation of propositions in proof by induction.

Secondly, Gentzen's sequent calculus draws attention to the r\^{o}le played by cut formul\ae. Subsidiary case analyses on the results of intermediate computations, which commonly take place on the right-hand side of definitions for pattern matching, should rather be explained by `left rules'. This subsumes the trivial case of Boolean guards in simply-types languages.

Thirdly, pattern matching decompositions have a well-defined interface given by a dependent type. These are user-definable, and generalize Wadler's notion of `view' (Wadler, 1987). The programmer wishing to introduce a new view of datatype, and exploit it directly in pattern matching, may do so via a standard idiom: writing a program.

This paper introduces enough syntax and semantics to account for this high-level style of programming in dependent type theory. It culminates int he development of a type-checker for the simply-typed lambda calculus, which furnishes a view of raw terms as either being well-typed, or containing an error. The implementation of this view is a proof that typechecking is decidable.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFYuLi8uLi9QYXBlcnMvTWNCcmlkZS9NY0JyaWRlLU1jS2lubmEgLSBUaGUgdmlldyBmcm9tIHRoZSBsZWZ0IChlYXJseSBkcmFmdCkgKDIwMDApLnBkZtIbDxwdV05TLmRhdGFPEQIaAAAAAAIaAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAx9Y4fTWNCcmlkZS1NY0tpbm5hIC0gVGgjMzFGNTg3LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADH1h8QsIzYAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAB01jQnJpZGUAABAACAAAwTR+XQAAABEACAAAxCxbdgAAAAEAEAAx9Y4ALZE/AANHrAAAa9gAAgBAT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOk1jQnJpZGU6TWNCcmlkZS1NY0tpbm5hIC0gVGgjMzFGNTg3LnBkZgAOAIQAQQBNAGMAQgByAGkAZABlAC0ATQBjAEsAaQBuAG4AYQAgAC0AIABUAGgAZQAgAHYAaQBlAHcAIABmAHIAbwBtACAAdABoAGUAIABsAGUAZgB0ACAAKABlAGEAcgBsAHkAIABkAHIAYQBmAHQAKQAgACgAMgAwADAAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF1Vc2Vycy9qZXJlbXkvUGFwZXJzL01jQnJpZGUvTWNCcmlkZS1NY0tpbm5hIC0gVGhlIHZpZXcgZnJvbSB0aGUgbGVmdCAoZWFybHkgZHJhZnQpICgyMDAwKS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQMBCAEQAy4DMAM1Az4DSQNNA1sDYgNrA3ADcwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOA},
	Bdsk-Url-1 = {http://www.dcs.st-and.ac.uk/~james/}}

@inproceedings{McBride:Functional:2004,
	Address = {New York, NY, USA},
	Author = {Conor McBride and James McKinna},
	Booktitle = {Haskell '04: Proceedings of the 2004 ACM SIGPLAN workshop on Haskell},
	Date-Added = {2008-04-16 21:34:24 -0400},
	Date-Modified = {2008-04-16 21:57:47 -0400},
	Doi = {http://doi.acm.org/10.1145/1017472.1017477},
	Isbn = {1-58113-850-4},
	Location = {Snowbird, Utah, USA},
	Pages = {1--9},
	Publisher = {ACM},
	Title = {Functional Pearl: {I} am not a number -- {I} am a free variable},
	Year = {2004},
	Abstract = {In this paper, we show how to manipulate syntax with binding using a mixed representation of names for free variables (with respect to the task in hand) and de Bruijn indices [5] for bound variables. By doing so, we retain the advantages of both representations: naming supports easy, arithmetic-free manipulation of terms; de Bruijn indices eliminate the need for \alpha-conversion. Further, we have ensured that not only the user but also the \textit{implementation} need never deal with de Bruijn indices, except within key basic operations.

Moreover, we give a hierarchical representation for names which naturally reflects the structure of the operations we implement. Name choice is safe and straightforward. Our technology combines easily with an approach to syntax manipulation inspired by Huet's 'zippers'[10].

Without the ideas in this paper, we would have struggled to implement EPIGRAM [19]. Our example -- constructing inductive elimination operators for datatype families -- is but one of many where it proves invaluable.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEG0uLi8uLi9QYXBlcnMvTWNCcmlkZS9NY0JyaWRlLU1jS2lubmEgLSBGdW5jdGlvbmFsIHBlYXJsOiBJIGFtIG5vdCBhIG51bWJlciAtLSBJIGFtIGEgZnJlZSB2YXJpYWJsZSAoMjAwNCkucGRm0hsPHB1XTlMuZGF0YU8RAl4AAAAAAl4AAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADH1jh9NY0JyaWRlLU1jS2lubmEgLSBGdSMzMUY1QTAucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMfWgxCwj7lBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAHTWNCcmlkZQAAEAAIAADBNH5dAAAAEQAIAADELFwuAAAAAQAQADH1jgAtkT8AA0esAABr2AACAEBPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6TWNCcmlkZTpNY0JyaWRlLU1jS2lubmEgLSBGdSMzMUY1QTAucGRmAA4AsgBYAE0AYwBCAHIAaQBkAGUALQBNAGMASwBpAG4AbgBhACAALQAgAEYAdQBuAGMAdABpAG8AbgBhAGwAIABwAGUAYQByAGwALwAgAEkAIABhAG0AIABuAG8AdAAgAGEAIABuAHUAbQBiAGUAcgAgAC0ALQAgAEkAIABhAG0AIABhACAAZgByAGUAZQAgAHYAYQByAGkAYQBiAGwAZQAgACgAMgAwADAANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHRVc2Vycy9qZXJlbXkvUGFwZXJzL01jQnJpZGUvTWNCcmlkZS1NY0tpbm5hIC0gRnVuY3Rpb25hbCBwZWFybDogSSBhbSBub3QgYSBudW1iZXIgLS0gSSBhbSBhIGZyZWUgdmFyaWFibGUgKDIwMDQpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEaAR8BJwOJA4sDkAOZA6QDqAO2A70DxgPLA84AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAD2w==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1017472.1017477}}

@article{Barendregt:The-impact:1997,
	Author = {Barendregt, H. P.},
	Date-Added = {2008-04-14 20:34:22 -0400},
	Date-Modified = {2008-04-18 12:52:25 -0400},
	Journal = {Bull. Symbolic Logic},
	Month = {June},
	Number = {2},
	Pages = {181--215},
	Title = {The impact of the lambda calculus in logic and computer science},
	Url = {http://www.cs.ru.nl/~henk/papers.html},
	Volume = {3},
	Year = {1997},
	Abstract = {One of the most important contributions of A. Church to logic is his invention of the lambda calculus. We present the genesis of this theory and its two major areas of application: the representation of computations and the resulting functional programming languages on the one hand and the representation of reasoning and the resulting systems of computer mathematics on the other hand.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGcuLi8uLi9QYXBlcnMvQmFyZW5kcmVndC9CYXJlbmRyZWd0IC0gVGhlIGltcGFjdCBvZiB0aGUgbGFtYmRhIGNhbGN1bHVzIGluIGxvZ2ljIGFuZCBjb21wdXRlciAoMTk5NykucGRm0hsPHB1XTlMuZGF0YU8RAkwAAAAAAkwAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADGntR9CYXJlbmRyZWd0IC0gVGhlIGltcCMzMUI4OUMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMbicxClwLwAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAKQmFyZW5kcmVndAAQAAgAAME0fl0AAAARAAgAAMQpqG8AAAABABAAMae1AC2RPwADR6wAAGvYAAIAQ09kaW46VXNlcnM6amVyZW15OlBhcGVyczpCYXJlbmRyZWd0OkJhcmVuZHJlZ3QgLSBUaGUgaW1wIzMxQjg5Qy5wZGYAAA4AoABPAEIAYQByAGUAbgBkAHIAZQBnAHQAIAAtACAAVABoAGUAIABpAG0AcABhAGMAdAAgAG8AZgAgAHQAaABlACAAbABhAG0AYgBkAGEAIABjAGEAbABjAHUAbAB1AHMAIABpAG4AIABsAG8AZwBpAGMAIABhAG4AZAAgAGMAbwBtAHAAdQB0AGUAcgAgACgAMQA5ADkANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG5Vc2Vycy9qZXJlbXkvUGFwZXJzL0JhcmVuZHJlZ3QvQmFyZW5kcmVndCAtIFRoZSBpbXBhY3Qgb2YgdGhlIGxhbWJkYSBjYWxjdWx1cyBpbiBsb2dpYyBhbmQgY29tcHV0ZXIgKDE5OTcpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEUARkBIQNxA3MDeAOBA4wDkAOeA6UDrgOzA7YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADww==},
	Bdsk-Url-1 = {http://www.cs.ru.nl/~henk/papers.html}}

@book{Girard:Proofs:1989,
	Address = {New York, NY, USA},
	Author = {Jean-Yves Girard and Paul Taylor and Yves Lafont},
	Date-Added = {2008-04-14 20:18:04 -0400},
	Date-Modified = {2008-04-14 20:20:53 -0400},
	Isbn = {0-521-37181-3},
	Note = {Based on a short graduate course on typed lambda calculus given at the Universit\'e Paris VII in the autumn term of 1986--1987. Now available free of charge from the author's website},
	Pages = {176},
	Publisher = {Cambridge University Press},
	Title = {Proofs and types},
	Url = {http://www.monad.me.uk/stable/Proofs%2BTypes.html},
	Year = {1989},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEYuLi8uLi9QYXBlcnMvR2lyYXJkL0dpcmFyZC1UYXlsb3ItTGFmb250IC0gUHJvb2ZzIGFuZCB0eXBlcyAoMTk4OSkucGRm0hsPHB1XTlMuZGF0YU8RAeoAAAAAAeoAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADG4cx9HaXJhcmQtVGF5bG9yLUxhZm9udCMxNzUzQzQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF1PEwmmCuVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGR2lyYXJkABAACAAAwTR+XQAAABEACAAAwmm6+QAAAAEAEAAxuHMALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkdpcmFyZDpHaXJhcmQtVGF5bG9yLUxhZm9udCMxNzUzQzQucGRmAAAOAGYAMgBHAGkAcgBhAHIAZAAtAFQAYQB5AGwAbwByAC0ATABhAGYAbwBuAHQAIAAtACAAUAByAG8AbwBmAHMAIABhAG4AZAAgAHQAeQBwAGUAcwAgACgAMQA5ADgAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAE1Vc2Vycy9qZXJlbXkvUGFwZXJzL0dpcmFyZC9HaXJhcmQtVGF5bG9yLUxhZm9udCAtIFByb29mcyBhbmQgdHlwZXMgKDE5ODkpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA8wD4AQAC7gLwAvUC/gMJAw0DGwMiAysDMAMzAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA0A=},
	Bdsk-Url-1 = {http://www.monad.me.uk/stable/Proofs+Types.html}}

@incollection{Sestoft:Demonstrating:2002,
	Address = {New York, NY, USA},
	Author = {Peter Sestoft},
	Booktitle = {The essence of computation: {C}omplexity, analysis, transformation; essays dedicated to Neil D.~Jones},
	Date-Added = {2008-04-14 18:50:54 -0400},
	Date-Modified = {2008-04-17 14:54:17 -0400},
	Editor = {Torben {\AE}. Mogenson and David A. Schmidt and Sudborough, I. Hal},
	Isbn = {3-540-00326-6},
	Note = {See \url{http://www.dina.kvl.dk/~sestoft/lamreduce/} for a system implementing and visualizing the reduction strategies discussed in the paper},
	Pages = {420--435},
	Publisher = {Springer-Verlag},
	Read = {Yes},
	Series = {Lecture Notes in Computer Science},
	Title = {Demonstrating lambda calculus reduction},
	Volume = {2566: Festschrift},
	Year = {2002},
	Abstract = {We describe lambda calculus reduction strategies, such as call-by-value, call-by-name, normal order, and applicative order, using big-step operational semantics. We show how to simply and efficiently trace such reductions, and use this in a web-based lambda calculus reducer available at $\langle$ http://www.dina.kvl.dk/~sestoft/lamreduce/ $\rangle$.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFEuLi8uLi9QYXBlcnMvU2VzdG9mdC9TZXN0b2Z0IC0gRGVtb25zdHJhdGluZyBsYW1iZGEgY2FsY3VsdXMgcmVkdWN0aW9uICgyMDAyKS5wZGbSGw8cHVdOUy5kYXRhTxECCgAAAAACCgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAMbdDH1Nlc3RvZnQgLSBEZW1vbnN0cmF0IzE3NTNCMC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXU7DCaYJPAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdTZXN0b2Z0AAAQAAgAAME0fl0AAAARAAgAAMJpuo8AAAABABAAMbdDAC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpTZXN0b2Z0OlNlc3RvZnQgLSBEZW1vbnN0cmF0IzE3NTNCMC5wZGYADgB6ADwAUwBlAHMAdABvAGYAdAAgAC0AIABEAGUAbQBvAG4AcwB0AHIAYQB0AGkAbgBnACAAbABhAG0AYgBkAGEAIABjAGEAbABjAHUAbAB1AHMAIAByAGUAZAB1AGMAdABpAG8AbgAgACgAMgAwADAAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFhVc2Vycy9qZXJlbXkvUGFwZXJzL1Nlc3RvZnQvU2VzdG9mdCAtIERlbW9uc3RyYXRpbmcgbGFtYmRhIGNhbGN1bHVzIHJlZHVjdGlvbiAoMjAwMikucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAP4BAwELAxkDGwMgAykDNAM4A0YDTQNWA1sDXgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANr}}

@book{Barendregt:The-Lambda:1984,
	Address = {Amsterdam},
	Author = {Barendregt, H. P.},
	Date-Added = {2008-04-14 09:33:25 -0400},
	Date-Modified = {2008-04-14 09:35:19 -0400},
	Edition = {Revised},
	Publisher = {Elsevier},
	Series = {Studies in Logic and the Foundations of Mathematics},
	Title = {The Lambda Calculus: {I}ts Syntax and Semantics},
	Volume = {103},
	Year = {1984}}

@book{Pierce:Types:2002,
	Author = {Benjamin C. Pierce},
	Date-Added = {2008-04-14 01:02:02 -0400},
	Date-Modified = {2008-04-14 01:03:07 -0400},
	Errata = {http://www.cis.upenn.edu/~bcpierce/tapl/errata.txt},
	Homepage = {http://www.cis.upenn.edu/~bcpierce/tapl},
	Publisher = {MIT Press},
	Title = {Types and Programming Languages},
	Year = 2002}

@book{Pierce:Advanced:2005,
	Date-Added = {2008-04-14 01:02:02 -0400},
	Date-Modified = {2008-04-14 01:03:30 -0400},
	Editor = {Benjamin C. Pierce},
	Homepage = {http://www.cis.upenn.edu/~bcpierce/attapl},
	Publisher = {MIT Press},
	Title = {Advanced Topics in Types and Programming Languages},
	Year = 2005}

@book{Thompson:Type:1991,
	Author = {Thompson, Simon},
	Date-Added = {2008-04-14 00:55:33 -0400},
	Date-Modified = {2008-04-14 19:04:07 -0400},
	Isbn = {0-201-41667-0},
	Note = {Available free of charge from the author's website, \url{http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/}},
	Publisher = {Addison-Wesley},
	Title = {Type Theory and Functional Programming},
	Url = {http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/},
	Year = {1991},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFIuLi8uLi9QYXBlcnMvVGhvbXBzb24vVGhvbXBzb24gLSBUeXBlIFRoZW9yeSBhbmQgRnVuY3Rpb25hbCBQcm9ncmFtbWluZyAoMTk5MSkucGRm0hsPHB1XTlMuZGF0YU8RAg4AAAAAAg4AAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADG3hB9UaG9tcHNvbiAtIFR5cGUgVGhlbyMxNzUzQ0QucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF1PNwmmC2QAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIVGhvbXBzb24AEAAIAADBNH5dAAAAEQAIAADCabsZAAAAAQAQADG3hAAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6VGhvbXBzb246VGhvbXBzb24gLSBUeXBlIFRoZW8jMTc1M0NELnBkZgAADgB6ADwAVABoAG8AbQBwAHMAbwBuACAALQAgAFQAeQBwAGUAIABUAGgAZQBvAHIAeQAgAGEAbgBkACAARgB1AG4AYwB0AGkAbwBuAGEAbAAgAFAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMQA5ADkAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFlVc2Vycy9qZXJlbXkvUGFwZXJzL1Rob21wc29uL1Rob21wc29uIC0gVHlwZSBUaGVvcnkgYW5kIEZ1bmN0aW9uYWwgUHJvZ3JhbW1pbmcgKDE5OTEpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA/wEEAQwDHgMgAyUDLgM5Az0DSwNSA1sDYANjAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA3A=},
	Bdsk-Url-1 = {http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/}}

@unpublished{Steele-Jr.:The-evolution-uncut:1993,
	Author = {{Steele Jr.}, Guy L. and Richard P. Gabriel},
	Date-Added = {2008-04-12 19:44:58 -0400},
	Date-Modified = {2008-04-21 01:37:28 -0400},
	Keywords = {history of computing},
	Note = {Version of the HOPL-II conference paper with 32 pages of material restored that was cut due to lack of time to historically validate the claims made therein.},
	Title = {The evolution of {L}isp ({U}ncut)},
	Url = {http://www.dreamsongs.com/Files/HOPL2-Uncut.pdf},
	Year = {1993},
	Abstract = {

Lisp is the world's greatest programming language---or so its proponents think. The structure of Lisp makes it easy to extend the language or even to implement entirely new dialects without starting from scratch. Overall, the evolution of Lisp has been guided more by institutional rivalry, one-upsmanship, and the glee born of technical cleverness that is characteristic of the "hacker culture" than by sober assessments of technical requirements. Nevertheless this process has eventually produced both an industrial-strength programming language, messy but powerful, and a technically pure dialect, small but powerful, that is suitable for use by programming-language theoreticians. We pick up where McCarthy's paper in the first HOPL conference left off. We trace the development chronologically from the era of the PDP-6, through the heyday of Interlisp and MacLisp, past the ascension and decline of special purpose Lisp machines, to the present era of standardization activities. We then examine the technical evolution of a few representative language features, including both some notable successes and some notable failures, that illuminate design issues that distinguish Lisp from other programming languages. We also discuss the use of Lisp as a laboratory for designing other programming languages. We conclude with some reflections on the forces that have driven the evolution of Lisp.

},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFUuLi8uLi9QYXBlcnMvU3RlZWxlIEpyLi9TdGVlbGUgSnIuLUdhYnJpZWwgLSBUaGUgZXZvbHV0aW9uIG9mIExpc3AgKFVuY3V0KSAoMTk5MykucGRm0hsPHB1XTlMuZGF0YU8RAhYAAAAAAhYAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADGo1R9TdGVlbGUgSnIuLUdhYnJpZWwgLSMzMUE4RjgucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMaj4xCbCjQAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAKU3RlZWxlIEpyLgAQAAgAAME0fl0AAAARAAgAAMQm+s0AAAABABAAMajVAC2RPwADR6wAAGvYAAIAQ09kaW46VXNlcnM6amVyZW15OlBhcGVyczpTdGVlbGUgSnIuOlN0ZWVsZSBKci4tR2FicmllbCAtIzMxQThGOC5wZGYAAA4AfAA9AFMAdABlAGUAbABlACAASgByAC4ALQBHAGEAYgByAGkAZQBsACAALQAgAFQAaABlACAAZQB2AG8AbAB1AHQAaQBvAG4AIABvAGYAIABMAGkAcwBwACAAKABVAG4AYwB1AHQAKQAgACgAMQA5ADkAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFxVc2Vycy9qZXJlbXkvUGFwZXJzL1N0ZWVsZSBKci4vU3RlZWxlIEpyLi1HYWJyaWVsIC0gVGhlIGV2b2x1dGlvbiBvZiBMaXNwIChVbmN1dCkgKDE5OTMpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgECAQcBDwMpAysDMAM5A0QDSANWA10DZgNrA24AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADew==},
	Bdsk-Url-1 = {http://www.dreamsongs.com/Files/HOPL2-Uncut.pdf}}

@article{McCarthy:History:1978,
	Address = {New York, NY, USA},
	Author = {John McCarthy},
	Date-Added = {2008-04-12 19:11:07 -0400},
	Date-Modified = {2008-04-21 01:37:03 -0400},
	Doi = {http://doi.acm.org/10.1145/960118.808387},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Keywords = {history of computing},
	Number = {8},
	Pages = {217--223},
	Publisher = {ACM},
	Title = {History of {LISP}},
	Volume = {13},
	Year = {1978},
	Abstract = {This paper concentrates on the development of the basic ideas and

distinguishes two periods -- Summer 1956 through Summer 1958 when most
of the key ideas were developed (some of which were implemented in the
FORTRAN based FLPL), and Fall 1958 through 1962 when the programming
language was implemented and applied to problems of artificial

intelligence. After 1962, the development of LISP became
multi-stranded, and different ideas were pursued in different places.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEDsuLi8uLi9QYXBlcnMvTWNDYXJ0aHkvTWNDYXJ0aHkgLSBIaXN0b3J5IG9mIExJU1AgKDE5NzgpLnBkZtIbDxwdV05TLmRhdGFPEQHIAAAAAAHIAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAxp4gfTWNDYXJ0aHkgLSBIaXN0b3J5IG8jMzFBODk1LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADGolcQmj8wAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAACE1jQ2FydGh5ABAACAAAwTR+XQAAABEACAAAxCbIDAAAAAEAEAAxp4gALZE/AANHrAAAa9gAAgBBT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOk1jQ2FydGh5Ok1jQ2FydGh5IC0gSGlzdG9yeSBvIzMxQTg5NS5wZGYAAA4ATAAlAE0AYwBDAGEAcgB0AGgAeQAgAC0AIABIAGkAcwB0AG8AcgB5ACAAbwBmACAATABJAFMAUAAgACgAMQA5ADcAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAEJVc2Vycy9qZXJlbXkvUGFwZXJzL01jQ2FydGh5L01jQ2FydGh5IC0gSGlzdG9yeSBvZiBMSVNQICgxOTc4KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA6ADtAPUCwQLDAsgC0QLcAuAC7gL1Av4DAwMGAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAxM=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/960118.808387}}

@article{Steele-Jr.:The-evolution:1993,
	Address = {New York, NY, USA},
	Author = {{Steele Jr.}, Guy L. and Richard P. Gabriel},
	Date-Added = {2008-04-12 19:11:07 -0400},
	Date-Modified = {2008-04-21 01:37:28 -0400},
	Doi = {http://doi.acm.org/10.1145/155360.155373},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Keywords = {history of computing},
	Number = {3},
	Pages = {231--270},
	Publisher = {ACM},
	Rating = {5},
	Title = {The evolution of {L}isp},
	Volume = {28},
	Year = {1993},
	Abstract = {

Lisp is the world's greatest programming language---or so its proponents think. The structure of Lisp makes it easy to extend the language or even to implement entirely new dialects without starting from scratch. Overall, the evolution of Lisp has been guided more by institutional rivalry, one-upsmanship, and the glee born of technical cleverness that is characteristic of the "hacker culture" than by sober assessments of technical requirements. Nevertheless this process has eventually produced both an industrial-strength programming language, messy but powerful, and a technically pure dialect, small but powerful, that is suitable for use by programming-language theoreticians. We pick up where McCarthy's paper in the first HOPL conference left off. We trace the development chronologically from the era of the PDP-6, through the heyday of Interlisp and MacLisp, past the ascension and decline of special purpose Lisp machines, to the present era of standardization activities. We then examine the technical evolution of a few representative language features, including both some notable successes and some notable failures, that illuminate design issues that distinguish Lisp from other programming languages. We also discuss the use of Lisp as a laboratory for designing other programming languages. We conclude with some reflections on the forces that have driven the evolution of Lisp.

},
	Annote = {Fascinating reading. Like having a drink with Steele Jr. and Gabriel while they dish all the Lisp community gossip.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE0uLi8uLi9QYXBlcnMvU3RlZWxlIEpyLi9TdGVlbGUgSnIuLUdhYnJpZWwgLSBUaGUgZXZvbHV0aW9uIG9mIExpc3AgKDE5OTMpLnBkZtIbDxwdV05TLmRhdGFPEQH+AAAAAAH+AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAxqNUfU3RlZWxlIEpyLi1HYWJyaWVsIC0jMzFBODk2LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADGolsQmj84AAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAClN0ZWVsZSBKci4AEAAIAADBNH5dAAAAEQAIAADEJsgOAAAAAQAQADGo1QAtkT8AA0esAABr2AACAENPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6U3RlZWxlIEpyLjpTdGVlbGUgSnIuLUdhYnJpZWwgLSMzMUE4OTYucGRmAAAOAGwANQBTAHQAZQBlAGwAZQAgAEoAcgAuAC0ARwBhAGIAcgBpAGUAbAAgAC0AIABUAGgAZQAgAGUAdgBvAGwAdQB0AGkAbwBuACAAbwBmACAATABpAHMAcAAgACgAMQA5ADkAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFRVc2Vycy9qZXJlbXkvUGFwZXJzL1N0ZWVsZSBKci4vU3RlZWxlIEpyLi1HYWJyaWVsIC0gVGhlIGV2b2x1dGlvbiBvZiBMaXNwICgxOTkzKS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA+gD/AQcDCQMLAxADGQMkAygDNgM9A0YDSwNOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA1s=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/155360.155373}}

@article{Cardelli:On-understanding:1985,
	Address = {New York, NY, USA},
	Author = {Luca Cardelli and Peter Wegner},
	Date-Added = {2008-04-12 19:11:07 -0400},
	Date-Modified = {2008-04-13 17:01:47 -0400},
	Doi = {http://doi.acm.org/10.1145/6041.6042},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Number = {4},
	Pages = {471--523},
	Publisher = {ACM},
	Rating = {5},
	Title = {On understanding types, data abstraction, and polymorphism},
	Volume = {17},
	Year = {1985},
	Abstract = {Our objective is to understand the notion of \textit{type} in programming languages, present a model of typed, polymorphic programming languages that reflects recent research in type theory, and examine the relevance of recent research to the design of practical programming languages.

Object-oriented languages provide both a framework and a motivation for exploring the interaction among the concepts of type, data abstraction, and polymorphism, since they extend the notion of type to data abstraction and since type inheritance is an important form of polymorphism. We develop a $\lambda$-calculus--based model for type systems that allows us to explore these interactions in a simple setting, unencumbered by complexities of production programming languages.

The evolution of languages from untyped universes to monomorphic and then polymorphic type systems is reviewed. Mechanisms for polymorphism such as overloading, coercion, subtyping, and parameterization are examined. A unifying framework for polymorphic type systems is developed in terms of the typed $\lambda$-calculus augmented to include binding of types by quantification as well as binding of values by abstraction.

The typed $\lambda$-calculus is augmented by universal quantification to model generic functions with type parameters, existential quantification and packaging (information hiding) to model abstract data types, and bounded quantification to model subtypes and type inheritance. In this way we obtain a simple and precise characterization of a powerful type system that includes abstract datatypes, parametric polymorphism, and multiple inheritance in a single consistent framework. The mechanisms for type checking for the augmented $\lambda$-calculus are discussed.

The augmented typed $\lambda$;-calculus is used as a programming language for a variety of illustrative examples. We christen this language \textsf{Fun} because fun instead of $\lambda$ is the functional abstraction keyword and because it is pleasant to deal with.

\textsf{Fun} is mathematically simple and can serve as a basis for the design and implementation of real programming languages with type facilities that are more powerful and expressive than those of existing programming languages. In particular, it provides a basis for the design of strongly typed object-oriented languages.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEG0uLi8uLi9QYXBlcnMvQ2FyZGVsbGkvQ2FyZGVsbGktV2VnbmVyIC0gT24gdW5kZXJzdGFuZGluZyB0eXBlcywgZGF0YSBhYnN0cmFjdGlvbiwgYW5kIHBvbHltb3JwaGlzbSAoMTk4NSkucGRm0hsPHB1XTlMuZGF0YU8RAl4AAAAAAl4AAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2Tph9DYXJkZWxsaS1XZWduZXIgLSBPbiMzMUE4OTcucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMaiXxCaP0AAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIQ2FyZGVsbGkAEAAIAADBNH5dAAAAEQAIAADEJsgQAAAAAQAQAC2TpgAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6Q2FyZGVsbGk6Q2FyZGVsbGktV2VnbmVyIC0gT24jMzFBODk3LnBkZgAADgCwAFcAQwBhAHIAZABlAGwAbABpAC0AVwBlAGcAbgBlAHIAIAAtACAATwBuACAAdQBuAGQAZQByAHMAdABhAG4AZABpAG4AZwAgAHQAeQBwAGUAcwAsACAAZABhAHQAYQAgAGEAYgBzAHQAcgBhAGMAdABpAG8AbgAsACAAYQBuAGQAIABwAG8AbAB5AG0AbwByAHAAaABpAHMAbQAgACgAMQA5ADgANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHRVc2Vycy9qZXJlbXkvUGFwZXJzL0NhcmRlbGxpL0NhcmRlbGxpLVdlZ25lciAtIE9uIHVuZGVyc3RhbmRpbmcgdHlwZXMsIGRhdGEgYWJzdHJhY3Rpb24sIGFuZCBwb2x5bW9ycGhpc20gKDE5ODUpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEaAR8BJwOJA4sDkAOZA6QDqAO2A70DxgPLA84AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAD2w==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/6041.6042}}

@article{Backus:Can-programming:1978,
	Address = {New York, NY, USA},
	Author = {John Backus},
	Date-Added = {2008-04-12 19:06:12 -0400},
	Date-Modified = {2008-04-12 19:07:07 -0400},
	Doi = {http://doi.acm.org/10.1145/359576.359579},
	Issn = {0001-0782},
	Journal = {Commun. ACM},
	Number = {8},
	Pages = {613--641},
	Publisher = {ACM},
	Title = {Can programming be liberated from the von Neumann style?: a functional style and its algebra of programs},
	Volume = {21},
	Year = {1978},
	Abstract = {Conventional programming languages are growing ever more enormous, but not stronger. Inherent defects at the most basic level cause them to be both fat and weak: their primitive word-at-a-time style of programming inherited from their common ancestor---the von Neumann computer, their close coupling of semantics to state transitions, their division of programming into a world of expressions and a world of statements, their inability to effectively use powerful combining forms for building new programs from existing ones, and their lack of useful mathematical properties for reasoning about programs. An alternative functional style of programming is founded on the use of combining forms for creating programs. Functional programs deal with structured data, are often nonrepetitive and nonrecursive, are hierarchically constructed, do not name their arguments, and do not require the complex machinery of procedure declarations to become generally applicable. Combining forms can use high level programs to build still higher level ones in a style not possible in conventional languages. Associated with the functional style of programming is an algebra of programs whose variables range over programs and whose operations are combining forms. This algebra can be used to transform programs and to solve equations whose "unknowns" are programs in much the same way one transforms equations in high school algebra. These transformations are given by algebraic laws and are carried out in the same language in which programs are written. Combining forms are chosen not only for their programming power but also for the power of their associated algebraic laws. General theorems of the algebra give the detailed behavior and termination conditions for large classes of programs. A new class of computing systems uses the functional programming style both in its programming language and in its state transition rules. Unlike von Neumann languages, these systems have semantics loosely coupled to states---only one state transition occurs per major computation.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGEuLi8uLi9QYXBlcnMvQmFja3VzL0JhY2t1cyAtIENhbiBwcm9ncmFtbWluZyBiZSBsaWJlcmF0ZWQgZnJvbSB0aGUgdm9uIE5ldW1hbm4gc3R5bGU/OiAoMTk3OCkucGRm0hsPHB1XTlMuZGF0YU8RAjoAAAAAAjoAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADGn1B9CYWNrdXMgLSBDYW4gcHJvZ3JhbSMzMUE3RDYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMafWxCa46FBERiBwcnZ3AAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGQmFja3VzABAACAAAwTR+XQAAABEACAAAxCbxKAAAAAEAEAAxp9QALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkJhY2t1czpCYWNrdXMgLSBDYW4gcHJvZ3JhbSMzMUE3RDYucGRmAAAOAJwATQBCAGEAYwBrAHUAcwAgAC0AIABDAGEAbgAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgAGIAZQAgAGwAaQBiAGUAcgBhAHQAZQBkACAAZgByAG8AbQAgAHQAaABlACAAdgBvAG4AIABOAGUAdQBtAGEAbgBuACAAcwB0AHkAbABlAD8ALwAgACgAMQA5ADcAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGhVc2Vycy9qZXJlbXkvUGFwZXJzL0JhY2t1cy9CYWNrdXMgLSBDYW4gcHJvZ3JhbW1pbmcgYmUgbGliZXJhdGVkIGZyb20gdGhlIHZvbiBOZXVtYW5uIHN0eWxlPzogKDE5NzgpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEOARMBGwNZA1sDYANpA3QDeAOGA40DlgObA54AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/359576.359579}}

@article{Wadler:Why-no-one-uses:1998,
	Address = {New York, NY, USA},
	Author = {Philip Wadler},
	Date-Added = {2008-04-12 19:06:12 -0400},
	Date-Modified = {2008-04-12 19:07:07 -0400},
	Doi = {http://doi.acm.org/10.1145/286385.286387},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {8},
	Pages = {23--27},
	Publisher = {ACM},
	Title = {Why no one uses functional languages},
	Url = {\url{http://homepages.inf.ed.ac.uk/wadler/papers/sigplan-why/sigplan-why.ps}},
	Volume = {33},
	Year = {1998},
	Abstract = {This column lists eight reasons why functional languages are not more

widely used (compatibility, libraries, portability, availability,
packagability, tools, training, and popularity) and two non-reasons
(performance and ``they just don't get it''), then draws four lessons.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEwuLi8uLi9QYXBlcnMvV2FkbGVyL1dhZGxlciAtIFdoeSBubyBvbmUgdXNlcyBmdW5jdGlvbmFsIGxhbmd1YWdlcyAoMTk5OCkucGRm0hsPHB1XTlMuZGF0YU8RAfwAAAAAAfwAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2ReB9XYWRsZXIgLSBXaHkgbm8gb25lICMzMUE3QzIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMafCxCa4vFBERiBwcnZ3AAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGV2FkbGVyABAACAAAwTR+XQAAABEACAAAxCbw/AAAAAEAEAAtkXgALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOldhZGxlcjpXYWRsZXIgLSBXaHkgbm8gb25lICMzMUE3QzIucGRmAAAOAHIAOABXAGEAZABsAGUAcgAgAC0AIABXAGgAeQAgAG4AbwAgAG8AbgBlACAAdQBzAGUAcwAgAGYAdQBuAGMAdABpAG8AbgBhAGwAIABsAGEAbgBnAHUAYQBnAGUAcwAgACgAMQA5ADkAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFNVc2Vycy9qZXJlbXkvUGFwZXJzL1dhZGxlci9XYWRsZXIgLSBXaHkgbm8gb25lIHVzZXMgZnVuY3Rpb25hbCBsYW5ndWFnZXMgKDE5OTgpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA+QD+AQYDBgMIAw0DFgMhAyUDMwM6A0MDSANLAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA1g=},
	Bdsk-Url-1 = {http://homepages.inf.ed.ac.uk/wadler/papers/sigplan-why/sigplan-why.ps},
	Bdsk-Url-2 = {http://doi.acm.org/10.1145/286385.286387}}

@inproceedings{Barendregt:Types:1990,
	Address = {London, UK},
	Author = {Henk Barendregt and Kees Hemerik},
	Booktitle = {ESOP '90: Proceedings of the 3rd European Symposium on Programming},
	Date-Added = {2008-04-12 19:04:51 -0400},
	Date-Modified = {2008-04-12 19:04:58 -0400},
	Isbn = {3-540-52592-0},
	Pages = {1--35},
	Publisher = {Springer-Verlag},
	Title = {Types in Lambda Calculi and Programming Languages},
	Year = {1990},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGkuLi8uLi9QYXBlcnMvQmFyZW5kcmVndC9CYXJlbmRyZWd0LUhlbWVyaWsgLSBUeXBlcyBpbiBMYW1iZGEgQ2FsY3VsaSBhbmQgUHJvZ3JhbW1pbmcgTGFuZ3VhZ2VzICgxOTkwKS5wZGbSGw8cHVdOUy5kYXRhTxECUgAAAAACUgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAMae1H0JhcmVuZHJlZ3QtSGVtZXJpayAtIzMxQTdBMy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxp6PEJrhlUERGIHBydncAAgADAAAJIAAAAAAAAAAAAAAAAAAAAApCYXJlbmRyZWd0ABAACAAAwTR+XQAAABEACAAAxCbwpQAAAAEAEAAxp7UALZE/AANHrAAAa9gAAgBDT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkJhcmVuZHJlZ3Q6QmFyZW5kcmVndC1IZW1lcmlrIC0jMzFBN0EzLnBkZgAADgCkAFEAQgBhAHIAZQBuAGQAcgBlAGcAdAAtAEgAZQBtAGUAcgBpAGsAIAAtACAAVAB5AHAAZQBzACAAaQBuACAATABhAG0AYgBkAGEAIABDAGEAbABjAHUAbABpACAAYQBuAGQAIABQAHIAbwBnAHIAYQBtAG0AaQBuAGcAIABMAGEAbgBnAHUAYQBnAGUAcwAgACgAMQA5ADkAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHBVc2Vycy9qZXJlbXkvUGFwZXJzL0JhcmVuZHJlZ3QvQmFyZW5kcmVndC1IZW1lcmlrIC0gVHlwZXMgaW4gTGFtYmRhIENhbGN1bGkgYW5kIFByb2dyYW1taW5nIExhbmd1YWdlcyAoMTk5MCkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARYBGwEjA3kDewOAA4kDlAOYA6YDrQO2A7sDvgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAPL}}

@article{Bruijn:Lambda:1972,
	Author = {de Bru{\ij}n, N. G.},
	Date-Added = {2008-04-12 19:04:51 -0400},
	Date-Modified = {2008-04-16 21:31:06 -0400},
	Journal = {Indagationes Mathematic{\ae}},
	Number = {5},
	Pages = {381-392},
	Title = {Lambda calculus notation with nameless dummies, a tool for automatic formula manipulation, with application to the {C}hurch--{R}osser theorem},
	Volume = {34},
	Year = 1972,
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE4uLi8uLi9QYXBlcnMvQnJ1aWpuL0JydWlqbiAtIExhbWJkYSBjYWxjdWx1cyBub3RhdGlvbiB3aXRoIG5hbWVsZXNzICgxOTcyKS5wZGbSGw8cHVdOUy5kYXRhTxECAgAAAAACAgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAMae0H0JydWlqbiAtIExhbWJkYSBjYWxjIzMxQTdBOS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxp6nEJrhyUERGIHBydncAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZCcnVpam4AEAAIAADBNH5dAAAAEQAIAADEJvCyAAAAAQAQADGntAAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QnJ1aWpuOkJydWlqbiAtIExhbWJkYSBjYWxjIzMxQTdBOS5wZGYAAA4AdgA6AEIAcgB1AGkAagBuACAALQAgAEwAYQBtAGIAZABhACAAYwBhAGwAYwB1AGwAdQBzACAAbgBvAHQAYQB0AGkAbwBuACAAdwBpAHQAaAAgAG4AYQBtAGUAbABlAHMAcwAgACgAMQA5ADcAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFVVc2Vycy9qZXJlbXkvUGFwZXJzL0JydWlqbi9CcnVpam4gLSBMYW1iZGEgY2FsY3VsdXMgbm90YXRpb24gd2l0aCBuYW1lbGVzcyAoMTk3MikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD7AQABCAMOAxADFQMeAykDLQM7A0IDSwNQA1MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADYA==},
	Bdsk-File-2 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFAuLi8uLi9QYXBlcnMvQnJ1XGlqbi9CcnVcaWpuIC0gTGFtYmRhIGNhbGN1bHVzIG5vdGF0aW9uIHdpdGggbmFtZWxlc3MgKDE5NzIpLnBkZtIbDxwdV05TLmRhdGFPEQIIAAAAAAIIAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAx9QgfQnJ1XGlqbiAtIExhbWJkYSBjYWwjMzFGNDU3LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADH0V8QsFwpQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAB0JydVxpam4AABAACAAAwTR+XQAAABEACAAAxCxPSgAAAAEAEAAx9QgALZE/AANHrAAAa9gAAgBAT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkJydVxpam46QnJ1XGlqbiAtIExhbWJkYSBjYWwjMzFGNDU3LnBkZgAOAHgAOwBCAHIAdQBcAGkAagBuACAALQAgAEwAYQBtAGIAZABhACAAYwBhAGwAYwB1AGwAdQBzACAAbgBvAHQAYQB0AGkAbwBuACAAdwBpAHQAaAAgAG4AYQBtAGUAbABlAHMAcwAgACgAMQA5ADcAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFdVc2Vycy9qZXJlbXkvUGFwZXJzL0JydVxpam4vQnJ1XGlqbiAtIExhbWJkYSBjYWxjdWx1cyBub3RhdGlvbiB3aXRoIG5hbWVsZXNzICgxOTcyKS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAP0BAgEKAxYDGAMdAyYDMQM1A0MDSgNTA1gDWwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANo}}

@article{Douence:A-systematic:1998a,
	Address = {New York, NY, USA},
	Author = {R\'{e}mi Douence and Pascal Fradet},
	Date-Added = {2008-04-12 18:58:16 -0400},
	Date-Modified = {2008-04-12 18:58:38 -0400},
	Doi = {http://doi.acm.org/10.1145/276393.276397},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Number = {2},
	Pages = {344--387},
	Publisher = {ACM},
	Title = {A systematic study of functional language implementations},
	Volume = {20},
	Year = {1998},
	Abstract = {We introduce a unified framework to describe, relate, compare, and classify functional language implementations. The compilation process is expressed as a succession of program transformations in the common framework. At each step, different transformations model fundamental choices. A benefit of this approach is to structure and decompose the implementation process. The correctness proofs can be tackled independently for each step and amount to proving program transformations in the functional world. This approach also paves the way to formal comparisons by making it possible to estimate the complexity of individual transformations or compositions of them. Our study aims at covering the whole known design space of sequential functional language implementations. In particular, we consider call-by-value, call-by-name, call-by-need reduction strategies as well as environment- and graph-based implementations. We describe for each compilation step the diverse alternatives as program transformations. In some cases, we illustrate how to compare or relate compilation techniques, express global optimizations, or hybrid implementations. We also provide a classification of well-known abstract machines.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGsuLi8uLi9QYXBlcnMvRG91ZW5jZS9Eb3VlbmNlLUZyYWRldCAtIEEgc3lzdGVtYXRpYyBzdHVkeSBvZiBmdW5jdGlvbmFsIGxhbmd1YWdlIGltcGxlbWVudGF0aW9ucyAoMTk5OGEpLnBkZtIbDxwdV05TLmRhdGFPEQJYAAAAAAJYAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtk0kfRG91ZW5jZS1GcmFkZXQgLSBBIHMjMzFBNzQ4LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADGnSMQmtvFQREYgcHJ2dwACAAMAAAkgAAAAAAAAAAAAAAAAAAAAB0RvdWVuY2UAABAACAAAwTR+XQAAABEACAAAxCbvMQAAAAEAEAAtk0kALZE/AANHrAAAa9gAAgBAT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkRvdWVuY2U6RG91ZW5jZS1GcmFkZXQgLSBBIHMjMzFBNzQ4LnBkZgAOAK4AVgBEAG8AdQBlAG4AYwBlAC0ARgByAGEAZABlAHQAIAAtACAAQQAgAHMAeQBzAHQAZQBtAGEAdABpAGMAIABzAHQAdQBkAHkAIABvAGYAIABmAHUAbgBjAHQAaQBvAG4AYQBsACAAbABhAG4AZwB1AGEAZwBlACAAaQBtAHAAbABlAG0AZQBuAHQAYQB0AGkAbwBuAHMAIAAoADEAOQA5ADgAYQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHJVc2Vycy9qZXJlbXkvUGFwZXJzL0RvdWVuY2UvRG91ZW5jZS1GcmFkZXQgLSBBIHN5c3RlbWF0aWMgc3R1ZHkgb2YgZnVuY3Rpb25hbCBsYW5ndWFnZSBpbXBsZW1lbnRhdGlvbnMgKDE5OThhKS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBGAEdASUDgQODA4gDkQOcA6ADrgO1A74DwwPGAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA9M=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/276393.276397}}

@inproceedings{McCarthy:LISP:1980,
	Address = {New York, NY, USA},
	Author = {John McCarthy},
	Booktitle = {LFP '80: Proceedings of the 1980 ACM conference on LISP and functional programming},
	Date-Added = {2008-04-12 18:58:16 -0400},
	Date-Modified = {2008-04-21 01:37:28 -0400},
	Doi = {http://doi.acm.org/10.1145/800087.802782},
	Keywords = {history of computing},
	Location = {Stanford University, California, United States},
	Pages = {.5--viii},
	Publisher = {ACM},
	Title = {LISP - notes on its past and future},
	Year = {1980},
	Abstract = {LISP has survived for 21 years because it is an approximate local optimum in the space of programming languages. However, it has accumulated some barnacles that should be scraped off, and some long-standing opportunities for improvement have been neglected. It would benefit from some co-operative maintenance especially in creating and maintaining program libraries. Computer checked proofs of program correctness are now possible for pure LISP and some extensions, but more theory and some smoothing of the language itself are required before we can take full advantage of LISP's mathematical basis.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE8uLi8uLi9QYXBlcnMvTWNDYXJ0aHkvTWNDYXJ0aHkgLSBMSVNQIC0gbm90ZXMgb24gaXRzIHBhc3QgYW5kIGZ1dHVyZSAoMTk4MCkucGRm0hsPHB1XTlMuZGF0YU8RAgQAAAAAAgQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADGniB9NY0NhcnRoeSAtIExJU1AgLSBubyMzMUE3NjIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMadixCa3UwAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAITWNDYXJ0aHkAEAAIAADBNH5dAAAAEQAIAADEJu+TAAAAAQAQADGniAAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6TWNDYXJ0aHk6TWNDYXJ0aHkgLSBMSVNQIC0gbm8jMzFBNzYyLnBkZgAADgB0ADkATQBjAEMAYQByAHQAaAB5ACAALQAgAEwASQBTAFAAIAAtACAAbgBvAHQAZQBzACAAbwBuACAAaQB0AHMAIABwAGEAcwB0ACAAYQBuAGQAIABmAHUAdAB1AHIAZQAgACgAMQA5ADgAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFZVc2Vycy9qZXJlbXkvUGFwZXJzL01jQ2FydGh5L01jQ2FydGh5IC0gTElTUCAtIG5vdGVzIG9uIGl0cyBwYXN0IGFuZCBmdXR1cmUgKDE5ODApLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD8AQEBCQMRAxMDGAMhAywDMAM+A0UDTgNTA1YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADYw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/800087.802782}}

@article{McCarthy:Recursive:1960,
	Address = {New York, NY, USA},
	Author = {John McCarthy},
	Date-Added = {2008-04-12 18:58:16 -0400},
	Date-Modified = {2008-04-12 18:58:38 -0400},
	Doi = {http://doi.acm.org/10.1145/367177.367199},
	Issn = {0001-0782},
	Journal = {Commun. ACM},
	Number = {4},
	Pages = {184--195},
	Publisher = {ACM},
	Title = {Recursive functions of symbolic expressions and their computation by machine, Part I},
	Volume = {3},
	Year = {1960},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGEuLi8uLi9QYXBlcnMvTWNDYXJ0aHkvTWNDYXJ0aHkgLSBSZWN1cnNpdmUgZnVuY3Rpb25zIG9mIHN5bWJvbGljIGV4cHJlc3Npb25zIGFuZCB0aGVpciAoMTk2MCkucGRm0hsPHB1XTlMuZGF0YU8RAjoAAAAAAjoAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADGniB9NY0NhcnRoeSAtIFJlY3Vyc2l2ZSMzMUE3OTUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMaeVxCa4DAAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAITWNDYXJ0aHkAEAAIAADBNH5dAAAAEQAIAADEJvBMAAAAAQAQADGniAAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6TWNDYXJ0aHk6TWNDYXJ0aHkgLSBSZWN1cnNpdmUjMzFBNzk1LnBkZgAADgCYAEsATQBjAEMAYQByAHQAaAB5ACAALQAgAFIAZQBjAHUAcgBzAGkAdgBlACAAZgB1AG4AYwB0AGkAbwBuAHMAIABvAGYAIABzAHkAbQBiAG8AbABpAGMAIABlAHgAcAByAGUAcwBzAGkAbwBuAHMAIABhAG4AZAAgAHQAaABlAGkAcgAgACgAMQA5ADYAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGhVc2Vycy9qZXJlbXkvUGFwZXJzL01jQ2FydGh5L01jQ2FydGh5IC0gUmVjdXJzaXZlIGZ1bmN0aW9ucyBvZiBzeW1ib2xpYyBleHByZXNzaW9ucyBhbmQgdGhlaXIgKDE5NjApLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEOARMBGwNZA1sDYANpA3QDeAOGA40DlgObA54AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/367177.367199}}

@article{Layer:Lisp:1991,
	Address = {New York, NY, USA},
	Author = {D. Kevin Layer and Chris Richardson},
	Date-Added = {2008-04-12 18:58:16 -0400},
	Date-Modified = {2008-04-21 01:37:28 -0400},
	Doi = {http://doi.acm.org/10.1145/114669.114674},
	Issn = {0001-0782},
	Journal = {Commun. ACM},
	Keywords = {history of computing},
	Number = {9},
	Pages = {48--57},
	Publisher = {ACM},
	Title = {Lisp systems in the 1990s},
	Volume = {34},
	Year = {1991},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEouLi8uLi9QYXBlcnMvTGF5ZXIvTGF5ZXItUmljaGFyZHNvbiAtIExpc3Agc3lzdGVtcyBpbiB0aGUgMTk5MHMgKDE5OTEpLnBkZtIbDxwdV05TLmRhdGFPEQH2AAAAAAH2AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAxp1IfTGF5ZXItUmljaGFyZHNvbiAtIEwjMjlGODdFLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACn4fgAAAAAAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABUxheWVyAAAQAAgAAME0fl0AAAARAAgAAAAAAAAAAAABABAAMadSAC2RPwADR6wAAGvYAAIAPk9kaW46VXNlcnM6amVyZW15OlBhcGVyczpMYXllcjpMYXllci1SaWNoYXJkc29uIC0gTCMyOUY4N0UucGRmAA4AcAA3AEwAYQB5AGUAcgAtAFIAaQBjAGgAYQByAGQAcwBvAG4AIAAtACAATABpAHMAcAAgAHMAeQBzAHQAZQBtAHMAIABpAG4AIAB0AGgAZQAgADEAOQA5ADAAcwAgACgAMQA5ADkAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFFVc2Vycy9qZXJlbXkvUGFwZXJzL0xheWVyL0xheWVyLVJpY2hhcmRzb24gLSBMaXNwIHN5c3RlbXMgaW4gdGhlIDE5OTBzICgxOTkxKS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPcA/AEEAv4DAAMFAw4DGQMdAysDMgM7A0ADQwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANQ},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/114669.114674}}

@inproceedings{Stoyan:Early:1984,
	Address = {New York, NY, USA},
	Author = {Herbert Stoyan},
	Booktitle = {LFP '84: Proceedings of the 1984 ACM Symposium on LISP and functional programming},
	Date-Added = {2008-04-12 18:58:16 -0400},
	Date-Modified = {2008-04-21 01:36:32 -0400},
	Doi = {http://doi.acm.org/10.1145/800055.802047},
	Isbn = {0-89791-142-3},
	Keywords = {history of computing},
	Location = {Austin, Texas, United States},
	Pages = {299--310},
	Publisher = {ACM},
	Read = {Yes},
	Title = {Early LISP history (1956 - 1959)},
	Year = {1984},
	Abstract = {This paper describes the development of LISP from McCarthy's first research in the topic of programming languages for AI until the stage when the LISP1 implementation had developed into a serious program (May 1959). We show the steps that led to LISP and the various proposals for LISP interpreters (between November 1958 and May 1959). The paper contains some correcting details to our book (32).},
	Annote = {Improves on McCarthy's own recollection through a basis in available written record. Very interesting look at what led up to the realization of honest-to-goodness LISP.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEguLi8uLi9QYXBlcnMvU3RveWFuL1N0b3lhbiAtIEVhcmx5IExJU1AgaGlzdG9yeSAoMTk1NiAtIDE5NTkpICgxOTg0KS5wZGbSGw8cHVdOUy5kYXRhTxEB8AAAAAAB8AACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAMadUH1N0b3lhbiAtIEVhcmx5IExJU1AgIzI5Rjg4MC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp+IAAAAAAAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZTdG95YW4AEAAIAADBNH5dAAAAEQAIAAAAAAAAAAAAAQAQADGnVAAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6U3RveWFuOlN0b3lhbiAtIEVhcmx5IExJU1AgIzI5Rjg4MC5wZGYAAA4AagA0AFMAdABvAHkAYQBuACAALQAgAEUAYQByAGwAeQAgAEwASQBTAFAAIABoAGkAcwB0AG8AcgB5ACAAKAAxADkANQA2ACAALQAgADEAOQA1ADkAKQAgACgAMQA5ADgANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAE9Vc2Vycy9qZXJlbXkvUGFwZXJzL1N0b3lhbi9TdG95YW4gLSBFYXJseSBMSVNQIGhpc3RvcnkgKDE5NTYgLSAxOTU5KSAoMTk4NCkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD1APoBAgL2AvgC/QMGAxEDFQMjAyoDMwM4AzsAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADSA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/800055.802047}}

@article{Mody:Functional:1992,
	Address = {New York, NY, USA},
	Author = {R. P. Mody},
	Date-Added = {2008-04-12 18:58:16 -0400},
	Date-Modified = {2008-04-12 18:58:38 -0400},
	Doi = {http://doi.acm.org/10.1145/141018.141021},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {11},
	Pages = {13--14},
	Publisher = {ACM},
	Title = {Functional programming is not self-modifying code},
	Volume = {27},
	Year = {1992},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFUuLi8uLi9QYXBlcnMvTW9keS9Nb2R5IC0gRnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpcyBub3Qgc2VsZi1tb2RpZnlpbmcgY29kZSAoMTk5MikucGRm0hsPHB1XTlMuZGF0YU8RAhYAAAAAAhYAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADGnUx9Nb2R5IC0gRnVuY3Rpb25hbCBwciMyOUY4N0YucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKfh/AAAAAAAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAETW9keQAQAAgAAME0fl0AAAARAAgAAAAAAAAAAAABABAAMadTAC2RPwADR6wAAGvYAAIAPU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpNb2R5Ok1vZHkgLSBGdW5jdGlvbmFsIHByIzI5Rjg3Ri5wZGYAAA4AiABDAE0AbwBkAHkAIAAtACAARgB1AG4AYwB0AGkAbwBuAGEAbAAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgAGkAcwAgAG4AbwB0ACAAcwBlAGwAZgAtAG0AbwBkAGkAZgB5AGkAbgBnACAAYwBvAGQAZQAgACgAMQA5ADkAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFxVc2Vycy9qZXJlbXkvUGFwZXJzL01vZHkvTW9keSAtIEZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaXMgbm90IHNlbGYtbW9kaWZ5aW5nIGNvZGUgKDE5OTIpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgECAQcBDwMpAysDMAM5A0QDSANWA10DZgNrA24AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADew==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/141018.141021}}

@article{Yuen:Which:1991,
	Address = {This article reviews models of programming applicable to Lisp, and argues that both the sequential model and the functional model have  developed in directions of excessive complexity. For future developments, a mixed model based on old-style Lisp, but augmented with new parallel constructs, can provide a simpler tool for handling practical programming tasks.},
	Author = {C. K. Yuen},
	Date-Added = {2008-04-12 18:58:16 -0400},
	Date-Modified = {2008-04-12 18:58:38 -0400},
	Doi = {http://doi.acm.org/10.1145/122616.122626},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Number = {10},
	Pages = {83--92},
	Publisher = {ACM},
	Title = {Which model of programming for LISP: sequential, functional or mixed?},
	Volume = {26},
	Year = {1991},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFQuLi8uLi9QYXBlcnMvWXVlbi9ZdWVuIC0gV2hpY2ggbW9kZWwgb2YgcHJvZ3JhbW1pbmcgZm9yIExJU1A6IHNlcXVlbnRpYWwsICgxOTkxKS5wZGbSGw8cHVdOUy5kYXRhTxECFAAAAAACFAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAMadVH1l1ZW4gLSBXaGljaCBtb2RlbCBvIzI5Rjg4MS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp+IEAAAAAAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAARZdWVuABAACAAAwTR+XQAAABEACAAAAAAAAAAAAAEAEAAxp1UALZE/AANHrAAAa9gAAgA9T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOll1ZW46WXVlbiAtIFdoaWNoIG1vZGVsIG8jMjlGODgxLnBkZgAADgCGAEIAWQB1AGUAbgAgAC0AIABXAGgAaQBjAGgAIABtAG8AZABlAGwAIABvAGYAIABwAHIAbwBnAHIAYQBtAG0AaQBuAGcAIABmAG8AcgAgAEwASQBTAFAALwAgAHMAZQBxAHUAZQBuAHQAaQBhAGwALAAgACgAMQA5ADkAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFtVc2Vycy9qZXJlbXkvUGFwZXJzL1l1ZW4vWXVlbiAtIFdoaWNoIG1vZGVsIG9mIHByb2dyYW1taW5nIGZvciBMSVNQOiBzZXF1ZW50aWFsLCAoMTk5MSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEBAQYBDgMmAygDLQM2A0EDRQNTA1oDYwNoA2sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADeA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/122616.122626}}

@inproceedings{Demaine:Cache-Oblivious:2002,
	Address = {BRICS, University of Aarhus, Denmark},
	Author = {Demaine, Erik D.},
	Booktitle = {Lecture Notes from the EEF Summer School on Massive Data Sets},
	Bookurl = {http://www.brics.dk/MassiveData02/},
	Date-Added = {2008-04-03 13:05:11 -0400},
	Date-Modified = {2008-04-03 13:28:03 -0400},
	Length = {29 pages},
	Month = {June 27--July 1},
	Note = {To appear},
	Publisher = {Springer-Verlag},
	Read = {Yes},
	Series = {Lecture Notes in Computer Science},
	Seriesurl = {http://www.springer.de/comp/lncs/},
	Title = {Cache-Oblivious Algorithms and Data Structures},
	Url = {http://erikdemaine.org/papers/BRICS2002/},
	Year = {2002},
	Abstract = {A recent direction in the design of cache-efficient and disk-efficient algorithms and data structures is the notion of \textit{cache obliviousness,} introduced by Frigo, Leiserson, Prokop, and Ramachandran in 1999. Cache-oblivious algorithms perform well on a multilevel memory hierarchy without knowing any parameters of the hierarchy, only knowing the existence of a hierarchy. Equivalently, a single cache-oblivious algorithm is efficient on all memory hierarchies simultaneously. While such results might seem impossible, a recent body of work has developed cache-oblivious algorithms and data structures that perform as well or nearly as well as standard external-memory structures which require knowledge of the cache/memory size and block transfer size. Here we describe several of these results with the intent of elucidating the techniques behind their design. Perhaps the most exciting of these results are the data structures, which form general building blocks immediately leading to several algorithmic results.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFguLi8uLi9QYXBlcnMvRGVtYWluZS9EZW1haW5lIC0gQ2FjaGUtT2JsaXZpb3VzIEFsZ29yaXRobXMgYW5kIERhdGEgU3RydWN0dXJlcyAoMjAwMikucGRm0hsPHB1XTlMuZGF0YU8RAiAAAAAAAiAAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADFGcR9EZW1haW5lIC0gQ2FjaGUtT2JsaSMzMTQ2MEUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMUYOxBqKjlBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAHRGVtYWluZQAAEAAIAADBNH5dAAAAEQAIAADEGsLOAAAAAQAQADFGcQAtkT8AA0esAABr2AACAEBPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6RGVtYWluZTpEZW1haW5lIC0gQ2FjaGUtT2JsaSMzMTQ2MEUucGRmAA4AiABDAEQAZQBtAGEAaQBuAGUAIAAtACAAQwBhAGMAaABlAC0ATwBiAGwAaQB2AGkAbwB1AHMAIABBAGwAZwBvAHIAaQB0AGgAbQBzACAAYQBuAGQAIABEAGEAdABhACAAUwB0AHIAdQBjAHQAdQByAGUAcwAgACgAMgAwADAAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF9Vc2Vycy9qZXJlbXkvUGFwZXJzL0RlbWFpbmUvRGVtYWluZSAtIENhY2hlLU9ibGl2aW91cyBBbGdvcml0aG1zIGFuZCBEYXRhIFN0cnVjdHVyZXMgKDIwMDIpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBBQEKARIDNgM4Az0DRgNRA1UDYwNqA3MDeAN7AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA4g=},
	Bdsk-Url-1 = {http://erikdemaine.org/papers/BRICS2002/}}

@book{Hennessy:Computer:2006,
	Author = {Hennessy, John L. and Patterson, David A.},
	Date-Added = {2008-04-03 13:01:59 -0400},
	Date-Modified = {2008-04-03 14:32:04 -0400},
	Edition = {Fourth},
	Month = {Sep},
	Publisher = {Morgan Kaufmann Publishers},
	Title = {Computer Architecture: A Quantitative Approach},
	Year = {2006}}

@book{Patterson:Computer:2007,
	Author = {Patterson, David A. and Hennessy, John L.},
	Date-Added = {2008-04-03 13:00:11 -0400},
	Date-Modified = {2008-04-03 14:31:55 -0400},
	Edition = {Third revised},
	Month = {June},
	Publisher = {Morgan Kaufmann Publishers},
	Title = {Computer Organization and Design: {T}he Hardware/Software Interface},
	Year = {2007}}

@book{Herken:The-Universal:1995,
	Address = {London, UK},
	Date-Added = {2008-04-03 12:53:05 -0400},
	Date-Modified = {2008-04-03 12:58:08 -0400},
	Edition = {Second},
	Editor = {Herken, Rolf},
	Month = {May},
	Publisher = {Springer-Verlag},
	Title = {The Universal Turing Machine: {A} Half-Century Survey},
	Year = {1995}}

@article{Turing:On-Computable:1937,
	Author = {Turing, Alan},
	Date-Added = {2008-04-03 12:44:01 -0400},
	Date-Modified = {2008-04-03 12:49:30 -0400},
	Journal = {Proceedings of the London Mathematical Society, Series 2},
	Pages = {230--265},
	Title = {On Computable Numbers, With an Application to the {E}ntscheidungsproblem},
	Volume = {42},
	Year = {1937}}

@book{Aho:Compilers:1986,
	Author = {Aho, Alfred V. and Sethi, Ravi and Ullman, Jeffrey D.},
	Date-Added = {2008-03-02 12:46:05 -0500},
	Date-Modified = {2008-04-14 19:03:47 -0400},
	Edition = {First},
	Isbn = {0-201-10088-6},
	Note = {Known as the ``red dragon book''},
	Publisher = {Addison-Wesley Higher Education},
	Title = {Compilers: {P}rinciples, Techniques, and Tools},
	Year = {1986}}

@book{Aho:Principles:1977,
	Address = {Reading, Mass., USA},
	Author = {Aho, Alfred V. and Ullman, Jeffrey D.},
	Date-Added = {2008-03-02 12:43:04 -0500},
	Date-Modified = {2008-04-14 19:03:54 -0400},
	Isbn = {0-201-00022-9},
	Note = {Known as the ``green dragon book''},
	Publisher = {Addison-Wesley},
	Title = {Principles of Compiler Design},
	Year = {1977}}

@inproceedings{Hovemeyer:Finding:2004,
	Address = {New York, NY, USA},
	Author = {David Hovemeyer and William Pugh},
	Booktitle = {OOPSLA '04: Companion to the 19th annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications},
	Date-Added = {2008-02-24 18:11:09 -0500},
	Date-Modified = {2008-02-24 18:14:39 -0500},
	Doi = {http://doi.acm.org/10.1145/1028664.1028717},
	Isbn = {1-58113-833-4},
	Location = {Vancouver, BC, CANADA},
	Note = {{\em See \url{http://findbugs.sourceforge.net/}.}},
	Pages = {132--136},
	Publisher = {ACM},
	Title = {Finding Bugs Is Easy},
	Url = {http://findbugs.sourceforge.net/docs/oopsla2004.pdf},
	Year = {2004},
	Abstract = {Many techniques have been developed over the years to automatically find bugs in software. Often, these techniques rely on formal methods and sophisticated program analysis. While these techniques are valuable, they can be difficult to apply, and they aren't always effective in finding real bugs.

<i>Bug patterns</i> are code idioms that are often errors. We have implemented automatic detectors for a variety of bug patterns found in Java programs. In this extended abstract<sup>1</sup>, we describe how we have used bug pattern detectors to find serious bugs in several widely used Java applications and libraries. We have found that the effort required to implement a bug pattern detector tends to be low, and that even extremely simple detectors find bugs in real applications.

From our experience applying bug pattern detectors to real programs, we have drawn several interesting conclusions. First, we have found that even well tested code written by experts contains a surprising number of obvious bugs. Second, Java (and similar languages) have many language features and APIs which are prone to misuse. Finally, that simple automatic techniques can be effective at countering the impact of both ordinary mistakes and misunderstood language features.},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1028664.1028717},
	Bdsk-Url-2 = {http://findbugs.sourceforge.net/docs/oopsla2004.pdf}}

@mastersthesis{Lattner:LLVM:2002,
	Address = {Urbana, Ill., USA},
	Author = {Chris Lattner},
	Date-Added = {2008-02-24 18:00:35 -0500},
	Date-Modified = {2008-02-24 18:02:21 -0500},
	Month = {Dec},
	Note = {{\em See \url{http://llvm.cs.uiuc.edu}.}},
	School = {{Computer Science Dept., University of Illinois at Urbana-Champaign}},
	Title = {{LLVM: An Infrastructure for Multi-Stage Optimization}},
	Year = {2002}}

@book{Zima:Supercompilers:1991,
	Address = {Reading, Mass., USA},
	Author = {Zima, Hans and Barbara Chapman},
	Date-Added = {2008-02-24 17:48:41 -0500},
	Date-Modified = {2008-02-24 17:56:48 -0500},
	Publisher = {ACM Press/Addison-Wesley},
	Title = {Supercompilers for Parallel and Vector Machines},
	Year = {1991}}

@book{Wolfe:High-Performance:1996,
	Address = {Redwood City, Calif., USA},
	Author = {Wolfe, Michael R.},
	Date-Added = {2008-02-24 17:48:37 -0500},
	Date-Modified = {2008-02-24 17:55:04 -0500},
	Publisher = {Addison-Wesley},
	Title = {High-Performance Compilers for Parallel Computing},
	Year = {1996}}

@book{Bannerjee:Loop:1994,
	Address = {Boston, Mass., USA},
	Author = {Bannerjee, Utpal},
	Date-Added = {2008-02-24 17:48:34 -0500},
	Date-Modified = {2008-02-24 17:53:30 -0500},
	Publisher = {Kluwer Academic Publishers},
	Title = {Loop Parallelization},
	Year = {1994}}

@book{Bannerjee:Loop:1993,
	Address = {Boston, Mass., USA},
	Author = {Bannerjee, Utpal},
	Date-Added = {2008-02-24 17:48:28 -0500},
	Date-Modified = {2008-02-24 17:52:50 -0500},
	Publisher = {Kluwer Academic Publishers},
	Title = {Loop Transformations for Restructuring Compilers},
	Year = {1993}}

@book{Bannerjee:Dependence:1988,
	Address = {Boston, Mass., USA},
	Author = {Bannerjee, Utpal},
	Date-Added = {2008-02-24 17:48:06 -0500},
	Date-Modified = {2008-02-24 17:52:15 -0500},
	Publisher = {Kluwer Academic Publishers},
	Title = {Dependence Analysis for Supercomputing},
	Year = {1988}}

@book{Aho:Compilers:2006,
	Author = {Aho, Alfred V. and Sethi, Ravi and Ullman, Jeffrey D. and Lam, Monica S.},
	Date-Added = {2008-02-10 14:28:34 -0500},
	Date-Modified = {2008-04-14 19:01:55 -0400},
	Edition = {Second},
	Isbn = {978-0-321-48681-1},
	Month = {August},
	Note = {Known as the ``purple dragon book''},
	Publisher = {Addison-Wesley Higher Education},
	Title = {Compilers: {P}rinciples, Techniques, and Tools},
	Year = {2006}}

@article{Wadler:Fixing:1987,
	Author = {Philip Wadler},
	Date-Added = {2007-12-13 14:15:18 -0500},
	Date-Modified = {2007-12-22 19:54:28 -0500},
	Journal = {Software Practice and Experience},
	Keywords = {space leak, garbage collection, functional languages, lazy evaluation},
	Local-Url = {file://localhost/Users/jeremy/Papers/Wadler/Wadler%20-%20Fixing%20some%20space%20leaks%20with%20(1987).pdf},
	Month = {September},
	Number = {17(9)},
	Pages = {595-608},
	Rating = {3},
	Read = {Yes},
	Title = {Fixing some space leaks with a garbage collector},
	Url = {http://www.research.avayalabs.com/user/wadler/papers/leak/leak.ps},
	Year = {1987},
	Abstract = {Some functional programs may use more space than would be expected. A modification to the garbage collector is suggested which solves this problem in some cases. Related work is discussed.},
	Annote = {Proposes having the garbage collector perform limited evaluation to eliminate a certain class of space leaks involving tuples and pattern-matched where clauses (as allowed in Miranda and Haskell). Contrasts to a more general but more obnoxious solution of forcing programmers to insert parallelism annotations.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEQuLi8uLi9QYXBlcnMvV2FkbGVyL1dhZGxlciAtIEZpeGluZyBzb21lIHNwYWNlIGxlYWtzIHdpdGggKDE5ODcpLnBkZtIbDxwdV05TLmRhdGFPEQHkAAAAAAHkAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtkXgfV2FkbGVyIC0gRml4aW5nIHNvbWUjMkM3NzdCLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACx3e8NqGCgAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABldhZGxlcgAQAAgAAME0fl0AAAARAAgAAMNqXngAAAABABAALZF4AC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpXYWRsZXI6V2FkbGVyIC0gRml4aW5nIHNvbWUjMkM3NzdCLnBkZgAADgBiADAAVwBhAGQAbABlAHIAIAAtACAARgBpAHgAaQBuAGcAIABzAG8AbQBlACAAcwBwAGEAYwBlACAAbABlAGEAawBzACAAdwBpAHQAaAAgACgAMQA5ADgANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAEtVc2Vycy9qZXJlbXkvUGFwZXJzL1dhZGxlci9XYWRsZXIgLSBGaXhpbmcgc29tZSBzcGFjZSBsZWFrcyB3aXRoICgxOTg3KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPEA9gD+AuYC6ALtAvYDAQMFAxMDGgMjAygDKwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAM4},
	Bdsk-Url-1 = {http://www.research.avayalabs.com/user/wadler/papers/leak/leak.ps}}

@book{Grune:Parsing:2007,
	Address = {London, UK},
	Author = {Grune, Dick and Jacobs, Ceriel J.\ H.},
	Date-Added = {2008-02-10 14:04:15 -0500},
	Date-Modified = {2008-04-14 19:02:31 -0400},
	Edition = {Second},
	Isbn = {978-0-387-20248-8},
	Keywords = {parsing},
	Note = {Complete first edition available online at \url{http://www.cs.vu.nl/$\sim$dick/PTAPG.html}},
	Publisher = {Springer-Verlag},
	Title = {Parsing Techniques: {A} Practical Guide},
	Year = {2007}}

@article{Parr:ANTLR:1995,
	Address = {New York, NY, USA},
	Author = {T. J. Parr and R. W. Quong},
	Date-Added = {2008-02-10 13:49:52 -0500},
	Date-Modified = {2008-02-10 14:10:28 -0500},
	Doi = {http://dx.doi.org/10.1002/spe.4380250705},
	Issn = {0038-0644},
	Journal = {Softw. Pract. Exper.},
	Keywords = {parsing},
	Note = {Current information on ANTLR is available from \url{http://www.antlr.org/}},
	Number = {7},
	Pages = {789--810},
	Publisher = {John Wiley \& Sons, Inc.},
	Title = {{ANTLR}: {A} predicated-{LL}($k$) parser generator},
	Url = {http://www.antlr.org/article/1055550346383/antlr.pdf},
	Volume = {25},
	Year = {1995},
	Abstract = {Despite the parsing power of LR/LALR algorithms, e.g. YACC, programmers often choose to write recursive-descent parsers by hand to obtain increased flexibility, better error handling, and ease of debugging. We introduce ANTLR, a public-domain parser generator that combines the flexibility of hand-coded parsing with the convenience of a parser generator, which is a component of PCCTS. ANTLR has many features that make it easier to use than other language tools. Most important, ANTLR provides predicates which let the programmer systematically direct the parse via arbitrary expressions using semantic and syntactic context; in practice, the use of predicates eliminates the need to hand-tweak the ANTLR output, even for difficult parsing problems. ANTLR also integrates the description of lexical and syntactic analysis, accepts LL(k) grammars for k > 1 with extended BNF notation, and can automatically generate abstract syntax trees.

ANTLR is widely used, with over 1000 registered industrial and academic users in 37 countries. It has been ported to many popular systems such as the PC, Macintosh, and a variety of UNIX platforms; a commercial C++ front-end has been developed as a result of one of our industrial collaborations.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFYuLi8uLi9QYXBlcnMvUGFyci9QYXJyLVF1b25nIC0gQU5UTFI6IEEgcHJlZGljYXRlZC1MTCgkayQpIHBhcnNlciBnZW5lcmF0b3IgKDE5OTUpLnBkZtIbDxwdV05TLmRhdGFPEQIaAAAAAAIaAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAwFAQfUGFyci1RdW9uZyAtIEFOVExSLyAjMzAxM0Y1LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAT9cPUslQAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABFBhcnIAEAAIAADBNH5dAAAAEQAIAADD1PikAAAAAQAQADAUBAAtkT8AA0esAABr2AACAD1PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6UGFycjpQYXJyLVF1b25nIC0gQU5UTFIvICMzMDEzRjUucGRmAAAOAIoARABQAGEAcgByAC0AUQB1AG8AbgBnACAALQAgAEEATgBUAEwAUgAvACAAQQAgAHAAcgBlAGQAaQBjAGEAdABlAGQALQBMAEwAKAAkAGsAJAApACAAcABhAHIAcwBlAHIAIABnAGUAbgBlAHIAYQB0AG8AcgAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF1Vc2Vycy9qZXJlbXkvUGFwZXJzL1BhcnIvUGFyci1RdW9uZyAtIEFOVExSOiBBIHByZWRpY2F0ZWQtTEwoJGskKSBwYXJzZXIgZ2VuZXJhdG9yICgxOTk1KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQMBCAEQAy4DMAM1Az4DSQNNA1sDYgNrA3ADcwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOA},
	Bdsk-Url-1 = {http://dx.doi.org/10.1002/spe.4380250705},
	Bdsk-Url-2 = {http://www.antlr.org/article/1055550346383/antlr.pdf}}

@manual{Pottier:Menhir:2007,
	Author = {Pottier, Fran{\c c}ois and R{\'e}gis-Gianis, Yann},
	Date-Added = {2008-02-10 13:29:59 -0500},
	Date-Modified = {2008-02-10 14:43:37 -0500},
	Keywords = {parsing},
	Month = {December},
	Organization = {INRIA},
	Title = {Menhir Reference Manual},
	Url = {http://cristal.inria.fr/~fpottier/menhir/},
	Year = {2007},
	Bdsk-Url-1 = {http://cristal.inria.fr/~fpottier/menhir/}}

@techreport{McPeak:Elkhound:2002,
	Address = {Berkeley, California, USA},
	Author = {McPeak, Scott},
	Date-Added = {2008-02-10 12:54:30 -0500},
	Date-Modified = {2008-02-10 14:43:23 -0500},
	Institution = {University of California, Berkeley},
	Keywords = {parsing},
	Month = {December},
	Number = {UCB/CSD--2--1214},
	Title = {Elkhound: {A} Fast, Practical {GLR} Parser Generator},
	Url = {http://www.cs.berkeley.edu/~smcpeak/elkhound/},
	Year = {2002},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFguLi8uLi9QYXBlcnMvTWNQZWFrL01jUGVhayAtIEVsa2hvdW5kOiBBIEZhc3QsIFByYWN0aWNhbCBHTFIgUGFyc2VyIEdlbmVyYXRvciAoMjAwMikucGRm0hsPHB1XTlMuZGF0YU8RAiAAAAAAAiAAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADAS+B9NY1BlYWsgLSBFbGtob3VuZC8gQSMyRTdGRkQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALn/9w7BQaQAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGTWNQZWFrABAACAAAwTR+XQAAABEACAAAw7CWuQAAAAEAEAAwEvgALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOk1jUGVhazpNY1BlYWsgLSBFbGtob3VuZC8gQSMyRTdGRkQucGRmAAAOAIoARABNAGMAUABlAGEAawAgAC0AIABFAGwAawBoAG8AdQBuAGQALwAgAEEAIABGAGEAcwB0ACwAIABQAHIAYQBjAHQAaQBjAGEAbAAgAEcATABSACAAUABhAHIAcwBlAHIAIABHAGUAbgBlAHIAYQB0AG8AcgAgACgAMgAwADAAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF9Vc2Vycy9qZXJlbXkvUGFwZXJzL01jUGVhay9NY1BlYWsgLSBFbGtob3VuZDogQSBGYXN0LCBQcmFjdGljYWwgR0xSIFBhcnNlciBHZW5lcmF0b3IgKDIwMDIpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBBQEKARIDNgM4Az0DRgNRA1UDYwNqA3MDeAN7AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA4g=},
	Bdsk-Url-1 = {http://www.cs.berkeley.edu/~smcpeak/elkhound/}}

@book{Muchnick:Advanced:1997,
	Author = {Muchnick, Steven S.},
	Date-Added = {2008-02-10 11:11:29 -0500},
	Date-Modified = {2008-04-14 19:03:06 -0400},
	Isbn = {978-1-55860-320-4},
	Keywords = {compilation},
	Publisher = {Academic Press},
	Title = {Advanced Compiler Design and Implementation},
	Year = {1997}}

@book{Hopcroft:Introduction:2007,
	Author = {Hopcroft, John E. and Motwani, Rajeev and Ullman, Jeffrey D.},
	Date-Added = {2008-02-08 18:53:33 -0500},
	Date-Modified = {2008-04-14 19:02:38 -0400},
	Edition = {Third},
	Isbn = {978-0-23-146225-1},
	Month = {July},
	Publisher = {Addison-Wesley Higher Education},
	Title = {Introduction to Automata Theory, Languages, and Computation},
	Url = {http://infolab.stanford.edu/~ullman/ialc.html},
	Year = {2007},
	Bdsk-Url-1 = {http://infolab.stanford.edu/~ullman/ialc.html}}

@inproceedings{Pereira:Register:2006,
	Address = {Vienna, Austria},
	Author = {Pereira, Fernando Magno Quint{\~a}o and Palsberg, Jens},
	Booktitle = {Proceedings of FOSSACS'06},
	Date-Added = {2008-02-08 16:15:40 -0500},
	Date-Modified = {2008-02-08 16:20:12 -0500},
	Keywords = {compilation},
	Month = {March},
	Pages = {79--93},
	Publisher = {Springer-Verlag (LNCS 3921)},
	Series = {Foundations of Software Science and Computation Structures},
	Title = {Register Allocation after Classical {SSA} Elimination Is {NP}-Complete},
	Url = {http://www.cs.ucla.edu/~palsberg/paper/fossacs06.pdf},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGYuLi8uLi9QYXBlcnMvUGVyZWlyYS9QZXJlaXJhLVBhbHNiZXJnIC0gUmVnaXN0ZXIgQWxsb2NhdGlvbiBhZnRlciBDbGFzc2ljYWwgU1NBIEVsaW1pbmF0aW9uICgyMDA2KS5wZGbSGw8cHVdOUy5kYXRhTxECSgAAAAACSgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAL/JjH1BlcmVpcmEtUGFsc2JlcmcgLSBSIzJGRjIzOS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv8jnD0jAuUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdQZXJlaXJhAAAQAAgAAME0fl0AAAARAAgAAMPSdn4AAAABABAAL/JjAC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpQZXJlaXJhOlBlcmVpcmEtUGFsc2JlcmcgLSBSIzJGRjIzOS5wZGYADgCkAFEAUABlAHIAZQBpAHIAYQAtAFAAYQBsAHMAYgBlAHIAZwAgAC0AIABSAGUAZwBpAHMAdABlAHIAIABBAGwAbABvAGMAYQB0AGkAbwBuACAAYQBmAHQAZQByACAAQwBsAGEAcwBzAGkAYwBhAGwAIABTAFMAQQAgAEUAbABpAG0AaQBuAGEAdABpAG8AbgAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG1Vc2Vycy9qZXJlbXkvUGFwZXJzL1BlcmVpcmEvUGVyZWlyYS1QYWxzYmVyZyAtIFJlZ2lzdGVyIEFsbG9jYXRpb24gYWZ0ZXIgQ2xhc3NpY2FsIFNTQSBFbGltaW5hdGlvbiAoMjAwNikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgETARgBIANuA3ADdQN+A4kDjQObA6IDqwOwA7MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADwA==},
	Bdsk-Url-1 = {http://www.cs.ucla.edu/~palsberg/paper/fossacs06.pdf}}

@inproceedings{Pereira:Register:2008,
	Address = {Tucson, Arizona, USA},
	Author = {Pereira, Fernando Magno Quint{\~a}o and Palsberg, Jens},
	Booktitle = {Proceedings of PLDI'08},
	Date-Added = {2008-02-08 15:24:30 -0500},
	Date-Modified = {2008-02-08 16:14:06 -0500},
	Keywords = {compilation},
	Month = {June},
	Note = {To appear},
	Series = {ACM SIGPLAN Conference on Programming Language Design and Implementation},
	Title = {Register Allocation by Puzzle Solving},
	Url = {http://www.cs.ucla.edu/~palsberg/paper/PereiraPalsberg08.pdf},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFkuLi8uLi9QYXBlcnMvUGFsc2JlcmcvUGFsc2JlcmctUGVyZWlyYSAtIFJlZ2lzdGVyIEFsbG9jYXRpb24gYnkgUHV6emxlIFNvbHZpbmcgKDIwMDgpLnBkZtIbDxwdV05TLmRhdGFPEQIiAAAAAAIiAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAv8ZofUGFsc2JlcmctUGVyZWlyYSAtIFIjMkZGMERELnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC/w3cPSJJsAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAACFBhbHNiZXJnABAACAAAwTR+XQAAABEACAAAw9Jq6wAAAAEAEAAv8ZoALZE/AANHrAAAa9gAAgBBT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlBhbHNiZXJnOlBhbHNiZXJnLVBlcmVpcmEgLSBSIzJGRjBERC5wZGYAAA4AiABDAFAAYQBsAHMAYgBlAHIAZwAtAFAAZQByAGUAaQByAGEAIAAtACAAUgBlAGcAaQBzAHQAZQByACAAQQBsAGwAbwBjAGEAdABpAG8AbgAgAGIAeQAgAFAAdQB6AHoAbABlACAAUwBvAGwAdgBpAG4AZwAgACgAMgAwADAAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGBVc2Vycy9qZXJlbXkvUGFwZXJzL1BhbHNiZXJnL1BhbHNiZXJnLVBlcmVpcmEgLSBSZWdpc3RlciBBbGxvY2F0aW9uIGJ5IFB1enpsZSBTb2x2aW5nICgyMDA4KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBBgELARMDOQM7A0ADSQNUA1gDZgNtA3YDewN+AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA4s=},
	Bdsk-Url-1 = {http://www.cs.ucla.edu/~palsberg/paper/PereiraPalsberg08.pdf}}

@inproceedings{Hines:Using:2005,
	Address = {New York, NY, USA},
	Author = {Stephen Hines and Prasad Kulkarni and David Whalley and Jack Davidson},
	Booktitle = {EMSOFT '05: Proceedings of the 5th ACM international conference on Embedded software},
	Date-Added = {2008-02-04 20:41:39 -0500},
	Date-Modified = {2008-02-04 20:45:28 -0500},
	Doi = {http://doi.acm.org/10.1145/1086228.1086251},
	Isbn = {1-59593-091-4},
	Keywords = {optimization phase ordering},
	Location = {Jersey City, NJ, USA},
	Pages = {114--123},
	Publisher = {ACM},
	Title = {Using de-optimization to re-optimize code},
	Year = {2005},
	Abstract = {The nature of embedded systems development places a great deal of importance on meeting strict requirements in areas such as static code size, power consumption, and execution time. In order to meet these requirements, embedded developers frequently generate and tune assembly code for applications by hand, despite the disadvantages of coding at a low level. The phase ordering problem is a well-known problem affecting the design of optimizing compilers. Hand-tuned code is susceptible to an analogous problem to phase ordering due to the process of iterative refinement, but there has been little research in mitigating its effect on the quality of the generated code. This paper presents an extension of the VISTA framework for investigating the effect and potential benefit of performing de-optimization before re-optimizing assembly code. The design and implementation of algorithms for de-optimization of both loop-invariant code motion and register allocation, along with results of experiments regarding de-optimization and re-optimization of previously generated assembly code are also presented.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGAuLi8uLi9QYXBlcnMvSGluZXMvSGluZXMtS3Vsa2FybmktV2hhbGxleSAtIFVzaW5nIGRlLW9wdGltaXphdGlvbiB0byByZS1vcHRpbWl6ZSBjb2RlICgyMDA1KS5wZGbSGw8cHVdOUy5kYXRhTxECOAAAAAACOAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAL9j2H0hpbmVzLUt1bGthcm5pLVdoYWxsIzJGRDhFQy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv2OzDzSjwUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVIaW5lcwAAEAAIAADBNH5dAAAAEQAIAADDzW9AAAAAAQAQAC/Y9gAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6SGluZXM6SGluZXMtS3Vsa2FybmktV2hhbGwjMkZEOEVDLnBkZgAOAJwATQBIAGkAbgBlAHMALQBLAHUAbABrAGEAcgBuAGkALQBXAGgAYQBsAGwAZQB5ACAALQAgAFUAcwBpAG4AZwAgAGQAZQAtAG8AcAB0AGkAbQBpAHoAYQB0AGkAbwBuACAAdABvACAAcgBlAC0AbwBwAHQAaQBtAGkAegBlACAAYwBvAGQAZQAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGdVc2Vycy9qZXJlbXkvUGFwZXJzL0hpbmVzL0hpbmVzLUt1bGthcm5pLVdoYWxsZXkgLSBVc2luZyBkZS1vcHRpbWl6YXRpb24gdG8gcmUtb3B0aW1pemUgY29kZSAoMjAwNSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgENARIBGgNWA1gDXQNmA3EDdQODA4oDkwOYA5sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1086228.1086251}}

@inproceedings{Edwards:No-ifs-ands:2007,
	Address = {New York, NY, USA},
	Author = {Jonathan Edwards},
	Booktitle = {OOPSLA '07: Proceedings of the 22nd annual ACM SIGPLAN conference on Object oriented programming systems and applications},
	Date-Added = {2008-01-29 22:26:53 -0500},
	Date-Modified = {2008-01-29 22:29:55 -0500},
	Doi = {http://doi.acm.org/10.1145/1297027.1297075},
	Isbn = {978-1-59593-786-5},
	Keywords = {language design},
	Location = {Montreal, Quebec, Canada},
	Pages = {639--658},
	Publisher = {ACM},
	Title = {No ifs, ands, or buts: uncovering the simplicity of conditionals},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFouLi8uLi9QYXBlcnMvRWR3YXJkcy9FZHdhcmRzIC0gTm8gaWZzLCBhbmRzLCBvciBidXRzOiB1bmNvdmVyaW5nIHRoZSBzaW1wbGljaXR5ICgyMDA3KS5wZGbSGw8cHVdOUy5kYXRhTxECJgAAAAACJgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAL7JXH0Vkd2FyZHMgLSBObyBpZnMsIGFuIzJGQjI1Ni5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvslbDxVjPUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdFZHdhcmRzAAAQAAgAAME0fl0AAAARAAgAAMPFnx8AAAABABAAL7JXAC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpFZHdhcmRzOkVkd2FyZHMgLSBObyBpZnMsIGFuIzJGQjI1Ni5wZGYADgCMAEUARQBkAHcAYQByAGQAcwAgAC0AIABOAG8AIABpAGYAcwAsACAAYQBuAGQAcwAsACAAbwByACAAYgB1AHQAcwAvACAAdQBuAGMAbwB2AGUAcgBpAG4AZwAgAHQAaABlACAAcwBpAG0AcABsAGkAYwBpAHQAeQAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGFVc2Vycy9qZXJlbXkvUGFwZXJzL0Vkd2FyZHMvRWR3YXJkcyAtIE5vIGlmcywgYW5kcywgb3IgYnV0czogdW5jb3ZlcmluZyB0aGUgc2ltcGxpY2l0eSAoMjAwNykucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEHAQwBFAM+A0ADRQNOA1kDXQNrA3IDewOAA4MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1297027.1297075}}

@article{Pippenger:Pure:1997,
	Address = {New York, NY, USA},
	Author = {Nicholas Pippenger},
	Date-Added = {2008-01-19 10:30:22 -0500},
	Date-Modified = {2008-04-21 01:38:54 -0400},
	Doi = {http://doi.acm.org/10.1145/244795.244798},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Number = {2},
	Pages = {223--238},
	Publisher = {ACM},
	Title = {Pure versus impure Lisp},
	Volume = {19},
	Year = {1997},
	Annote = {Appears from the abstract that impure Lisp is strictly more powerful (in that it can compute faster) than pure Lisp when online operation, as in an interpreter, is required. Not sure how this affects interactive programs -- probably the same difference remains. This is where the details would come in handy....},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEUuLi8uLi9QYXBlcnMvUGlwcGVuZ2VyL1BpcHBlbmdlciAtIFB1cmUgdmVyc3VzIGltcHVyZSBMaXNwICgxOTk3KS5wZGbSGw8cHVdOUy5kYXRhTxEB5gAAAAAB5gACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALuySH1BpcHBlbmdlciAtIFB1cmUgdmVyIzJFRUM4Qy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAu7IzDt4HrUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAlQaXBwZW5nZXIAABAACAAAwTR+XQAAABEACAAAw7fIOwAAAAEAEAAu7JIALZE/AANHrAAAa9gAAgBCT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlBpcHBlbmdlcjpQaXBwZW5nZXIgLSBQdXJlIHZlciMyRUVDOEMucGRmAA4AXgAuAFAAaQBwAHAAZQBuAGcAZQByACAALQAgAFAAdQByAGUAIAB2AGUAcgBzAHUAcwAgAGkAbQBwAHUAcgBlACAATABpAHMAcAAgACgAMQA5ADkANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAExVc2Vycy9qZXJlbXkvUGFwZXJzL1BpcHBlbmdlci9QaXBwZW5nZXIgLSBQdXJlIHZlcnN1cyBpbXB1cmUgTGlzcCAoMTk5NykucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPIA9wD/AukC6wLwAvkDBAMIAxYDHQMmAysDLgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAM7},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/244795.244798}}

@article{Wadler:Lazy:1996,
	Address = {New York, NY, USA},
	Author = {Philip Wadler},
	Date-Added = {2008-01-19 10:29:44 -0500},
	Date-Modified = {2008-01-19 10:29:46 -0500},
	Doi = {http://doi.acm.org/10.1145/234528.234738},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Number = {2},
	Pages = {318--320},
	Publisher = {ACM},
	Title = {Lazy versus strict},
	Volume = {28},
	Year = {1996},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEDouLi8uLi9QYXBlcnMvV2FkbGVyL1dhZGxlciAtIExhenkgdmVyc3VzIHN0cmljdCAoMTk5NikucGRm0hsPHB1XTlMuZGF0YU8RAcYAAAAAAcYAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2ReB9XYWRsZXIgLSBMYXp5IHZlcnN1cyMyRUVDODIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALuyCw7eBzVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGV2FkbGVyABAACAAAwTR+XQAAABEACAAAw7fIHQAAAAEAEAAtkXgALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOldhZGxlcjpXYWRsZXIgLSBMYXp5IHZlcnN1cyMyRUVDODIucGRmAAAOAE4AJgBXAGEAZABsAGUAcgAgAC0AIABMAGEAegB5ACAAdgBlAHIAcwB1AHMAIABzAHQAcgBpAGMAdAAgACgAMQA5ADkANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAEFVc2Vycy9qZXJlbXkvUGFwZXJzL1dhZGxlci9XYWRsZXIgLSBMYXp5IHZlcnN1cyBzdHJpY3QgKDE5OTYpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA5wDsAPQCvgLAAsUCzgLZAt0C6wLyAvsDAAMDAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAxA=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/234528.234738}}

@inproceedings{Bravenboer:Concrete:2004,
	Address = {New York, NY, USA},
	Author = {Martin Bravenboer and Eelco Visser},
	Booktitle = {OOPSLA '04: Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications},
	Date-Added = {2008-01-19 09:34:24 -0500},
	Date-Modified = {2008-01-19 09:38:17 -0500},
	Doi = {http://doi.acm.org/10.1145/1028976.1029007},
	Isbn = {1-58113-831-9},
	Keywords = {parsing},
	Location = {Vancouver, BC, Canada},
	Pages = {365--383},
	Publisher = {ACM},
	Title = {Concrete syntax for objects: domain-specific language embedding and assimilation without restrictions},
	Year = {2004},
	Abstract = {Application programmer's interfaces give access to domain knowledge encapsulated in class libraries without providing the appropriate notation for expressing domain composition. Since object-oriented languages are designed for extensibility and reuse, the language constructs are often sufficient for expressing domain abstractions at the semantic level. However, they do not provide the right abstractions at the syntactic level. In this paper we describe MetaBorg, a method for providing <i>concrete syntax</i> for domain abstractions to application programmers. The method consists of <i>embedding</i> domain-specific languages in a general purpose host language and <i>assimilating</i> the embedded domain code into the surrounding host code. Instead of extending the implementation of the host language, the assimilation phase implements domain abstractions in terms of existing APIs leaving the host language undisturbed. Indeed, MetaBorg can be considered a method for promoting APIs to the language level. The method is supported by proven and available technology, i.e. the syntax definition formalism SDF and the program transformation language and toolset Stratego/XT. We illustrate the method with applications in three domains: code generation, XML generation, and user-interface construction.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGwuLi8uLi9QYXBlcnMvQnJhdmVuYm9lci9CcmF2ZW5ib2VyLVZpc3NlciAtIENvbmNyZXRlIHN5bnRheCBmb3Igb2JqZWN0czogZG9tYWluLXNwZWNpZmljIGxhbmd1YWdlICgyMDA0KS5wZGbSGw8cHVdOUy5kYXRhTxECXAAAAAACXAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALusHH0JyYXZlbmJvZXItVmlzc2VyIC0gIzJFRUI0NC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAu60TDt3U9UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAApCcmF2ZW5ib2VyABAACAAAwTR+XQAAABEACAAAw7e7jQAAAAEAEAAu6wcALZE/AANHrAAAa9gAAgBDT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkJyYXZlbmJvZXI6QnJhdmVuYm9lci1WaXNzZXIgLSAjMkVFQjQ0LnBkZgAADgCqAFQAQgByAGEAdgBlAG4AYgBvAGUAcgAtAFYAaQBzAHMAZQByACAALQAgAEMAbwBuAGMAcgBlAHQAZQAgAHMAeQBuAHQAYQB4ACAAZgBvAHIAIABvAGIAagBlAGMAdABzAC8AIABkAG8AbQBhAGkAbgAtAHMAcABlAGMAaQBmAGkAYwAgAGwAYQBuAGcAdQBhAGcAZQAgACgAMgAwADAANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHNVc2Vycy9qZXJlbXkvUGFwZXJzL0JyYXZlbmJvZXIvQnJhdmVuYm9lci1WaXNzZXIgLSBDb25jcmV0ZSBzeW50YXggZm9yIG9iamVjdHM6IGRvbWFpbi1zcGVjaWZpYyBsYW5ndWFnZSAoMjAwNCkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEZAR4BJgOGA4gDjQOWA6EDpQOzA7oDwwPIA8sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAD2A==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1028976.1029007}}

@inproceedings{Bravenboer:Preventing:2007,
	Address = {New York, NY, USA},
	Author = {Martin Bravenboer and Eelco Dolstra and Eelco Visser},
	Booktitle = {GPCE '07: Proceedings of the 6th international conference on Generative programming and component engineering},
	Date-Added = {2008-01-19 09:34:02 -0500},
	Date-Modified = {2008-01-19 09:38:17 -0500},
	Doi = {http://doi.acm.org/10.1145/1289971.1289975},
	Isbn = {978-1-59593-855-8},
	Keywords = {parsing},
	Location = {Salzburg, Austria},
	Pages = {3--12},
	Publisher = {ACM},
	Title = {Preventing injection attacks with syntax embeddings},
	Year = {2007},
	Abstract = {Software written in one language often needs to construct sentences in another language, such as SQL queries, XML output, or shell command invocations. This is almost always done using unhygienic string manipulation, the concatenation of constants and client-supplied strings. A client can then supply specially crafted input that causes the constructed sentence to be interpreted in an unintended way, leading to an injection attack. We describe a more natural style of programming that yields code that is impervious to injections by construction. Our approach embeds the grammars of the guest languages (e.g., SQL) into that of the host language (e.g., Java) and automatically generates code that maps the embedded language to constructs in the host language that reconstruct the embedded sentences, adding escaping functions where appropriate. This approach is generic, meaning that it can be applied with relative ease to any combination of host and guest languages.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGcuLi8uLi9QYXBlcnMvQnJhdmVuYm9lci9CcmF2ZW5ib2VyLURvbHN0cmEtVmlzc2VyIC0gUHJldmVudGluZyBpbmplY3Rpb24gYXR0YWNrcyB3aXRoIHN5bnRheCAoMjAwNykucGRm0hsPHB1XTlMuZGF0YU8RAkwAAAAAAkwAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC7rBx9CcmF2ZW5ib2VyLURvbHN0cmEtViMyRUVCM0QucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALus9w7d07FBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAKQnJhdmVuYm9lcgAQAAgAAME0fl0AAAARAAgAAMO3uzwAAAABABAALusHAC2RPwADR6wAAGvYAAIAQ09kaW46VXNlcnM6amVyZW15OlBhcGVyczpCcmF2ZW5ib2VyOkJyYXZlbmJvZXItRG9sc3RyYS1WIzJFRUIzRC5wZGYAAA4AoABPAEIAcgBhAHYAZQBuAGIAbwBlAHIALQBEAG8AbABzAHQAcgBhAC0AVgBpAHMAcwBlAHIAIAAtACAAUAByAGUAdgBlAG4AdABpAG4AZwAgAGkAbgBqAGUAYwB0AGkAbwBuACAAYQB0AHQAYQBjAGsAcwAgAHcAaQB0AGgAIABzAHkAbgB0AGEAeAAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG5Vc2Vycy9qZXJlbXkvUGFwZXJzL0JyYXZlbmJvZXIvQnJhdmVuYm9lci1Eb2xzdHJhLVZpc3NlciAtIFByZXZlbnRpbmcgaW5qZWN0aW9uIGF0dGFja3Mgd2l0aCBzeW50YXggKDIwMDcpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEUARkBIQNxA3MDeAOBA4wDkAOeA6UDrgOzA7YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADww==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1289971.1289975}}

@techreport{Bravenboer:Program:2005,
	Address = {Utrecht},
	Author = {Martin Bravenboer and Arthur van Dam and Karina Olmos and Eelco Visser},
	Date-Added = {2008-01-19 09:28:07 -0500},
	Date-Modified = {2008-01-19 13:23:20 -0500},
	Institution = {Utrecht University},
	Keywords = {parsing},
	Month = {June},
	Number = {UU-CS-2005-05},
	Title = {Program Transformation with Scoped Dynamic Rewrite Rules},
	Year = {2005},
	Annote = {Published as Bravenboer:Program:2006.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGQuLi8uLi9QYXBlcnMvQnJhdmVuYm9lci9CcmF2ZW5ib2VyLURhbS1PbG1vcyAtIFByb2dyYW0gVHJhbnNmb3JtYXRpb24gd2l0aCBTY29wZWQgRHluYW1pYyAoMjAwNSkucGRm0hsPHB1XTlMuZGF0YU8RAkQAAAAAAkQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC7rBx9CcmF2ZW5ib2VyLURhbS1PbG1vcyMyRUVBRkUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALur+w7dzH1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAKQnJhdmVuYm9lcgAQAAgAAME0fl0AAAARAAgAAMO3uW8AAAABABAALusHAC2RPwADR6wAAGvYAAIAQ09kaW46VXNlcnM6amVyZW15OlBhcGVyczpCcmF2ZW5ib2VyOkJyYXZlbmJvZXItRGFtLU9sbW9zIzJFRUFGRS5wZGYAAA4AmgBMAEIAcgBhAHYAZQBuAGIAbwBlAHIALQBEAGEAbQAtAE8AbABtAG8AcwAgAC0AIABQAHIAbwBnAHIAYQBtACAAVAByAGEAbgBzAGYAbwByAG0AYQB0AGkAbwBuACAAdwBpAHQAaAAgAFMAYwBvAHAAZQBkACAARAB5AG4AYQBtAGkAYwAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGtVc2Vycy9qZXJlbXkvUGFwZXJzL0JyYXZlbmJvZXIvQnJhdmVuYm9lci1EYW0tT2xtb3MgLSBQcm9ncmFtIFRyYW5zZm9ybWF0aW9uIHdpdGggU2NvcGVkIER5bmFtaWMgKDIwMDUpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBEQEWAR4DZgNoA20DdgOBA4UDkwOaA6MDqAOrAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA7g=}}

@inproceedings{Bravenboer:Declarative:2006,
	Address = {New York, NY, USA},
	Author = {Martin Bravenboer and \'{E}ric Tanter and Eelco Visser},
	Booktitle = {OOPSLA '06: Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications},
	Date-Added = {2008-01-19 09:25:07 -0500},
	Date-Modified = {2008-01-19 09:38:17 -0500},
	Doi = {http://doi.acm.org/10.1145/1167473.1167491},
	Isbn = {1-59593-348-4},
	Keywords = {parsing},
	Location = {Portland, Oregon, USA},
	Pages = {209--228},
	Publisher = {ACM},
	Title = {Declarative, formal, and extensible syntax definition for aspect{J}},
	Year = {2006},
	Abstract = {Aspect-Oriented Programming (AOP) is attracting attention from both research and industry, as illustrated by the ever-growing popularity of AspectJ, the de facto standard AOP extension of Java. From a compiler construction perspective AspectJ is interesting as it is a typical example of compositional language, ie a language composed of a number of separate languages with different syntactical styles: in addition to plain Java, AspectJ includes a language for defining pointcuts and one for defining advices. Language composition represents a non-trivial challenge for conventional parsing techniques. First, combining several languages with different lexical syntax leads to considerable complexity in the lexical states to processed. Second, as new language features for AOP are being explored, many research proposals are concerned with further extending the AspectJ language, resulting in a need for an extensible syntax definition.This paper shows how scannerless parsing elegantly addresses the issues encountered by conventional techniques when parsing AspectJ . We present the design of a modular, extensible, and formal definition of the lexical and context-free aspects of the AspectJ syntax in the Syntax Definition Formalism SDF, which is implemented by a scannerless, generalized-LR parser (SGLR). We introduce grammar mixins as a novel application of SDF's modularity features, which allows the declarative definition of different keyword policies and combination of extensions. We illustrate the modular extensibility of our definition with syntax extensions taken from current research on aspect languages. Finally, benchmarks show the reasonable performance of scannerless generalized-LR parsing for this grammar.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHMuLi8uLi9QYXBlcnMvQnJhdmVuYm9lci9CcmF2ZW5ib2VyLVRhbnRlci1WaXNzZXIgLSBEZWNsYXJhdGl2ZSwgZm9ybWFsLCBhbmQgZXh0ZW5zaWJsZSBzeW50YXggZGVmaW5pdGlvbiAoMjAwNikucGRm0hsPHB1XTlMuZGF0YU8RAnAAAAAAAnAAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC7rBx9CcmF2ZW5ib2VyLVRhbnRlci1WaSMyRUVCMkEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALusqw7d0slBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAKQnJhdmVuYm9lcgAQAAgAAME0fl0AAAARAAgAAMO3uwIAAAABABAALusHAC2RPwADR6wAAGvYAAIAQ09kaW46VXNlcnM6amVyZW15OlBhcGVyczpCcmF2ZW5ib2VyOkJyYXZlbmJvZXItVGFudGVyLVZpIzJFRUIyQS5wZGYAAA4AuABbAEIAcgBhAHYAZQBuAGIAbwBlAHIALQBUAGEAbgB0AGUAcgAtAFYAaQBzAHMAZQByACAALQAgAEQAZQBjAGwAYQByAGEAdABpAHYAZQAsACAAZgBvAHIAbQBhAGwALAAgAGEAbgBkACAAZQB4AHQAZQBuAHMAaQBiAGwAZQAgAHMAeQBuAHQAYQB4ACAAZABlAGYAaQBuAGkAdABpAG8AbgAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHpVc2Vycy9qZXJlbXkvUGFwZXJzL0JyYXZlbmJvZXIvQnJhdmVuYm9lci1UYW50ZXItVmlzc2VyIC0gRGVjbGFyYXRpdmUsIGZvcm1hbCwgYW5kIGV4dGVuc2libGUgc3ludGF4IGRlZmluaXRpb24gKDIwMDYpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEgASUBLQOhA6MDqAOxA7wDwAPOA9UD3gPjA+YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAD8w==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1167473.1167491}}

@article{Bravenboer:Program:2006,
	Address = {Amsterdam, The Netherlands, The Netherlands},
	Author = {Martin Bravenboer and Arthur van Dam and Karina Olmos and Eelco Visser},
	Date-Added = {2008-01-19 09:22:05 -0500},
	Date-Modified = {2008-01-19 09:38:17 -0500},
	Issn = {0169-2968},
	Journal = {Fundam. Inf.},
	Keywords = {parsing},
	Number = {1-2},
	Pages = {123--178},
	Publisher = {IOS Press},
	Title = {Program Transformation with Scoped Dynamic Rewrite Rules},
	Volume = {69},
	Year = {2006}}

@techreport{Visser:Scannerless:1997,
	Address = {Amsterdam},
	Author = {Eelco Visser},
	Date-Added = {2008-01-19 09:16:04 -0500},
	Date-Modified = {2008-01-19 09:18:59 -0500},
	Institution = {University of Amsterdam},
	Keywords = {parsing},
	Month = {July},
	Number = {P9707},
	Title = {Scannerless Generalized-LR Parsing},
	Year = {1997},
	Abstract = {Current deterministic parsing techniques have a number of problems. These include the limitations of parser generators for deterministic languages and the complex interface between scanner and parser. Scannerless parsing is a parsing technique in which lexical and context-free syntax are integrated into one grammar and are all handled by a single context-free analysis phase. This approach has a number of advantages including discarding of the scanner and lexical disambiguation by means of the context in which a lexical token occurs. Scannerless parsing generates a number of interesting problems as well. Integrated grammars do not fit the requirements of the conventional deterministic parsing techniques. A plain context-free grammar formalism leads to unwieldy grammars, if all lexical information is included. Lexical disambiguation needs to be reformulated for use in context-free parsing.

The scannerless generalized-LR parsing approach presented in this paper solves these problems. Grammar normalization is used to support an expressive grammar formalism without complicating the underlying machinery. Follow restrictions are used to express longest match lexical disambiguation. Reject productions are used to express the prefer keywords rule for lexical disambiguation. The SLR(1) parser generation algorithm is adapted to implement disambiguation by general priority and associativity declarations and to interpret follow restrictions. Generalized-LR parsing is used to provide dynamic lookahead and to support parsing of arbitrary context-free grammars including ambiguous ones. An adaptation of the GLR algorithm supports the interpretation of grammars with reject productions. },
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEouLi8uLi9QYXBlcnMvVmlzc2VyL1Zpc3NlciAtIFNjYW5uZXJsZXNzIEdlbmVyYWxpemVkLUxSIFBhcnNpbmcgKDE5OTcpLnBkZtIbDxwdV05TLmRhdGFPEQH2AAAAAAH2AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAu6sgfVmlzc2VyIC0gU2Nhbm5lcmxlc3MjMkVFQUMxLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC7qwcO3cNIAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABlZpc3NlcgAQAAgAAME0fl0AAAARAAgAAMO3tyIAAAABABAALurIAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpWaXNzZXI6Vmlzc2VyIC0gU2Nhbm5lcmxlc3MjMkVFQUMxLnBkZgAADgBuADYAVgBpAHMAcwBlAHIAIAAtACAAUwBjAGEAbgBuAGUAcgBsAGUAcwBzACAARwBlAG4AZQByAGEAbABpAHoAZQBkAC0ATABSACAAUABhAHIAcwBpAG4AZwAgACgAMQA5ADkANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFFVc2Vycy9qZXJlbXkvUGFwZXJzL1Zpc3Nlci9WaXNzZXIgLSBTY2FubmVybGVzcyBHZW5lcmFsaXplZC1MUiBQYXJzaW5nICgxOTk3KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPcA/AEEAv4DAAMFAw4DGQMdAysDMgM7A0ADQwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANQ}}

@article{Brand:Generation:1996,
	Address = {New York, NY, USA},
	Author = {van den Brand, Mark and Eelco Visser},
	Date-Added = {2008-01-19 09:12:26 -0500},
	Date-Modified = {2008-01-19 09:23:02 -0500},
	Doi = {http://doi.acm.org/10.1145/226155.226156},
	Issn = {1049-331X},
	Journal = {ACM Trans. Softw. Eng. Methodol.},
	Keywords = {parsing},
	Number = {1},
	Pages = {1--41},
	Publisher = {ACM},
	Title = {Generation of formatters for context-free languages},
	Volume = {5},
	Year = {1996},
	Abstract = {Good documentation is important for the production of reusable and maintainable software. For the production of accurate documentation it is necessary that the original program text is not copied manually to obtain a typeset version. Apart from being tedious, this will invariably introduce errors. The production of tools that support the production of legible and accurate documentation is a software engineering challenge in itself. We present an algebraic approach to the generation of tools that produce typographically effective presentations of computer programs. A specification of a formatter is generated from the context-free grammar of a (programming) language. These generated formatters translate abstract syntax trees of programs into box expressions. Box expressions are translated by language-independent interpreters of the box language into ASCII or TEX. The formatting rules that are generated can easily be tuned in order to get the desired formatting of programs. We demonstrate this by means of real-life applications. Furthermore, we give a practical solution for the problem of formatting comments, which occur in the original text. The formatter generation approach proposed in this article can be used to generate formatting programs for arbitrary programming environments. Our formatter generation approach can be used to automatically generate formatters that have to be programmed explicitly in other systems.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGAuLi8uLi9QYXBlcnMvQnJhbmQvQnJhbmQtVmlzc2VyIC0gR2VuZXJhdGlvbiBvZiBmb3JtYXR0ZXJzIGZvciBjb250ZXh0LWZyZWUgbGFuZ3VhZ2VzICgxOTk2KS5wZGbSGw8cHVdOUy5kYXRhTxECOAAAAAACOAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALupwH0JyYW5kLVZpc3NlciAtIEdlbmVyIzJFRUFEOS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAu6tnDt3HQUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVCcmFuZAAAEAAIAADBNH5dAAAAEQAIAADDt7ggAAAAAQAQAC7qcAAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QnJhbmQ6QnJhbmQtVmlzc2VyIC0gR2VuZXIjMkVFQUQ5LnBkZgAOAJwATQBCAHIAYQBuAGQALQBWAGkAcwBzAGUAcgAgAC0AIABHAGUAbgBlAHIAYQB0AGkAbwBuACAAbwBmACAAZgBvAHIAbQBhAHQAdABlAHIAcwAgAGYAbwByACAAYwBvAG4AdABlAHgAdAAtAGYAcgBlAGUAIABsAGEAbgBnAHUAYQBnAGUAcwAgACgAMQA5ADkANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGdVc2Vycy9qZXJlbXkvUGFwZXJzL0JyYW5kL0JyYW5kLVZpc3NlciAtIEdlbmVyYXRpb24gb2YgZm9ybWF0dGVycyBmb3IgY29udGV4dC1mcmVlIGxhbmd1YWdlcyAoMTk5NikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgENARIBGgNWA1gDXQNmA3EDdQODA4oDkwOYA5sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/226155.226156}}

@inproceedings{Brand:Disambiguation:2002,
	Address = {London, UK},
	Author = {Mark G. J. van den Brand and Jeroen Scheerder and Jurgen J. Vinju and Eelco Visser},
	Booktitle = {CC '02: Proceedings of the 11th International Conference on Compiler Construction},
	Date-Added = {2008-01-19 09:08:40 -0500},
	Date-Modified = {2008-01-19 09:10:25 -0500},
	Isbn = {3-540-43369-4},
	Keywords = {parsing},
	Pages = {143--158},
	Publisher = {Springer-Verlag},
	Title = {Disambiguation Filters for Scannerless Generalized LR Parsers},
	Year = {2002},
	Abstract = {In this paper we present the fusion of generalized LR parsing and scannerless parsing. This combination supports syntax definitions in which all aspects (lexical and context-free) of the syntax of a language are defined explicitly in one formalism. Furthermore, there are no restrictions on the class of grammars, thus allowing a natural syntax tree structure. Ambiguities that arise through the use of unrestricted grammars are handled by explicit disambiguation constructs, instead of implicit defaults that are taken by traditional scanner and parser generators. Hence, a syntax definition becomes a full declarative description of a language. Scannerless generalized LR parsing is a viable technique that has been applied in various industrial and academic projects.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHMuLi8uLi9QYXBlcnMvQnJhbmQvQnJhbmQtU2NoZWVyZGVyLVZpbmp1IC0gRGlzYW1iaWd1YXRpb24gRmlsdGVycyBmb3IgU2Nhbm5lcmxlc3MgR2VuZXJhbGl6ZWQgTFIgUGFyc2VycyAoMjAwMikucGRm0hsPHB1XTlMuZGF0YU8RAnAAAAAAAnAAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC7qcB9CcmFuZC1TY2hlZXJkZXItVmluaiMyRUVBNkEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALupqw7dv11BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAFQnJhbmQAABAACAAAwTR+XQAAABEACAAAw7e2JwAAAAEAEAAu6nAALZE/AANHrAAAa9gAAgA+T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkJyYW5kOkJyYW5kLVNjaGVlcmRlci1WaW5qIzJFRUE2QS5wZGYADgDCAGAAQgByAGEAbgBkAC0AUwBjAGgAZQBlAHIAZABlAHIALQBWAGkAbgBqAHUAIAAtACAARABpAHMAYQBtAGIAaQBnAHUAYQB0AGkAbwBuACAARgBpAGwAdABlAHIAcwAgAGYAbwByACAAUwBjAGEAbgBuAGUAcgBsAGUAcwBzACAARwBlAG4AZQByAGEAbABpAHoAZQBkACAATABSACAAUABhAHIAcwBlAHIAcwAgACgAMgAwADAAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHpVc2Vycy9qZXJlbXkvUGFwZXJzL0JyYW5kL0JyYW5kLVNjaGVlcmRlci1WaW5qdSAtIERpc2FtYmlndWF0aW9uIEZpbHRlcnMgZm9yIFNjYW5uZXJsZXNzIEdlbmVyYWxpemVkIExSIFBhcnNlcnMgKDIwMDIpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEgASUBLQOhA6MDqAOxA7wDwAPOA9UD3gPjA+YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAD8w==}}

@inproceedings{Soisalon-Soininen:Elimination:1977,
	Address = {New York, NY, USA},
	Author = {Eljas Soisalon-Soininen},
	Booktitle = {POPL '77: Proceedings of the 4th ACM SIGACT-SIGPLAN symposium on Principles of programming languages},
	Date-Added = {2008-01-17 22:28:17 -0500},
	Date-Modified = {2008-01-17 22:29:10 -0500},
	Doi = {http://doi.acm.org/10.1145/512950.512967},
	Location = {Los Angeles, California},
	Pages = {183--193},
	Publisher = {ACM},
	Title = {Elimination of single productions from LR parsers in conjunction with the use of default reductions},
	Year = {1977},
	Abstract = {The problem in the use of default reductions in conjunction with the elimination of reductions by single productions is discussed in Pager[1973a] and a method is given there to solve the problem. The basis of the solution is to apply first the algorithm for eliminating reductions by single productions and then to check every potential default reduction in order to decide whether it can be used or not. Hence, in the optimized parser all reductions by single productions are eliminated, but the use of default reductions can be limited. (Pager [1973a] has found that in the case of some practical grammars almost all of potential default reductions can be used.)

In the present paper we consider another approach to the problem. In our method the elimination process itself corresponds to the technique of Pager[1973a,1974], but the elimination is carried out only if it does not affect the applicability of default reductions. The main motivation of this approach is the fact that it leads to a method for eliminating reductions by single productions which is applicable for any type of LR parser, including LALR parsers and generalizations of them.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEG8uLi8uLi9QYXBlcnMvU29pc2Fsb24tU29pbmluZW4vU29pc2Fsb24tU29pbmluZW4gLSBFbGltaW5hdGlvbiBvZiBzaW5nbGUgcHJvZHVjdGlvbnMgZnJvbSBMUiBwYXJzZXJzICgxOTc3KS5wZGbSGw8cHVdOUy5kYXRhTxECZAAAAAACZAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALuIZH1NvaXNhbG9uLVNvaW5pbmVuIC0gIzJFRTIxOC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAu4hjDtYiaUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAABFTb2lzYWxvbi1Tb2luaW5lbgAAEAAIAADBNH5dAAAAEQAIAADDtc7qAAAAAQAQAC7iGQAtkT8AA0esAABr2AACAEpPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6U29pc2Fsb24tU29pbmluZW46U29pc2Fsb24tU29pbmluZW4gLSAjMkVFMjE4LnBkZgAOAKIAUABTAG8AaQBzAGEAbABvAG4ALQBTAG8AaQBuAGkAbgBlAG4AIAAtACAARQBsAGkAbQBpAG4AYQB0AGkAbwBuACAAbwBmACAAcwBpAG4AZwBsAGUAIABwAHIAbwBkAHUAYwB0AGkAbwBuAHMAIABmAHIAbwBtACAATABSACAAcABhAHIAcwBlAHIAcwAgACgAMQA5ADcANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHZVc2Vycy9qZXJlbXkvUGFwZXJzL1NvaXNhbG9uLVNvaW5pbmVuL1NvaXNhbG9uLVNvaW5pbmVuIC0gRWxpbWluYXRpb24gb2Ygc2luZ2xlIHByb2R1Y3Rpb25zIGZyb20gTFIgcGFyc2VycyAoMTk3NykucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARwBIQEpA5EDkwOYA6EDrAOwA74DxQPOA9MD1gAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAPj},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/512950.512967}}

@article{Aycock:Even:2001,
	Address = {Secaucus, NJ, USA},
	Author = {John Aycock and Nigel Horspool and Jan Janou\v{s}ek and Bo\v{r}ivoj Melichar},
	Date-Added = {2008-01-17 22:17:11 -0500},
	Date-Modified = {2008-01-17 22:19:40 -0500},
	Doi = {http://dx.doi.org/10.1007/PL00013319},
	Issn = {0001-5903},
	Journal = {Acta Inf.},
	Keywords = {parsing},
	Number = {9},
	Pages = {633--651},
	Publisher = {Springer-Verlag New York, Inc.},
	Title = {Even faster generalized LR parsing},
	Volume = {37},
	Year = {2001},
	Abstract = {We prove a property of generalized LR (GLR) parsing -- if the grammar is without right and hidden left recursions, then the number of consecutive reductions between the shifts of two adjacent symbols cannot be greater than a constant. Further, we show that this property can be used for constructing an optimized version of our GLR parser. Compared with a standard GLR parser, our optimized parser reads one symbol on every transition and performs significantly fewer stack operations. Our timings show that, especially for highly ambiguous grammars, our parser is significantly faster than a standard GLR parser.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFwuLi8uLi9QYXBlcnMvQXljb2NrL0F5Y29jay1Ib3JzcG9vbC1KYW5vdXNlayAtIEV2ZW4gZmFzdGVyIGdlbmVyYWxpemVkIExSIHBhcnNpbmcgKDIwMDEpLnBkZtIbDxwdV05TLmRhdGFPEQIsAAAAAAIsAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAugkAfQXljb2NrLUhvcnNwb29sLUphbm8jMkVFMTk1LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC7hlcO1hHhQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABkF5Y29jawAQAAgAAME0fl0AAAARAAgAAMO1ysgAAAABABAALoJAAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpBeWNvY2s6QXljb2NrLUhvcnNwb29sLUphbm8jMkVFMTk1LnBkZgAADgCSAEgAQQB5AGMAbwBjAGsALQBIAG8AcgBzAHAAbwBvAGwALQBKAGEAbgBvAHUAcwBlAGsAIAAtACAARQB2AGUAbgAgAGYAYQBzAHQAZQByACAAZwBlAG4AZQByAGEAbABpAHoAZQBkACAATABSACAAcABhAHIAcwBpAG4AZwAgACgAMgAwADAAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGNVc2Vycy9qZXJlbXkvUGFwZXJzL0F5Y29jay9BeWNvY2stSG9yc3Bvb2wtSmFub3VzZWsgLSBFdmVuIGZhc3RlciBnZW5lcmFsaXplZCBMUiBwYXJzaW5nICgyMDAxKS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQkBDgEWA0YDSANNA1YDYQNlA3MDegODA4gDiwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOY},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/PL00013319}}

@article{Horspool:Even:1990,
	Address = {New York, NY, USA},
	Author = {R. N. Horspool and M. Whitney},
	Date-Added = {2008-01-17 22:12:22 -0500},
	Date-Modified = {2008-01-17 22:13:09 -0500},
	Doi = {http://dx.doi.org/10.1002/spe.4380200602},
	Issn = {0038-0644},
	Journal = {Softw. Pract. Exper.},
	Keywords = {parsing},
	Number = {6},
	Pages = {515--535},
	Publisher = {John Wiley \& Sons, Inc.},
	Title = {Even faster LR parsing},
	Volume = {20},
	Year = {1990},
	Abstract = {Conventional LR parser generators create tables which are used to drive a standard parser procedure. Much faster parsers can be obtained by compiling the table entries into code that is directly executed. A possible drawback with a directly executable parser is its large size. In this paper, we introduce optimization techniques that increase the parsing speed even further while simultaneously reducing the size of the parser.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEouLi8uLi9QYXBlcnMvSG9yc3Bvb2wvSG9yc3Bvb2wtV2hpdG5leSAtIEV2ZW4gZmFzdGVyIExSIHBhcnNpbmcgKDE5OTApLnBkZtIbDxwdV05TLmRhdGFPEQH2AAAAAAH2AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAu4W8fSG9yc3Bvb2wtV2hpdG5leSAtIEUjMkVFMEI1LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC7gtcO1gBFQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAACEhvcnNwb29sABAACAAAwTR+XQAAABEACAAAw7XGYQAAAAEAEAAu4W8ALZE/AANHrAAAa9gAAgBBT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkhvcnNwb29sOkhvcnNwb29sLVdoaXRuZXkgLSBFIzJFRTBCNS5wZGYAAA4AagA0AEgAbwByAHMAcABvAG8AbAAtAFcAaABpAHQAbgBlAHkAIAAtACAARQB2AGUAbgAgAGYAYQBzAHQAZQByACAATABSACAAcABhAHIAcwBpAG4AZwAgACgAMQA5ADkAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFFVc2Vycy9qZXJlbXkvUGFwZXJzL0hvcnNwb29sL0hvcnNwb29sLVdoaXRuZXkgLSBFdmVuIGZhc3RlciBMUiBwYXJzaW5nICgxOTkwKS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPcA/AEEAv4DAAMFAw4DGQMdAysDMgM7A0ADQwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANQ},
	Bdsk-Url-1 = {http://dx.doi.org/10.1002/spe.4380200602}}

@article{Bhamidipaty:Very:1998,
	Address = {New York, NY, USA},
	Author = {Achyutram Bhamidipaty and Todd A. Proebsting},
	Date-Added = {2008-01-17 22:10:11 -0500},
	Date-Modified = {2008-01-17 22:13:47 -0500},
	Doi = {http://dx.doi.org/10.1002/(SICI)1097-024X(199802)28:2<181::AID-SPE139>3.3.CO;2-W},
	Issn = {0038-0644},
	Journal = {Softw. Pract. Exper.},
	Keywords = {parsing},
	Number = {2},
	Pages = {181--190},
	Publisher = {John Wiley \& Sons, Inc.},
	Title = {Very fast YACC-compatible parsers (for very little effort)},
	Volume = {28},
	Year = {1998},
	Abstract = {We have developed a yacc-compatible parser generator that creates parsers that are 2.0 to 6.0 times faster than those generated by yacc or bison. Our tool, mule, creates directly-executable, hard-coded parsers in ANSI; yacc produces interpreted, table-driven parsers. Two attributes distinguish mule from other parser generators that create hard-coded LR parsers; mule is compatible wtih yacc (including yacc's peculiar error recovery mechanisms), and mule does absolutely none of the complex automata analysis of previous hard-coded-parser generators. Mule creates simple, fast parsers after very little analysis.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGMuLi8uLi9QYXBlcnMvQmhhbWlkaXBhdHkvQmhhbWlkaXBhdHktUHJvZWJzdGluZyAtIFZlcnkgZmFzdCBZQUNDLWNvbXBhdGlibGUgcGFyc2VycyAoZm9yICgxOTk4KS5wZGbSGw8cHVdOUy5kYXRhTxECQAAAAAACQAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALuEWH0JoYW1pZGlwYXR5LVByb2Vic3RpIzJFRTBGQy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAu4PzDtYH0UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAtCaGFtaWRpcGF0eQAAEAAIAADBNH5dAAAAEQAIAADDtchEAAAAAQAQAC7hFgAtkT8AA0esAABr2AACAERPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QmhhbWlkaXBhdHk6QmhhbWlkaXBhdHktUHJvZWJzdGkjMkVFMEZDLnBkZgAOAJYASgBCAGgAYQBtAGkAZABpAHAAYQB0AHkALQBQAHIAbwBlAGIAcwB0AGkAbgBnACAALQAgAFYAZQByAHkAIABmAGEAcwB0ACAAWQBBAEMAQwAtAGMAbwBtAHAAYQB0AGkAYgBsAGUAIABwAGEAcgBzAGUAcgBzACAAKABmAG8AcgAgACgAMQA5ADkAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGpVc2Vycy9qZXJlbXkvUGFwZXJzL0JoYW1pZGlwYXR5L0JoYW1pZGlwYXR5LVByb2Vic3RpbmcgLSBWZXJ5IGZhc3QgWUFDQy1jb21wYXRpYmxlIHBhcnNlcnMgKGZvciAoMTk5OCkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARABFQEdA2EDYwNoA3EDfAOAA44DlQOeA6MDpgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOz},
	Bdsk-Url-1 = {http://dx.doi.org/10.1002/(SICI)1097-024X(199802)28:2%3C181::AID-SPE139%3E3.3.CO;2-W}}

@article{DeRemer:Efficient:1982,
	Address = {New York, NY, USA},
	Author = {Frank DeRemer and Thomas Pennello},
	Date-Added = {2008-01-17 21:50:13 -0500},
	Date-Modified = {2008-01-17 22:14:07 -0500},
	Doi = {http://doi.acm.org/10.1145/69622.357187},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Keywords = {parsing},
	Number = {4},
	Pages = {615--649},
	Publisher = {ACM},
	Title = {Efficient Computation of LALR(1) Look-Ahead Sets},
	Volume = {4},
	Year = {1982},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGMuLi8uLi9QYXBlcnMvRGVSZW1lci9EZVJlbWVyLVBlbm5lbGxvIC0gRWZmaWNpZW50IENvbXB1dGF0aW9uIG9mIExBTFIoMSkgTG9vay1BaGVhZCBTZXRzICgxOTgyKS5wZGbSGw8cHVdOUy5kYXRhTxECQAAAAAACQAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALuB1H0RlUmVtZXItUGVubmVsbG8gLSBFIzJFRTAyMS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAu4CHDtX5mUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdEZVJlbWVyAAAQAAgAAME0fl0AAAARAAgAAMO1xLYAAAABABAALuB1AC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpEZVJlbWVyOkRlUmVtZXItUGVubmVsbG8gLSBFIzJFRTAyMS5wZGYADgCeAE4ARABlAFIAZQBtAGUAcgAtAFAAZQBuAG4AZQBsAGwAbwAgAC0AIABFAGYAZgBpAGMAaQBlAG4AdAAgAEMAbwBtAHAAdQB0AGEAdABpAG8AbgAgAG8AZgAgAEwAQQBMAFIAKAAxACkAIABMAG8AbwBrAC0AQQBoAGUAYQBkACAAUwBlAHQAcwAgACgAMQA5ADgAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGpVc2Vycy9qZXJlbXkvUGFwZXJzL0RlUmVtZXIvRGVSZW1lci1QZW5uZWxsbyAtIEVmZmljaWVudCBDb21wdXRhdGlvbiBvZiBMQUxSKDEpIExvb2stQWhlYWQgU2V0cyAoMTk4MikucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARABFQEdA2EDYwNoA3EDfAOAA44DlQOeA6MDpgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOz},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/69622.357187}}

@inproceedings{Tan:iComment:2007,
	Address = {New York, NY, USA},
	Author = {Lin Tan and Ding Yuan and Gopal Krishna and Yuanyuan Zhou},
	Booktitle = {SOSP '07: Proceedings of twenty-first ACM SIGOPS symposium on Operating systems principles},
	Date-Added = {2008-01-14 01:46:49 -0500},
	Date-Modified = {2008-01-14 01:50:26 -0500},
	Doi = {http://doi.acm.org/10.1145/1294261.1294276},
	Isbn = {978-1-59593-591-5},
	Local-Url = {file://localhost/Users/jeremy/Papers/Tan/Tan-Yuan-Krishna%20-%20-*i%7BC%7Domment%20Bugs%20or%20Bad%20Comments%3F*-%20(2007).pdf},
	Location = {Stevenson, Washington, USA},
	Pages = {145--158},
	Publisher = {ACM},
	Title = {/*i{C}omment: Bugs or Bad Comments?*/},
	Year = {2007},
	Abstract = {Commenting source code has long been a common practice in software development. Compared to source code, comments are more direct, descriptive and easy-to-understand. Comments and sourcecode provide relatively redundant and independent information regarding a program's semantic behavior. As software evolves, they can easily grow out-of-sync, indicating two problems: (1) bugs -the source code does not follow the assumptions and requirements specified by correct program comments; (2) bad comments - comments that are inconsistent with correct code, which can confuse and mislead programmers to introduce bugs in subsequent versions. Unfortunately, as most comments are written in natural language, no solution has been proposed to automatically analyze commentsand detect inconsistencies between comments and source code. This paper takes the first step in automatically analyzing commentswritten in natural language to extract implicit program rulesand use these rules to automatically detect inconsistencies between comments and source code, indicating either bugs or bad comments. Our solution, iComment, combines Natural Language Processing(NLP), Machine Learning, Statistics and Program Analysis techniques to achieve these goals. We evaluate iComment on four large code bases: Linux, Mozilla, Wine and Apache. Our experimental results show that iComment automatically extracts 1832 rules from comments with 90.8-100% accuracy and detects 60 comment-code inconsistencies, 33 newbugs and 27 bad comments, in the latest versions of the four programs. Nineteen of them (12 bugs and 7 bad comments) have already been confirmed by the corresponding developers while the others are currently being analyzed by the developers.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFMuLi8uLi9QYXBlcnMvVGFuL1Rhbi1ZdWFuLUtyaXNobmEgLSAtKml7Q31vbW1lbnQgQnVncyBvciBCYWQgQ29tbWVudHM/Ki0gKDIwMDcpLnBkZtIbDxwdV05TLmRhdGFPEQIQAAAAAAIQAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAugwsfVGFuLVl1YW4tS3Jpc2huYSAtIC0jMkU4MzA5LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC6DCcOwcDFQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAA1RhbgAAEAAIAADBNH5dAAAAEQAIAADDsLaBAAAAAQAQAC6DCwAtkT8AA0esAABr2AACADxPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6VGFuOlRhbi1ZdWFuLUtyaXNobmEgLSAtIzJFODMwOS5wZGYADgCGAEIAVABhAG4ALQBZAHUAYQBuAC0ASwByAGkAcwBoAG4AYQAgAC0AIAAtACoAaQB7AEMAfQBvAG0AbQBlAG4AdAAgAEIAdQBnAHMAIABvAHIAIABCAGEAZAAgAEMAbwBtAG0AZQBuAHQAcwA/ACoALQAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFpVc2Vycy9qZXJlbXkvUGFwZXJzL1Rhbi9UYW4tWXVhbi1LcmlzaG5hIC0gLSppe0N9b21tZW50IEJ1Z3Mgb3IgQmFkIENvbW1lbnRzPyotICgyMDA3KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBAAEFAQ0DIQMjAygDMQM8A0ADTgNVA14DYwNmAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA3M=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1294261.1294276}}

@inproceedings{Minsky:Caml:2008,
	Address = {New York, NY, USA},
	Author = {Yaron M. Minsky},
	Booktitle = {POPL '08: Proceedings of the 35th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
	Date-Added = {2008-01-14 01:45:40 -0500},
	Date-Modified = {2008-01-14 01:51:48 -0500},
	Doi = {http://doi.acm.org/10.1145/1328438.1328441},
	Isbn = {978-1-59593-689-9},
	Keywords = {functional languages},
	Local-Url = {file://localhost/Users/jeremy/Papers/Minsky/Minsky%20-%20Caml%20trading%20(2008).pdf},
	Location = {San Francisco, California, USA},
	Pages = {285--285},
	Publisher = {ACM},
	Title = {Caml trading},
	Year = {2008},
	Abstract = {Jane Street Capital is a successful proprietary trading company that has shifted from developing software in mainstream programming languages to developing software almost entirely in OCaml, a statically typed functional programming language that has only modest industrial use. The scope of the enterprise is small but growing: Jane Street now has over 20 OCaml programmers that have collectively written hundreds of thousands of lines of OCaml code. OCaml is used for building everything from trading systems to research infrastructure to user interfaces to systems administration tools. This talk will discuss the motivations behind Jane Street's adoption of OCaml, and why we think that statically typed functional programming languages are such a good fit for the world of trading and finance.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEDQuLi8uLi9QYXBlcnMvTWluc2t5L01pbnNreSAtIENhbWwgdHJhZGluZyAoMjAwOCkucGRm0hsPHB1XTlMuZGF0YU8RAbQAAAAAAbQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC6DBB9NaW5za3kgLSBDYW1sIHRyYWRpbiMyRTgzMDIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALoMCw7BwClBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGTWluc2t5ABAACAAAwTR+XQAAABEACAAAw7C2WgAAAAEAEAAugwQALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOk1pbnNreTpNaW5za3kgLSBDYW1sIHRyYWRpbiMyRTgzMDIucGRmAAAOAEIAIABNAGkAbgBzAGsAeQAgAC0AIABDAGEAbQBsACAAdAByAGEAZABpAG4AZwAgACgAMgAwADAAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASADtVc2Vycy9qZXJlbXkvUGFwZXJzL01pbnNreS9NaW5za3kgLSBDYW1sIHRyYWRpbmcgKDIwMDgpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA4QDmAO4CpgKoAq0CtgLBAsUC0wLaAuMC6ALrAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAvg=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1328438.1328441}}

@article{Abadi:Just:2007,
	Address = {New York, NY, USA},
	Author = {Mart\'{\i}n Abadi and Bruno Blanchet and C\'{e}dric Fournet},
	Date-Added = {2008-01-14 01:44:39 -0500},
	Date-Modified = {2008-01-14 01:48:44 -0500},
	Doi = {http://doi.acm.org/10.1145/1266977.1266978},
	Issn = {1094-9224},
	Journal = {ACM Trans. Inf. Syst. Secur.},
	Local-Url = {file://localhost/Users/jeremy/Papers/Abadi/Abadi-Blanchet-Fournet%20-%20Just%20fast%20keying%20in%20the%20pi%20calculus%20(2007).pdf},
	Number = {3},
	Pages = {9},
	Publisher = {ACM},
	Title = {Just fast keying in the pi calculus},
	Volume = {10},
	Year = {2007},
	Abstract = {JFK is a recent, attractive protocol for fast key establishment as part of securing IP communication. In this paper, we formally analyze this protocol in the applied pi calculus (partly in terms of observational equivalences and partly with the assistance of an automatic protocol verifier). We treat JFK's core security properties and also other properties that are rarely articulated and rigorously studied, such as plausible deniability and resistance to denial-of-service attacks. In the course of this analysis, we found some ambiguities and minor problems, such as limitations in identity protection, but we mostly obtain positive results about JFK. For this purpose, we develop ideas and techniques that should be more generally useful in the specification and verification of security protocols.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFouLi8uLi9QYXBlcnMvQWJhZGkvQWJhZGktQmxhbmNoZXQtRm91cm5ldCAtIEp1c3QgZmFzdCBrZXlpbmcgaW4gdGhlIHBpIGNhbGN1bHVzICgyMDA3KS5wZGbSGw8cHVdOUy5kYXRhTxECJgAAAAACJgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALoL+H0FiYWRpLUJsYW5jaGV0LUZvdXJuIzJFODJGQi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAugvvDsG/mUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVBYmFkaQAAEAAIAADBNH5dAAAAEQAIAADDsLY2AAAAAQAQAC6C/gAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QWJhZGk6QWJhZGktQmxhbmNoZXQtRm91cm4jMkU4MkZCLnBkZgAOAJAARwBBAGIAYQBkAGkALQBCAGwAYQBuAGMAaABlAHQALQBGAG8AdQByAG4AZQB0ACAALQAgAEoAdQBzAHQAIABmAGEAcwB0ACAAawBlAHkAaQBuAGcAIABpAG4AIAB0AGgAZQAgAHAAaQAgAGMAYQBsAGMAdQBsAHUAcwAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGFVc2Vycy9qZXJlbXkvUGFwZXJzL0FiYWRpL0FiYWRpLUJsYW5jaGV0LUZvdXJuZXQgLSBKdXN0IGZhc3Qga2V5aW5nIGluIHRoZSBwaSBjYWxjdWx1cyAoMjAwNykucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEHAQwBFAM+A0ADRQNOA1kDXQNrA3IDewOAA4MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1266977.1266978}}

@inproceedings{Renieris:Almost::1999,
	Address = {New York, NY, USA},
	Author = {Manos Renieris and Steven P. Reiss},
	Booktitle = {NPIVM '99: Proceedings of the 1999 workshop on new paradigms in information visualization and manipulation in conjunction with the eighth ACM internation conference on Information and knowledge management},
	Date-Added = {2008-01-14 01:43:28 -0500},
	Date-Modified = {2008-01-14 01:51:32 -0500},
	Doi = {http://doi.acm.org/10.1145/331770.331788},
	Isbn = {1-58113-254-9},
	Keywords = {optimization},
	Local-Url = {file://localhost/Users/jeremy/Papers/Renieris/Renieris-Reiss%20-%20Almost%20exploring%20program%20traces%20(1999).pdf},
	Location = {Kansas City, Missouri, United States},
	Pages = {70--77},
	Publisher = {ACM},
	Title = {Almost: exploring program traces},
	Year = {1999},
	Abstract = {We built a tool to visualize and explore program execution traces. Our goal was to help programmers without any prior knowledge of a program, quickly get enough knowledge about its structure so that they can make small to medium changes. In the process, a number of problems were faced and tackled concerning the efficient use of screen space, interaction with multiple concurrent views, and linking of asymmetric views.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFEuLi8uLi9QYXBlcnMvUmVuaWVyaXMvUmVuaWVyaXMtUmVpc3MgLSBBbG1vc3QgZXhwbG9yaW5nIHByb2dyYW0gdHJhY2VzICgxOTk5KS5wZGbSGw8cHVdOUy5kYXRhTxECCgAAAAACCgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALoLyH1JlbmllcmlzLVJlaXNzIC0gQWxtIzJFODJGMC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAugvDDsG9vUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAhSZW5pZXJpcwAQAAgAAME0fl0AAAARAAgAAMOwtb8AAAABABAALoLyAC2RPwADR6wAAGvYAAIAQU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpSZW5pZXJpczpSZW5pZXJpcy1SZWlzcyAtIEFsbSMyRTgyRjAucGRmAAAOAHgAOwBSAGUAbgBpAGUAcgBpAHMALQBSAGUAaQBzAHMAIAAtACAAQQBsAG0AbwBzAHQAIABlAHgAcABsAG8AcgBpAG4AZwAgAHAAcgBvAGcAcgBhAG0AIAB0AHIAYQBjAGUAcwAgACgAMQA5ADkAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFhVc2Vycy9qZXJlbXkvUGFwZXJzL1JlbmllcmlzL1JlbmllcmlzLVJlaXNzIC0gQWxtb3N0IGV4cGxvcmluZyBwcm9ncmFtIHRyYWNlcyAoMTk5OSkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAP4BAwELAxkDGwMgAykDNAM4A0YDTQNWA1sDXgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANr},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/331770.331788}}

@article{Mernik:When:2005,
	Address = {New York, NY, USA},
	Author = {Marjan Mernik and Jan Heering and Anthony M. Sloane},
	Date-Added = {2008-01-14 01:32:38 -0500},
	Date-Modified = {2008-01-14 01:36:28 -0500},
	Doi = {http://doi.acm.org/10.1145/1118890.1118892},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Keywords = {dsls, language design},
	Local-Url = {file://localhost/Users/jeremy/Papers/Mernik/Mernik-Heering-Sloane%20-%20When%20and%20how%20to%20develop%20domain-specific%20languages%20(2005).pdf},
	Number = {4},
	Pages = {316--344},
	Publisher = {ACM},
	Title = {When and how to develop domain-specific languages},
	Volume = {37},
	Year = {2005},
	Abstract = {Domain-specific languages (DSLs) are languages tailored to a specific application domain. They offer substantial gains in expressiveness and ease of use compared with general-purpose programming languages in their domain of application. DSL development is hard, requiring both domain knowledge and language development expertise. Few people have both. Not surprisingly, the decision to develop a DSL is often postponed indefinitely, if considered at all, and most DSLs never get beyond the application library stage.Although many articles have been written on the development of particular DSLs, there is very limited literature on DSL development methodologies and many questions remain regarding when and how to develop a DSL. To aid the DSL developer, we identify patterns in the decision, analysis, design, and implementation phases of DSL development. Our patterns improve and extend earlier work on DSL design patterns. We also discuss domain analysis tools and language development systems that may help to speed up DSL development. Finally, we present a number of open problems.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGguLi8uLi9QYXBlcnMvTWVybmlrL01lcm5pay1IZWVyaW5nLVNsb2FuZSAtIFdoZW4gYW5kIGhvdyB0byBkZXZlbG9wIGRvbWFpbi1zcGVjaWZpYyBsYW5ndWFnZXMgKDIwMDUpLnBkZtIbDxwdV05TLmRhdGFPEQJQAAAAAAJQAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAugtcfTWVybmlrLUhlZXJpbmctU2xvYW4jMkU4MkQ1LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC6C1cOwbQNQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABk1lcm5pawAQAAgAAME0fl0AAAARAAgAAMOws1MAAAABABAALoLXAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpNZXJuaWs6TWVybmlrLUhlZXJpbmctU2xvYW4jMkU4MkQ1LnBkZgAADgCqAFQATQBlAHIAbgBpAGsALQBIAGUAZQByAGkAbgBnAC0AUwBsAG8AYQBuAGUAIAAtACAAVwBoAGUAbgAgAGEAbgBkACAAaABvAHcAIAB0AG8AIABkAGUAdgBlAGwAbwBwACAAZABvAG0AYQBpAG4ALQBzAHAAZQBjAGkAZgBpAGMAIABsAGEAbgBnAHUAYQBnAGUAcwAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG9Vc2Vycy9qZXJlbXkvUGFwZXJzL01lcm5pay9NZXJuaWstSGVlcmluZy1TbG9hbmUgLSBXaGVuIGFuZCBob3cgdG8gZGV2ZWxvcCBkb21haW4tc3BlY2lmaWMgbGFuZ3VhZ2VzICgyMDA1KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARUBGgEiA3YDeAN9A4YDkQOVA6MDqgOzA7gDuwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAPI},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1118890.1118892}}

@article{Kelleher:Lowering:2005,
	Address = {New York, NY, USA},
	Author = {Caitlin Kelleher and Randy Pausch},
	Date-Added = {2008-01-14 01:31:01 -0500},
	Date-Modified = {2008-01-14 01:35:13 -0500},
	Doi = {http://doi.acm.org/10.1145/1089733.1089734},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Local-Url = {file://localhost/Users/jeremy/Papers/Kelleher/Kelleher-Pausch%20-%20Lowering%20the%20barriers%20to%20programming%20A%20taxonomy%20of%20programming%20(2005).pdf},
	Number = {2},
	Pages = {83--137},
	Publisher = {ACM},
	Title = {Lowering the barriers to programming: A taxonomy of programming environments and languages for novice programmers},
	Volume = {37},
	Year = {2005},
	Abstract = {Since the early 1960's, researchers have built a number of programming languages and environments with the intention of making programming accessible to a larger number of people. This article presents a taxonomy of languages and environments designed to make programming more accessible to novice programmers of all ages. The systems are organized by their primary goal, either to teach programming or to use programming to empower their users, and then, by each system's authors' approach, to making learning to program easier for novice programmers. The article explains all categories in the taxonomy, provides a brief description of the systems in each category, and suggests some avenues for future work in novice programming environments and languages.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHEuLi8uLi9QYXBlcnMvS2VsbGVoZXIvS2VsbGVoZXItUGF1c2NoIC0gTG93ZXJpbmcgdGhlIGJhcnJpZXJzIHRvIHByb2dyYW1taW5nIEEgdGF4b25vbXkgb2YgcHJvZ3JhbW1pbmcgKDIwMDUpLnBkZtIbDxwdV05TLmRhdGFPEQJqAAAAAAJqAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAugtAfS2VsbGVoZXItUGF1c2NoIC0gTG8jMkU4MkNGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC6Cz8OwbMRQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAACEtlbGxlaGVyABAACAAAwTR+XQAAABEACAAAw7CzFAAAAAEAEAAugtAALZE/AANHrAAAa9gAAgBBT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOktlbGxlaGVyOktlbGxlaGVyLVBhdXNjaCAtIExvIzJFODJDRi5wZGYAAA4AuABbAEsAZQBsAGwAZQBoAGUAcgAtAFAAYQB1AHMAYwBoACAALQAgAEwAbwB3AGUAcgBpAG4AZwAgAHQAaABlACAAYgBhAHIAcgBpAGUAcgBzACAAdABvACAAcAByAG8AZwByAGEAbQBtAGkAbgBnACAAQQAgAHQAYQB4AG8AbgBvAG0AeQAgAG8AZgAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHhVc2Vycy9qZXJlbXkvUGFwZXJzL0tlbGxlaGVyL0tlbGxlaGVyLVBhdXNjaCAtIExvd2VyaW5nIHRoZSBiYXJyaWVycyB0byBwcm9ncmFtbWluZyBBIHRheG9ub215IG9mIHByb2dyYW1taW5nICgyMDA1KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBHgEjASsDmQObA6ADqQO0A7gDxgPNA9YD2wPeAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA+s=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1089733.1089734}}

@article{Black:Object-oriented:,
	Address = {New York, NY, USA},
	Author = {A. P. Black},
	Date-Added = {2008-01-14 01:28:14 -0500},
	Date-Modified = {2008-01-14 01:30:00 -0500},
	Doi = {http://doi.acm.org/10.1145/242224.242414},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Keywords = {monads, object-oriented languages},
	Local-Url = {file://localhost/Users/jeremy/Papers/Black/Black%20-%20Object-oriented%20languages%20the%20next%20generation%20(1996).pdf},
	Month = {December},
	Number = {4},
	Pages = {149},
	Publisher = {ACM},
	Title = {Object-oriented languages: the next generation},
	Volume = {28},
	Year = {1996},
	Abstract = {This position paper outlines some important future directions for object-oriented programming languages. It was prepared as input to the object-oriented programming working group of the Workshop on Strategic Directions in Computing. It highlights the influence of Distribution, User-orientation, Monads, Types and Higher-Order programming on Object-Oriented languages.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFMuLi8uLi9QYXBlcnMvQmxhY2svQmxhY2sgLSBPYmplY3Qtb3JpZW50ZWQgbGFuZ3VhZ2VzIHRoZSBuZXh0IGdlbmVyYXRpb24gKDE5OTYpLnBkZtIbDxwdV05TLmRhdGFPEQIQAAAAAAIQAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAugrMfQmxhY2sgLSBPYmplY3Qtb3JpZW4jMkU4MkFGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC6Cr8OwaxMAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABUJsYWNrAAAQAAgAAME0fl0AAAARAAgAAMOwsWMAAAABABAALoKzAC2RPwADR6wAAGvYAAIAPk9kaW46VXNlcnM6amVyZW15OlBhcGVyczpCbGFjazpCbGFjayAtIE9iamVjdC1vcmllbiMyRTgyQUYucGRmAA4AggBAAEIAbABhAGMAawAgAC0AIABPAGIAagBlAGMAdAAtAG8AcgBpAGUAbgB0AGUAZAAgAGwAYQBuAGcAdQBhAGcAZQBzACAAdABoAGUAIABuAGUAeAB0ACAAZwBlAG4AZQByAGEAdABpAG8AbgAgACgAMQA5ADkANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFpVc2Vycy9qZXJlbXkvUGFwZXJzL0JsYWNrL0JsYWNrIC0gT2JqZWN0LW9yaWVudGVkIGxhbmd1YWdlcyB0aGUgbmV4dCBnZW5lcmF0aW9uICgxOTk2KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBAAEFAQ0DIQMjAygDMQM8A0ADTgNVA14DYwNmAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA3M=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/242224.242414}}

@article{Beszedes:Survey:2003,
	Address = {New York, NY, USA},
	Author = {\'{A}rp\'{a}d Besz\'{e}des and Rudolf Ferenc and Tibor Gyim\'{o}thy and Andr\'{e} Dolenc and Konsta Karsisto},
	Date-Added = {2008-01-14 01:22:42 -0500},
	Date-Modified = {2008-01-14 01:23:59 -0500},
	Doi = {http://doi.acm.org/10.1145/937503.937504},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Keywords = {optimization},
	Local-Url = {file://localhost/Users/jeremy/Papers/Beszedes/Beszedes-Ferenc-Gyimothy%20-%20Survey%20of%20code-size%20reduction%20methods%20(2003).pdf},
	Number = {3},
	Pages = {223--267},
	Publisher = {ACM},
	Title = {Survey of code-size reduction methods},
	Volume = {35},
	Year = {2003},
	Abstract = {Program code compression is an emerging research activity that is having an impact in several production areas such as networking and embedded systems. This is because the reduced-sized code can have a positive impact on network traffic and embedded system costs such as memory requirements and power consumption. Although code-size reduction is a relatively new research area, numerous publications already exist on it. The methods published usually have different motivations and a variety of application contexts. They may use different principles and their publications often use diverse notations. To our knowledge, there are no publications that present a good overview of this broad range of methods and give a useful assessment. This article surveys twelve methods and several related works appearing in some 50 papers published up to now. We provide extensive assessment criteria for evaluating the methods and offer a basis for comparison. We conclude that it is fairly hard to make any fair comparisons of the methods or draw conclusions about their applicability.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGEuLi8uLi9QYXBlcnMvQmVzemVkZXMvQmVzemVkZXMtRmVyZW5jLUd5aW1vdGh5IC0gU3VydmV5IG9mIGNvZGUtc2l6ZSByZWR1Y3Rpb24gbWV0aG9kcyAoMjAwMykucGRm0hsPHB1XTlMuZGF0YU8RAjoAAAAAAjoAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC6Cgh9CZXN6ZWRlcy1GZXJlbmMtR3lpbSMyRTgyN0YucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALoJ/w7BqGlBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIQmVzemVkZXMAEAAIAADBNH5dAAAAEQAIAADDsLBqAAAAAQAQAC6CggAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QmVzemVkZXM6QmVzemVkZXMtRmVyZW5jLUd5aW0jMkU4MjdGLnBkZgAADgCYAEsAQgBlAHMAegBlAGQAZQBzAC0ARgBlAHIAZQBuAGMALQBHAHkAaQBtAG8AdABoAHkAIAAtACAAUwB1AHIAdgBlAHkAIABvAGYAIABjAG8AZABlAC0AcwBpAHoAZQAgAHIAZQBkAHUAYwB0AGkAbwBuACAAbQBlAHQAaABvAGQAcwAgACgAMgAwADAAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGhVc2Vycy9qZXJlbXkvUGFwZXJzL0Jlc3plZGVzL0Jlc3plZGVzLUZlcmVuYy1HeWltb3RoeSAtIFN1cnZleSBvZiBjb2RlLXNpemUgcmVkdWN0aW9uIG1ldGhvZHMgKDIwMDMpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEOARMBGwNZA1sDYANpA3QDeAOGA40DlgObA54AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/937503.937504}}

@article{Aycock:A-brief:2003,
	Address = {New York, NY, USA},
	Author = {John Aycock},
	Date-Added = {2008-01-14 01:15:44 -0500},
	Date-Modified = {2008-04-21 01:37:03 -0400},
	Doi = {http://doi.acm.org/10.1145/857076.857077},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Keywords = {compilation; history of computing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Aycock/Aycock%20-%20A%20brief%20history%20of%20just-in-time%20(2003).pdf},
	Number = {2},
	Pages = {97--113},
	Publisher = {ACM},
	Title = {A brief history of just-in-time},
	Volume = {35},
	Year = {2003},
	Abstract = {Software systems have been using "just-in-time" compilation (JIT) techniques since the 1960s. Broadly, JIT compilation includes any translation performed dynamically, after a program has started execution. We examine the motivation behind JIT compilation and constraints imposed on JIT compilation systems, and present a classification scheme for such systems. This classification emerges as we survey forty years of JIT work, from 1960--2000.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEcuLi8uLi9QYXBlcnMvQXljb2NrL0F5Y29jayAtIEEgYnJpZWYgaGlzdG9yeSBvZiBqdXN0LWluLXRpbWUgKDIwMDMpLnBkZtIbDxwdV05TLmRhdGFPEQHsAAAAAAHsAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAugkAfQXljb2NrIC0gQSBicmllZiBoaXMjMkU4MjNGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC6CP8OwaG9QREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABkF5Y29jawAQAAgAAME0fl0AAAARAAgAAMOwrr8AAAABABAALoJAAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpBeWNvY2s6QXljb2NrIC0gQSBicmllZiBoaXMjMkU4MjNGLnBkZgAADgBoADMAQQB5AGMAbwBjAGsAIAAtACAAQQAgAGIAcgBpAGUAZgAgAGgAaQBzAHQAbwByAHkAIABvAGYAIABqAHUAcwB0AC0AaQBuAC0AdABpAG0AZQAgACgAMgAwADAAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAE5Vc2Vycy9qZXJlbXkvUGFwZXJzL0F5Y29jay9BeWNvY2sgLSBBIGJyaWVmIGhpc3Rvcnkgb2YganVzdC1pbi10aW1lICgyMDAzKS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA9AD5AQEC8QLzAvgDAQMMAxADHgMlAy4DMwM2AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA0M=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/857076.857077}}

@article{Spector:Efficient:1988,
	Address = {New York, NY, USA},
	Author = {D. Spector},
	Date-Added = {2008-01-14 01:10:52 -0500},
	Date-Modified = {2008-01-17 21:19:51 -0500},
	Doi = {http://doi.acm.org/10.1145/57669.57684},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Keywords = {parsing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Spector/Spector%20-%20Efficient%20full%20LR(I)%20parser%20generation%20(1988).pdf},
	Number = {12},
	Pages = {143--150},
	Publisher = {ACM},
	Rating = {4},
	Read = {Yes},
	Title = {Efficient full LR(I) parser generation},
	Volume = {23},
	Year = {1988},
	Abstract = {This paper proposes that full LR(1) parser generators are easier to use than the LALR(1) parser generators commonly in use, and that minimal-state full LR(1) tables are not much larger than LALR(1) tables. A method is presented for the automatic construction of minimal-state full LR(1) parser tables. The method is fast and accurate because it starts with the LR(0) table and resolves lookahead ambiguities as necessary by tracing the LR(0) table and splitting the minimum number of states, and because there is no need for generalized set manipulation.},
	Annote = {Spector clearly explains in one page what Pager spent ten pages being confusing about. Basically: Generate an LR(0) parser, throw in one token of lookahead, zero in on inadequate states, and split them to reflect the left context that suffices to disambiguate them. Spector includes output from a parser generator he wrote that employs this technique.

Spector also gives a good, concise argument for why LR(1) parser generators are better than LALR(1). His arguments against LALR(1) parser generators are still valid twenty years later.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFAuLi8uLi9QYXBlcnMvU3BlY3Rvci9TcGVjdG9yIC0gRWZmaWNpZW50IGZ1bGwgTFIoSSkgcGFyc2VyIGdlbmVyYXRpb24gKDE5ODgpLnBkZtIbDxwdV05TLmRhdGFPEQIIAAAAAAIIAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAugiMfU3BlY3RvciAtIEVmZmljaWVudCAjMkU4MjE3LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC6CF8OwZuVQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAB1NwZWN0b3IAABAACAAAwTR+XQAAABEACAAAw7CtNQAAAAEAEAAugiMALZE/AANHrAAAa9gAAgBAT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlNwZWN0b3I6U3BlY3RvciAtIEVmZmljaWVudCAjMkU4MjE3LnBkZgAOAHgAOwBTAHAAZQBjAHQAbwByACAALQAgAEUAZgBmAGkAYwBpAGUAbgB0ACAAZgB1AGwAbAAgAEwAUgAoAEkAKQAgAHAAYQByAHMAZQByACAAZwBlAG4AZQByAGEAdABpAG8AbgAgACgAMQA5ADgAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFdVc2Vycy9qZXJlbXkvUGFwZXJzL1NwZWN0b3IvU3BlY3RvciAtIEVmZmljaWVudCBmdWxsIExSKEkpIHBhcnNlciBnZW5lcmF0aW9uICgxOTg4KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAP0BAgEKAxYDGAMdAyYDMQM1A0MDSgNTA1gDWwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANo},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/57669.57684}}

@article{Appel:SSA-is-functional:1998,
	Address = {New York, NY, USA},
	Author = {Andrew W. Appel},
	Date-Added = {2007-12-23 01:26:18 -0500},
	Date-Modified = {2008-01-14 01:39:56 -0500},
	Doi = {http://doi.acm.org/10.1145/278283.278285},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Keywords = {functional languages, intermediate representations},
	Local-Url = {file://localhost/Users/jeremy/Papers/Appel/Appel%20-%20SSA%20is%20functional%20programming%20(1998).pdf},
	Number = {4},
	Pages = {17--20},
	Publisher = {ACM},
	Title = {SSA is functional programming},
	Volume = {33},
	Year = {1998},
	Abstract = {Static Single-Assignment (SSA) form is an intermediate language designed to make optimization clean and efficient for imperative-language (Fortran, C) compilers. Lambda-calculus is an intermediate language that makes optimization clean and efficient for functional-language (Scheme, ML, Haskell) compilers. The SSA community draws pictures of graphs with basic blocks and flow edges, and the functional-language community writes lexically nested functions, but (as Richard Kelsey recently pointed out [9]) they're both doing exactly the same thing in different notation.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEMuLi8uLi9QYXBlcnMvQXBwZWwvQXBwZWwgLSBTU0EgaXMgZnVuY3Rpb25hbCBwcm9ncmFtbWluZyAoMTk5OCkucGRm0hsPHB1XTlMuZGF0YU8RAeAAAAAAAeAAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2aGx9BcHBlbCAtIFNTQSBpcyBmdW5jdCMyRDlBMTgucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZoYw5Npx1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAFQXBwZWwAABAACAAAwTR+XQAAABEACAAAw5OwFwAAAAEAEAAtmhsALZE/AANHrAAAa9gAAgA+T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkFwcGVsOkFwcGVsIC0gU1NBIGlzIGZ1bmN0IzJEOUExOC5wZGYADgBiADAAQQBwAHAAZQBsACAALQAgAFMAUwBBACAAaQBzACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMQA5ADkAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAEpVc2Vycy9qZXJlbXkvUGFwZXJzL0FwcGVsL0FwcGVsIC0gU1NBIGlzIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgKDE5OTgpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgDwAPUA/QLhAuMC6ALxAvwDAAMOAxUDHgMjAyYAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADMw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/278283.278285}}

@article{Ball:Paths:1999,
	Address = {New York, NY, USA},
	Author = {Thomas Ball},
	Date-Added = {2007-12-23 01:23:34 -0500},
	Date-Modified = {2008-01-14 01:39:32 -0500},
	Doi = {http://doi.acm.org/10.1145/307903.307910},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Keywords = {functional languages, imperative languages},
	Local-Url = {file://localhost/Users/jeremy/Papers/Ball/Ball%20-%20Paths%20between%20imperative%20and%20functional%20programming%20(1999).pdf},
	Number = {2},
	Pages = {21--25},
	Publisher = {ACM},
	Title = {Paths between imperative and functional programming},
	Volume = {34},
	Year = {1999},
	Abstract = {This article explores relationships between imperative and functional programming by viewing a program as a set of paths. We argue, through a small case study, that the presence of infeasible (or unexecutable) paths makes programs harder to understand. We identify two main causes of infeasible paths, "unnecessary" sequencing and destructive update, hallmarks of an imperative programming style. Functional programming eschews sequencing and destructive update, which can result in programs with fewer infeasible paths that are easier to understand. No proofs are included. We intend to provoke discussion regarding imperative and functional programming styles.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFcuLi8uLi9QYXBlcnMvQmFsbC9CYWxsIC0gUGF0aHMgYmV0d2VlbiBpbXBlcmF0aXZlIGFuZCBmdW5jdGlvbmFsIHByb2dyYW1taW5nICgxOTk5KS5wZGbSGw8cHVdOUy5kYXRhTxECHAAAAAACHAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZoSH0JhbGwgLSBQYXRocyBiZXR3ZWVuIzJEOUEwRC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtmg3Dk2mfUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAARCYWxsABAACAAAwTR+XQAAABEACAAAw5Ov7wAAAAEAEAAtmhIALZE/AANHrAAAa9gAAgA9T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkJhbGw6QmFsbCAtIFBhdGhzIGJldHdlZW4jMkQ5QTBELnBkZgAADgCMAEUAQgBhAGwAbAAgAC0AIABQAGEAdABoAHMAIABiAGUAdAB3AGUAZQBuACAAaQBtAHAAZQByAGEAdABpAHYAZQAgAGEAbgBkACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMQA5ADkAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF5Vc2Vycy9qZXJlbXkvUGFwZXJzL0JhbGwvQmFsbCAtIFBhdGhzIGJldHdlZW4gaW1wZXJhdGl2ZSBhbmQgZnVuY3Rpb25hbCBwcm9ncmFtbWluZyAoMTk5OSkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQQBCQERAzEDMwM4A0EDTANQA14DZQNuA3MDdgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOD},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/307903.307910}}

@inproceedings{Thiemann:Unboxed:1995,
	Address = {New York, NY, USA},
	Author = {Peter J. Thiemann},
	Booktitle = {FPCA '95: Proceedings of the seventh international conference on Functional programming languages and computer architecture},
	Date-Added = {2007-12-22 21:40:38 -0500},
	Date-Modified = {2007-12-22 21:40:58 -0500},
	Doi = {http://doi.acm.org/10.1145/224164.224175},
	Isbn = {0-89791-719-7},
	Keywords = {compilation, unboxing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Thiemann/Thiemann%20-%20Unboxed%20values%20and%20polymorphic%20typing%20revisited%20(1995).pdf},
	Location = {La Jolla, California, United States},
	Pages = {24--35},
	Publisher = {ACM},
	Title = {Unboxed values and polymorphic typing revisited},
	Year = {1995},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFsuLi8uLi9QYXBlcnMvVGhpZW1hbm4vVGhpZW1hbm4gLSBVbmJveGVkIHZhbHVlcyBhbmQgcG9seW1vcnBoaWMgdHlwaW5nIHJldmlzaXRlZCAoMTk5NSkucGRm0hsPHB1XTlMuZGF0YU8RAigAAAAAAigAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2UhB9UaGllbWFubiAtIFVuYm94ZWQgdiMyRDk0ODAucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZSAw5M0x1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIVGhpZW1hbm4AEAAIAADBNH5dAAAAEQAIAADDk3sXAAAAAQAQAC2UhAAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6VGhpZW1hbm46VGhpZW1hbm4gLSBVbmJveGVkIHYjMkQ5NDgwLnBkZgAADgCMAEUAVABoAGkAZQBtAGEAbgBuACAALQAgAFUAbgBiAG8AeABlAGQAIAB2AGEAbAB1AGUAcwAgAGEAbgBkACAAcABvAGwAeQBtAG8AcgBwAGgAaQBjACAAdAB5AHAAaQBuAGcAIAByAGUAdgBpAHMAaQB0AGUAZAAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGJVc2Vycy9qZXJlbXkvUGFwZXJzL1RoaWVtYW5uL1RoaWVtYW5uIC0gVW5ib3hlZCB2YWx1ZXMgYW5kIHBvbHltb3JwaGljIHR5cGluZyByZXZpc2l0ZWQgKDE5OTUpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEIAQ0BFQNBA0MDSANRA1wDYANuA3UDfgODA4YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/224164.224175}}

@inproceedings{Shao:A-type-based:1995,
	Address = {New York, NY, USA},
	Author = {Zhong Shao and Andrew W. Appel},
	Booktitle = {PLDI '95: Proceedings of the ACM SIGPLAN 1995 conference on Programming language design and implementation},
	Date-Added = {2007-12-22 21:36:46 -0500},
	Date-Modified = {2008-01-02 18:49:53 -0500},
	Doi = {http://doi.acm.org/10.1145/207110.207123},
	Isbn = {0-89791-697-2},
	Keywords = {history of computing, compilation},
	Local-Url = {file://localhost/Users/jeremy/Papers/Shao/Shao-Appel%20-%20A%20type-based%20compiler%20for%20standard%20ML%20(1995).pdf},
	Location = {La Jolla, California, United States},
	Pages = {116--129},
	Publisher = {ACM},
	Read = {Yes},
	Title = {A type-based compiler for standard ML},
	Year = {1995},
	Abstract = {Compile-time type information should be valuable in efficient compilation of statically typed functional languages such as Standard ML. But how should type-directed compilation work in real compilers, and how much performance gain will type-based optimizations yield? In order to support more efficient data representations and gain more experience about type-directed compilation, we have implemented a new type-based middle end and back end for the Standard ML of New Jersey compiler. We describe the basic design of the new compiler, identify a number of practical issues, and then compare the performance of our new compiler with the old non-type-based compiler. Our measurement shows that a combination of several simple type-based optimizations reduces heap allocation by 36%; and improves the already-efficient code generated by the old non-type-based compiler by about 19% on a DECstation 500.},
	Annote = {I'll need to reread this one. It's pretty dense. The conclusion sheds a lot of light on why they're bothering with this, but a lot of the story seems tied up in Appel's book "Compiling with Continuations" and its development of CPS as an intermediate representation.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE8uLi8uLi9QYXBlcnMvU2hhby9TaGFvLUFwcGVsIC0gQSB0eXBlLWJhc2VkIGNvbXBpbGVyIGZvciBzdGFuZGFyZCBNTCAoMTk5NSkucGRm0hsPHB1XTlMuZGF0YU8RAgQAAAAAAgQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2UbR9TaGFvLUFwcGVsIC0gQSB0eXBlLSMyRDk0NkIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZRrw5M0GVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAEU2hhbwAQAAgAAME0fl0AAAARAAgAAMOTemkAAAABABAALZRtAC2RPwADR6wAAGvYAAIAPU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpTaGFvOlNoYW8tQXBwZWwgLSBBIHR5cGUtIzJEOTQ2Qi5wZGYAAA4AfAA9AFMAaABhAG8ALQBBAHAAcABlAGwAIAAtACAAQQAgAHQAeQBwAGUALQBiAGEAcwBlAGQAIABjAG8AbQBwAGkAbABlAHIAIABmAG8AcgAgAHMAdABhAG4AZABhAHIAZAAgAE0ATAAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFZVc2Vycy9qZXJlbXkvUGFwZXJzL1NoYW8vU2hhby1BcHBlbCAtIEEgdHlwZS1iYXNlZCBjb21waWxlciBmb3Igc3RhbmRhcmQgTUwgKDE5OTUpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD8AQEBCQMRAxMDGAMhAywDMAM+A0UDTgNTA1YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADYw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/207110.207123}}

@article{Fradet:Compilation:1991,
	Address = {New York, NY, USA},
	Author = {Pascal Fradet and Daniel Le M\'{e}tayer},
	Date-Added = {2007-12-22 21:11:18 -0500},
	Date-Modified = {2007-12-22 21:12:37 -0500},
	Doi = {http://doi.acm.org/10.1145/114005.102805},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Keywords = {compilation},
	Local-Url = {file://localhost/Users/jeremy/Papers/Fradet/Fradet-Metayer%20-%20Compilation%20of%20functional%20languages%20by%20program%20transformation%20(1991).pdf},
	Number = {1},
	Pages = {21--51},
	Publisher = {ACM},
	Title = {Compilation of functional languages by program transformation},
	Volume = {13},
	Year = {1991},
	Abstract = {One of the most important issues concerning functional languages is the efficiency and the correctness of their implementation. We focus on sequential implementations for conventional von Neumann computers. The compilation process is described in terms of program transformations in the functional framework. The original functional expression is transformed into a functional term that can be seen as a traditional machine code. The two main steps are the compilation of the computation rule by the introduction of continuation functions and the compilation of the environment management using combinators. The advantage of this approach is that we do not have to introduce an abstract machine, which makes correctness proofs much simpler. As far as efficiency is concerned, this approach is promising since many optimizations can be described and formally justified in the functional framework.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEG0uLi8uLi9QYXBlcnMvRnJhZGV0L0ZyYWRldC1NZXRheWVyIC0gQ29tcGlsYXRpb24gb2YgZnVuY3Rpb25hbCBsYW5ndWFnZXMgYnkgcHJvZ3JhbSB0cmFuc2Zvcm1hdGlvbiAoMTk5MSkucGRm0hsPHB1XTlMuZGF0YU8RAl4AAAAAAl4AAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2UDx9GcmFkZXQtTWV0YXllciAtIENvbSMyRDk0MEQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZQNw5MuQVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGRnJhZGV0ABAACAAAwTR+XQAAABEACAAAw5N0kQAAAAEAEAAtlA8ALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkZyYWRldDpGcmFkZXQtTWV0YXllciAtIENvbSMyRDk0MEQucGRmAAAOALQAWQBGAHIAYQBkAGUAdAAtAE0AZQB0AGEAeQBlAHIAIAAtACAAQwBvAG0AcABpAGwAYQB0AGkAbwBuACAAbwBmACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgAGwAYQBuAGcAdQBhAGcAZQBzACAAYgB5ACAAcAByAG8AZwByAGEAbQAgAHQAcgBhAG4AcwBmAG8AcgBtAGEAdABpAG8AbgAgACgAMQA5ADkAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHRVc2Vycy9qZXJlbXkvUGFwZXJzL0ZyYWRldC9GcmFkZXQtTWV0YXllciAtIENvbXBpbGF0aW9uIG9mIGZ1bmN0aW9uYWwgbGFuZ3VhZ2VzIGJ5IHByb2dyYW0gdHJhbnNmb3JtYXRpb24gKDE5OTEpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEaAR8BJwOJA4sDkAOZA6QDqAO2A70DxgPLA84AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAD2w==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/114005.102805}}

@article{Kulkarni:Fast:2005,
	Address = {New York, NY, USA},
	Author = {Prasad A. Kulkarni and Stephen R. Hines and David B. Whalley and Jason D. Hiser and Jack W. Davidson and Douglas L. Jones},
	Date-Added = {2007-12-22 21:09:24 -0500},
	Date-Modified = {2007-12-22 21:10:19 -0500},
	Doi = {http://doi.acm.org/10.1145/1071604.1071607},
	Issn = {1544-3566},
	Journal = {ACM Trans. Archit. Code Optim.},
	Keywords = {optimization phase ordering},
	Local-Url = {file://localhost/Users/jeremy/Papers/Kulkarni/Kulkarni-Hines-Whalley%20-%20Fast%20and%20efficient%20searches%20for%20effective%20optimization-phase%20(2005).pdf},
	Number = {2},
	Pages = {165--198},
	Publisher = {ACM},
	Title = {Fast and efficient searches for effective optimization-phase sequences},
	Volume = {2},
	Year = {2005},
	Abstract = {It has long been known that a fixed ordering of optimization phases will not produce the best code for every application. One approach for addressing this phase-ordering problem is to use an evolutionary algorithm to search for a specific sequence of phases for each module or function. While such searches have been shown to produce more efficient code, the approach can be extremely slow because the application is compiled and possibly executed to evaluate each sequence's effectiveness. Consequently, evolutionary or iterative compilation schemes have been promoted for compilation systems targeting embedded applications where meeting strict constraints on execution time, code size, and power consumption is paramount and longer compilation times may be tolerated in the final stage of development, when an application is compiled one last time and embedded in a product. Unfortunately, even for small embedded applications, the search process can take many hours or even days making the approach less attractive to developers. In this paper, we describe two complementary general approaches for achieving faster searches for effective optimization sequences when using a genetic algorithm. The first approach reduces the search time by avoiding unnecessary executions of the application when possible. Results indicate search time reductions of 62%;, on average, often reducing searches from hours to minutes. The second approach modifies the search so fewer generations are required to achieve the same results. Measurements show this approach decreases the average number of required generations by 59%. These improvements have the potential for making evolutionary compilation a viable choice for tuning embedded applications.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHYuLi8uLi9QYXBlcnMvS3Vsa2FybmkvS3Vsa2FybmktSGluZXMtV2hhbGxleSAtIEZhc3QgYW5kIGVmZmljaWVudCBzZWFyY2hlcyBmb3IgZWZmZWN0aXZlIG9wdGltaXphdGlvbi1waGFzZSAoMjAwNSkucGRm0hsPHB1XTlMuZGF0YU8RAnoAAAAAAnoAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2T8h9LdWxrYXJuaS1IaW5lcy1XaGFsbCMyRDkzRkIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZP7w5MtkFBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIS3Vsa2FybmkAEAAIAADBNH5dAAAAEQAIAADDk3PgAAAAAQAQAC2T8gAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6S3Vsa2Fybmk6S3Vsa2FybmktSGluZXMtV2hhbGwjMkQ5M0ZCLnBkZgAADgDCAGAASwB1AGwAawBhAHIAbgBpAC0ASABpAG4AZQBzAC0AVwBoAGEAbABsAGUAeQAgAC0AIABGAGEAcwB0ACAAYQBuAGQAIABlAGYAZgBpAGMAaQBlAG4AdAAgAHMAZQBhAHIAYwBoAGUAcwAgAGYAbwByACAAZQBmAGYAZQBjAHQAaQB2AGUAIABvAHAAdABpAG0AaQB6AGEAdABpAG8AbgAtAHAAaABhAHMAZQAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAH1Vc2Vycy9qZXJlbXkvUGFwZXJzL0t1bGthcm5pL0t1bGthcm5pLUhpbmVzLVdoYWxsZXkgLSBGYXN0IGFuZCBlZmZpY2llbnQgc2VhcmNoZXMgZm9yIGVmZmVjdGl2ZSBvcHRpbWl6YXRpb24tcGhhc2UgKDIwMDUpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBIwEoATADrgOwA7UDvgPJA80D2wPiA+sD8APzAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAABAA=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1071604.1071607}}

@inproceedings{Kulkarni:In-search:2006,
	Address = {New York, NY, USA},
	Author = {Prasad A. Kulkarni and David B. Whalley and Gary S. Tyson and Jack W. Davidson},
	Booktitle = {LCTES '06: Proceedings of the 2006 ACM SIGPLAN/SIGBED conference on Language, compilers, and tool support for embedded systems},
	Date-Added = {2007-12-22 21:07:56 -0500},
	Date-Modified = {2007-12-22 21:08:57 -0500},
	Doi = {http://doi.acm.org/10.1145/1134650.1134663},
	Isbn = {1-59593-362-X},
	Keywords = {optimization phase ordering},
	Local-Url = {file://localhost/Users/jeremy/Papers/Kulkarni/Kulkarni-Whalley-Tyson%20-%20In%20search%20of%20near-optimal%20optimization%20phase%20orderings%20(2006).pdf},
	Location = {Ottawa, Ontario, Canada},
	Pages = {83--92},
	Publisher = {ACM},
	Title = {In search of near-optimal optimization phase orderings},
	Year = {2006},
	Abstract = {Phase ordering is a long standing challenge for traditional optimizing compilers. Varying the order of applying optimization phases to a program can produce different code, with potentially significant performance variation amongst them. A key insight to addressing the phase ordering problem is that many different optimization sequences produce the same code. In an earlier study, we used this observation to restate the phase ordering problem to concentrate on finding all distinct function instances that can be produced due to different phase orderings, instead of attempting to generate code for all possible optimization sequences. Using a novel search algorithm we were able to show that it is possible to exhaustively enumerate the set of all possible function instances that can be produced by different phase orderings in our compiler for most of the functions in our benchmark suite [1]. Finding the optimal function instance within this set for almost any dynamic measure of performance still appears impractical since that would involve execution/simulation of all generated function instances. To find the dynamically optimal function instance we exploit the observation that the enumeration space for a function typically contains a very small number of distinct control flow paths. We simulate only one function instance from each group of function instances having the identical control flow, and use that information to estimate the dynamic performance of the remaining functions in that group. We further show that the estimated dynamic frequency counts obtained by using our method correlate extremely well to simulated processor cycle counts. Thus, by using our measure of dynamic frequencies to identify a small number of the best performing function instances we can often find the optimal phase ordering for a function within a reasonable amount of time. Finally, we perform a case study to evaluate how adept our genetic algorithm is for finding optimal phase orderings within our compiler, and demonstrate how the algorithm can be improved.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHAuLi8uLi9QYXBlcnMvS3Vsa2FybmkvS3Vsa2FybmktV2hhbGxleS1UeXNvbiAtIEluIHNlYXJjaCBvZiBuZWFyLW9wdGltYWwgb3B0aW1pemF0aW9uIHBoYXNlIG9yZGVyaW5ncyAoMjAwNikucGRm0hsPHB1XTlMuZGF0YU8RAmgAAAAAAmgAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2T8h9LdWxrYXJuaS1XaGFsbGV5LVR5cyMyRDkzRUUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZPuw5MtVlBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIS3Vsa2FybmkAEAAIAADBNH5dAAAAEQAIAADDk3OmAAAAAQAQAC2T8gAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6S3Vsa2Fybmk6S3Vsa2FybmktV2hhbGxleS1UeXMjMkQ5M0VFLnBkZgAADgC2AFoASwB1AGwAawBhAHIAbgBpAC0AVwBoAGEAbABsAGUAeQAtAFQAeQBzAG8AbgAgAC0AIABJAG4AIABzAGUAYQByAGMAaAAgAG8AZgAgAG4AZQBhAHIALQBvAHAAdABpAG0AYQBsACAAbwBwAHQAaQBtAGkAegBhAHQAaQBvAG4AIABwAGgAYQBzAGUAIABvAHIAZABlAHIAaQBuAGcAcwAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHdVc2Vycy9qZXJlbXkvUGFwZXJzL0t1bGthcm5pL0t1bGthcm5pLVdoYWxsZXktVHlzb24gLSBJbiBzZWFyY2ggb2YgbmVhci1vcHRpbWFsIG9wdGltaXphdGlvbiBwaGFzZSBvcmRlcmluZ3MgKDIwMDYpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBHQEiASoDlgOYA50DpgOxA7UDwwPKA9MD2APbAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA+g=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1134650.1134663}}

@article{Kumar:When:2004,
	Address = {New York, NY, USA},
	Author = {K. V. Seshu Kumar},
	Date-Added = {2007-12-22 21:06:22 -0500},
	Date-Modified = {2007-12-22 21:07:27 -0500},
	Doi = {http://doi.acm.org/10.1145/981009.981015},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Keywords = {compilation, optimization, virtual machines},
	Local-Url = {file://localhost/Users/jeremy/Papers/Kumar/Kumar%20-%20When%20and%20what%20to%20compile-optimize%20in%20a%20virtual%20machine%3F%20(2004).pdf},
	Number = {3},
	Pages = {38--45},
	Publisher = {ACM},
	Title = {When and what to compile/optimize in a virtual machine?},
	Volume = {39},
	Year = {2004},
	Abstract = {To speed up the computation of some of the object languages, virtual machines use dynamic compilation. But due to compilation taking place during user application runtime, one has to choose which methods to compile, so that the compile time has little impact on the total runtime of the actual application. In order to achieve this, we have to use an estimate to determine the process of compilation. Current virtual machines use run time information such as number of calls made to this method, size of the method and as well as number of times the back edges taken to determine the hotness of a method. They use this information against some threshold which does not have any relationship with the method that is being considered for compilation.

Detecting the hot routines is very important from the perspective of performance since optimized methods run 10 times faster than the interpreted version. In this paper we propose a new technique called relative estimation for determining the hotness of the functions. For each method in the application, we estimate the cost/benefits for compilation or optimization by doing method analysis. We select the methods for compilation or optimization initially based on the above metrics using the proposed relative estimation technique. Later on we use the online profile information such as backedge counters and invocation counts to adjust the relative estimation process itself. We have performed experiments to validate the effectiveness of the proposed method on SPECjvm98 benchmark suite and found that up to 4% performance improvement in the application execution time occurs.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEF0uLi8uLi9QYXBlcnMvS3VtYXIvS3VtYXIgLSBXaGVuIGFuZCB3aGF0IHRvIGNvbXBpbGUtb3B0aW1pemUgaW4gYSB2aXJ0dWFsIG1hY2hpbmU/ICgyMDA0KS5wZGbSGw8cHVdOUy5kYXRhTxECLgAAAAACLgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZPgH0t1bWFyIC0gV2hlbiBhbmQgd2hhIzJEOTNENi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtk9bDkyy2UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVLdW1hcgAAEAAIAADBNH5dAAAAEQAIAADDk3MGAAAAAQAQAC2T4AAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6S3VtYXI6S3VtYXIgLSBXaGVuIGFuZCB3aGEjMkQ5M0Q2LnBkZgAOAJYASgBLAHUAbQBhAHIAIAAtACAAVwBoAGUAbgAgAGEAbgBkACAAdwBoAGEAdAAgAHQAbwAgAGMAbwBtAHAAaQBsAGUALQBvAHAAdABpAG0AaQB6AGUAIABpAG4AIABhACAAdgBpAHIAdAB1AGEAbAAgAG0AYQBjAGgAaQBuAGUAPwAgACgAMgAwADAANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGRVc2Vycy9qZXJlbXkvUGFwZXJzL0t1bWFyL0t1bWFyIC0gV2hlbiBhbmQgd2hhdCB0byBjb21waWxlLW9wdGltaXplIGluIGEgdmlydHVhbCBtYWNoaW5lPyAoMjAwNCkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQoBDwEXA0kDSwNQA1kDZANoA3YDfQOGA4sDjgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOb},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/981009.981015}}

@article{Sansom:Formally:1997,
	Address = {New York, NY, USA},
	Author = {Patrick M. Sansom and Peyton Jones, Simon L. },
	Date-Added = {2007-12-22 21:03:49 -0500},
	Date-Modified = {2008-04-17 17:55:32 -0400},
	Doi = {http://doi.acm.org/10.1145/244795.244802},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Keywords = {profiling},
	Local-Url = {file://localhost/Users/jeremy/Papers/Sansom/Sansom-Jones%20-%20Formally%20based%20profiling%20for%20higher-order%20functional%20(1997).pdf},
	Number = {2},
	Pages = {334--385},
	Publisher = {ACM},
	Title = {Formally based profiling for higher-order functional languages},
	Volume = {19},
	Year = {1997},
	Abstract = {We present the first source-level profiler for a compiled, nonstrict, higher-order, purely functional language capable of measuring time as well as space usage. Our profiler is implemented in a production-quality optimizing compiler for Haskell and can successfully profile large applications. A unique feature of our approach is that we give a formal specification of the attribution of execution costs to cost centers. This specification enables us to discuss our design decisions in a precise framework, prove properties about the attribution of costs, and examine to effects of different program transformations on the attribution of costs. Since it is not obvious how to map this specification onto a particular implementation, we also present an implementation-oriented operational semantics, and prove it equivalent to the specification.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGIuLi8uLi9QYXBlcnMvU2Fuc29tL1NhbnNvbS1Kb25lcyAtIEZvcm1hbGx5IGJhc2VkIHByb2ZpbGluZyBmb3IgaGlnaGVyLW9yZGVyIGZ1bmN0aW9uYWwgKDE5OTcpLnBkZtIbDxwdV05TLmRhdGFPEQI+AAAAAAI+AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtk8UfU2Fuc29tLUpvbmVzIC0gRm9ybWEjMkQ5M0MzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC2Tw8OTLFJQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABlNhbnNvbQAQAAgAAME0fl0AAAARAAgAAMOTcqIAAAABABAALZPFAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpTYW5zb206U2Fuc29tLUpvbmVzIC0gRm9ybWEjMkQ5M0MzLnBkZgAADgCeAE4AUwBhAG4AcwBvAG0ALQBKAG8AbgBlAHMAIAAtACAARgBvAHIAbQBhAGwAbAB5ACAAYgBhAHMAZQBkACAAcAByAG8AZgBpAGwAaQBuAGcAIABmAG8AcgAgAGgAaQBnAGgAZQByAC0AbwByAGQAZQByACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgACgAMQA5ADkANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGlVc2Vycy9qZXJlbXkvUGFwZXJzL1NhbnNvbS9TYW5zb20tSm9uZXMgLSBGb3JtYWxseSBiYXNlZCBwcm9maWxpbmcgZm9yIGhpZ2hlci1vcmRlciBmdW5jdGlvbmFsICgxOTk3KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQ8BFAEcA14DYANlA24DeQN9A4sDkgObA6ADowAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOw},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/244795.244802}}

@inproceedings{Cardelli:Compiling:1984,
	Address = {New York, NY, USA},
	Author = {Luca Cardelli},
	Booktitle = {LFP '84: Proceedings of the 1984 ACM Symposium on LISP and functional programming},
	Date-Added = {2007-12-22 20:58:15 -0500},
	Date-Modified = {2008-01-02 18:37:41 -0500},
	Doi = {http://doi.acm.org/10.1145/800055.802037},
	Isbn = {0-89791-142-3},
	Keywords = {history of computing, compilation},
	Local-Url = {file://localhost/Users/jeremy/Papers/Cardelli/Cardelli%20-%20Compiling%20a%20functional%20language%20(1984).pdf},
	Location = {Austin, Texas, United States},
	Pages = {208--217},
	Publisher = {ACM},
	Rating = {2},
	Read = {Yes},
	Title = {Compiling a functional language},
	Year = {1984},
	Abstract = {This paper summarizes my experience in implementing a compiler for a functional language. The language is ML(1) [Milner 84] and the compiler was first implemented in 1980 as a personal project when I was a postgraduate student at the University of Edinburgh(2). At the time, I was familiar with programming language semantics but knew very little about compiler technology; interpreters had been my main programming concern. Major influences in the design of this compiler have been [Steele 77] [Steele 78] and the implementation folklore for statically and dynamically scoped dialects of Lisp [Allen 78]. As a result, the internal structure of the compiler is fairly unorthodox, if compared for example with [Aho 78]. Anyway, a compiler for a language like ML has to be different. ML is interactive, statically scoped, strongly typed, polymorphic, and has first class higher-order functions, type inference and dynamic allocation. These features preclude many well-known implementation styles, particularly the ones used for Lisp (because of static scoping), the Algol family (because of functional values) and C (because of nested scoping and strong typing). The interaction of these features is what gives ML its ``character'', and makes compilation challenging. The compiler has been recently partially converted to the new ML standard. The major points of interest which are discussed in this paper are: (a) the interactive interpreter-like usage; (b) the polymorphic type inference algorithm; (c) the compilation of pattern matching; (d) the optimization of the representation of user defined data types; (e) the compilation of functional closures, function application and variable access; (f) the intermediate abstract machine and its formal operational semantics; (g) modules and type-safe separate compilation.},
	Annote = {Regards functional compilation as distinct from imperative, and considers techniques such as register allocation to be a "mistake in functional languages because of frequent context switching" (209). In building her compiler, Cardelli drew primarily on Lisp compilation experience and folklore, rather than imperative compilation theory and technique as exemplified in the dragon book.

The module system was still under construction at the time. Already uses unboxed representations for small values (booleans, small ints, etc.). Discusses pattern-matching via discrimination trees in some detail. Correctly observes that how to represent the many datatypes, particularly closures, is an important issue. Argues for use of an abstract machine in order to simplify the process of compilation, and seems particularly fond of using a typefree machine. Her functional abstract machine (FAM) is basically an SECD machine, though it uses several other stacks for different purposes.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEsuLi8uLi9QYXBlcnMvQ2FyZGVsbGkvQ2FyZGVsbGkgLSBDb21waWxpbmcgYSBmdW5jdGlvbmFsIGxhbmd1YWdlICgxOTg0KS5wZGbSGw8cHVdOUy5kYXRhTxEB+AAAAAAB+AACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZOmH0NhcmRlbGxpIC0gQ29tcGlsaW5nIzJEOTNBMi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtk6LDkys+UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAhDYXJkZWxsaQAQAAgAAME0fl0AAAARAAgAAMOTcY4AAAABABAALZOmAC2RPwADR6wAAGvYAAIAQU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpDYXJkZWxsaTpDYXJkZWxsaSAtIENvbXBpbGluZyMyRDkzQTIucGRmAAAOAGwANQBDAGEAcgBkAGUAbABsAGkAIAAtACAAQwBvAG0AcABpAGwAaQBuAGcAIABhACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgAGwAYQBuAGcAdQBhAGcAZQAgACgAMQA5ADgANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFJVc2Vycy9qZXJlbXkvUGFwZXJzL0NhcmRlbGxpL0NhcmRlbGxpIC0gQ29tcGlsaW5nIGEgZnVuY3Rpb25hbCBsYW5ndWFnZSAoMTk4NCkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPgA/QEFAwEDAwMIAxEDHAMgAy4DNQM+A0MDRgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANT},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/800055.802037}}

@article{Webber:Optimization:1995,
	Address = {New York, NY, USA},
	Author = {Adam Webber},
	Date-Added = {2007-12-22 20:52:19 -0500},
	Date-Modified = {2007-12-22 20:57:44 -0500},
	Doi = {http://doi.acm.org/10.1145/201059.201067},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Keywords = {optimization},
	Local-Url = {file://localhost/Users/jeremy/Papers/Webber/Webber%20-%20Optimization%20of%20functional%20programs%20by%20grammar%20thinning%20(1995).pdf},
	Number = {2},
	Pages = {293--330},
	Publisher = {ACM},
	Title = {Optimization of functional programs by grammar thinning},
	Volume = {17},
	Year = {1995},
	Abstract = {We describe a new technique for optimizing first-order functional programs. Programs are represented as graph grammars, and optimization proceeds by counterexample: when a graph generated by the grammar is found to contain an unnecessary computation, the optimizer attempts to reformulates the grammar so that it never again generates any graph that contains that counterexample. This kind of program reformulation corresponds to an interesting problem on context-free grammars. Our reformulation technique is derived from an (approximate) solution to this CFG problem. An optimizer called Thinner is the proof of concept for this technique. Thinner is a fully automatic, source-to-source optimizer for a Lisp-like language of purely functional, first-order programs. Thinner rediscovers a wide variety of common compiler optimizations. It also finds other more exotic transformations, including the well-known Fibonacci reformulation and the Knuth-Morris-Pratt optimization.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEF8uLi8uLi9QYXBlcnMvV2ViYmVyL1dlYmJlciAtIE9wdGltaXphdGlvbiBvZiBmdW5jdGlvbmFsIHByb2dyYW1zIGJ5IGdyYW1tYXIgdGhpbm5pbmcgKDE5OTUpLnBkZtIbDxwdV05TLmRhdGFPEQI0AAAAAAI0AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtk3YfV2ViYmVyIC0gT3B0aW1pemF0aW8jMkQ5MzcyLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC2TcsOTKklQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABldlYmJlcgAQAAgAAME0fl0AAAARAAgAAMOTcJkAAAABABAALZN2AC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpXZWJiZXI6V2ViYmVyIC0gT3B0aW1pemF0aW8jMkQ5MzcyLnBkZgAADgCYAEsAVwBlAGIAYgBlAHIAIAAtACAATwBwAHQAaQBtAGkAegBhAHQAaQBvAG4AIABvAGYAIABmAHUAbgBjAHQAaQBvAG4AYQBsACAAcAByAG8AZwByAGEAbQBzACAAYgB5ACAAZwByAGEAbQBtAGEAcgAgAHQAaABpAG4AbgBpAG4AZwAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGZVc2Vycy9qZXJlbXkvUGFwZXJzL1dlYmJlci9XZWJiZXIgLSBPcHRpbWl6YXRpb24gb2YgZnVuY3Rpb25hbCBwcm9ncmFtcyBieSBncmFtbWFyIHRoaW5uaW5nICgxOTk1KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBDAERARkDUQNTA1gDYQNsA3ADfgOFA44DkwOWAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA6M=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/201059.201067}}

@inproceedings{Marlow:Making:2004,
	Address = {New York, NY, USA},
	Author = {Simon Marlow and Simon Peyton Jones},
	Booktitle = {ICFP '04: Proceedings of the ninth ACM SIGPLAN international conference on Functional programming},
	Date-Added = {2007-12-22 20:48:03 -0500},
	Date-Modified = {2008-04-17 17:56:52 -0400},
	Doi = {http://doi.acm.org/10.1145/1016850.1016856},
	Isbn = {1-58113-905-5},
	Keywords = {optimization, functional languages},
	Local-Url = {file://localhost/Users/jeremy/Papers/Marlow/Marlow-Jones%20-%20Making%20a%20fast%20curry%20push-enter%20vs.%20eval-apply%20(2004).pdf},
	Location = {Snow Bird, UT, USA},
	Pages = {4--15},
	Publisher = {ACM},
	Title = {Making a fast curry: push/enter vs. eval/apply for higher-order languages},
	Year = {2004},
	Abstract = {Higher-order languages that encourage currying are implemented using one of two basic evaluation models: push/enter or eval/apply. Implementors use their intuition and qualitative judgements to choose one model or the other. Our goal in this paper is to provide, for the first time, a more substantial basis for this choice, based on our qualitative and quantitative experience of implementing both models in a state-of-the-art compiler for Haskell. Our conclusion is simple, and contradicts our initial intuition: compiled implementations should use eval/apply.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFsuLi8uLi9QYXBlcnMvTWFybG93L01hcmxvdy1Kb25lcyAtIE1ha2luZyBhIGZhc3QgY3VycnkgcHVzaC1lbnRlciB2cy4gZXZhbC1hcHBseSAoMjAwNCkucGRm0hsPHB1XTlMuZGF0YU8RAigAAAAAAigAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2TVB9NYXJsb3ctSm9uZXMgLSBNYWtpbiMyRDkzNTIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZNSw5MpJFBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGTWFybG93ABAACAAAwTR+XQAAABEACAAAw5NvdAAAAAEAEAAtk1QALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOk1hcmxvdzpNYXJsb3ctSm9uZXMgLSBNYWtpbiMyRDkzNTIucGRmAAAOAJAARwBNAGEAcgBsAG8AdwAtAEoAbwBuAGUAcwAgAC0AIABNAGEAawBpAG4AZwAgAGEAIABmAGEAcwB0ACAAYwB1AHIAcgB5ACAAcAB1AHMAaAAtAGUAbgB0AGUAcgAgAHYAcwAuACAAZQB2AGEAbAAtAGEAcABwAGwAeQAgACgAMgAwADAANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGJVc2Vycy9qZXJlbXkvUGFwZXJzL01hcmxvdy9NYXJsb3ctSm9uZXMgLSBNYWtpbmcgYSBmYXN0IGN1cnJ5IHB1c2gtZW50ZXIgdnMuIGV2YWwtYXBwbHkgKDIwMDQpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEIAQ0BFQNBA0MDSANRA1wDYANuA3UDfgODA4YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1016850.1016856}}

@article{Douence:A-systematic:1998,
	Address = {New York, NY, USA},
	Author = {R\'{e}mi Douence and Pascal Fradet},
	Date-Added = {2007-12-22 20:46:59 -0500},
	Date-Modified = {2008-01-14 01:39:13 -0500},
	Doi = {http://doi.acm.org/10.1145/276393.276397},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Keywords = {functional languages},
	Local-Url = {file://localhost/Users/jeremy/Papers/Douence/Douence-Fradet%20-%20A%20systematic%20study%20of%20functional%20language%20implementations%20(1998).pdf},
	Number = {2},
	Pages = {344--387},
	Publisher = {ACM},
	Title = {A systematic study of functional language implementations},
	Volume = {20},
	Year = {1998},
	Abstract = {We introduce a unified framework to describe, relate, compare, and classify functional language implementations. The compilation process is expressed as a succession of program transformations in the common framework. At each step, different transformations model fundamental choices. A benefit of this approach is to structure and decompose the implementation process. The correctness proofs can be tackled independently for each step and amount to proving program transformations in the functional world. This approach also paves the way to formal comparisons by making it possible to estimate the complexity of individual transformations or compositions of them. Our study aims at covering the whole known design space of sequential functional language implementations. In particular, we consider call-by-value, call-by-name, call-by-need reduction strategies as well as environment- and graph-based implementations. We describe for each compilation step the diverse alternatives as program transformations. In some cases, we illustrate how to compare or relate compilation techniques, express global optimizations, or hybrid implementations. We also provide a classification of well-known abstract machines.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGouLi8uLi9QYXBlcnMvRG91ZW5jZS9Eb3VlbmNlLUZyYWRldCAtIEEgc3lzdGVtYXRpYyBzdHVkeSBvZiBmdW5jdGlvbmFsIGxhbmd1YWdlIGltcGxlbWVudGF0aW9ucyAoMTk5OCkucGRm0hsPHB1XTlMuZGF0YU8RAlYAAAAAAlYAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2TSR9Eb3VlbmNlLUZyYWRldCAtIEEgcyMyRDkzNDYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZNGw5Moz1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAHRG91ZW5jZQAAEAAIAADBNH5dAAAAEQAIAADDk28fAAAAAQAQAC2TSQAtkT8AA0esAABr2AACAEBPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6RG91ZW5jZTpEb3VlbmNlLUZyYWRldCAtIEEgcyMyRDkzNDYucGRmAA4ArABVAEQAbwB1AGUAbgBjAGUALQBGAHIAYQBkAGUAdAAgAC0AIABBACAAcwB5AHMAdABlAG0AYQB0AGkAYwAgAHMAdAB1AGQAeQAgAG8AZgAgAGYAdQBuAGMAdABpAG8AbgBhAGwAIABsAGEAbgBnAHUAYQBnAGUAIABpAG0AcABsAGUAbQBlAG4AdABhAHQAaQBvAG4AcwAgACgAMQA5ADkAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHFVc2Vycy9qZXJlbXkvUGFwZXJzL0RvdWVuY2UvRG91ZW5jZS1GcmFkZXQgLSBBIHN5c3RlbWF0aWMgc3R1ZHkgb2YgZnVuY3Rpb25hbCBsYW5ndWFnZSBpbXBsZW1lbnRhdGlvbnMgKDE5OTgpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBFwEcASQDfgOAA4UDjgOZA50DqwOyA7sDwAPDAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA9A=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/276393.276397}}

@inproceedings{Nederhof:Efficient:1996,
	Address = {Morristown, NJ, USA},
	Author = {Mark-Jan Nederhof and Giorgio Satta},
	Booktitle = {Proceedings of the 34th annual meeting on Association for Computational Linguistics},
	Date-Added = {2007-12-22 20:28:27 -0500},
	Date-Modified = {2007-12-22 20:32:55 -0500},
	Doi = {http://dx.doi.org/10.3115/981863.981895},
	Keywords = {parsing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Nederhof/Nederhof-Satta%20-%20Efficient%20tabular%20LR%20parsing%20(1996).pdf},
	Location = {Santa Cruz, California},
	Pages = {239--246},
	Publisher = {Association for Computational Linguistics},
	Title = {Efficient tabular LR parsing},
	Year = {1996},
	Abstract = {We give a new treatment of tabular LR parsing, which is an alternative to Tomita's generalized LR algorithm. The advantage is twofold. Firstly, our treatment is conceptually more attractive because it uses simpler concepts, such as grammar transformations and standard tabulation techniques also know as chart parsing. Secondly, the static and dynamic complexity of parsing, both in space and time, is significantly reduced.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE4uLi8uLi9QYXBlcnMvTmVkZXJob2YvTmVkZXJob2YtU2F0dGEgLSBFZmZpY2llbnQgdGFidWxhciBMUiBwYXJzaW5nICgxOTk2KS5wZGbSGw8cHVdOUy5kYXRhTxECAgAAAAACAgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZLtH05lZGVyaG9mLVNhdHRhIC0gRWZmIzJEOTJFOS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkunDkyRsUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAhOZWRlcmhvZgAQAAgAAME0fl0AAAARAAgAAMOTarwAAAABABAALZLtAC2RPwADR6wAAGvYAAIAQU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpOZWRlcmhvZjpOZWRlcmhvZi1TYXR0YSAtIEVmZiMyRDkyRTkucGRmAAAOAHIAOABOAGUAZABlAHIAaABvAGYALQBTAGEAdAB0AGEAIAAtACAARQBmAGYAaQBjAGkAZQBuAHQAIAB0AGEAYgB1AGwAYQByACAATABSACAAcABhAHIAcwBpAG4AZwAgACgAMQA5ADkANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFVVc2Vycy9qZXJlbXkvUGFwZXJzL05lZGVyaG9mL05lZGVyaG9mLVNhdHRhIC0gRWZmaWNpZW50IHRhYnVsYXIgTFIgcGFyc2luZyAoMTk5NikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD7AQABCAMOAxADFQMeAykDLQM7A0IDSwNQA1MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADYA==},
	Bdsk-Url-1 = {http://dx.doi.org/10.3115/981863.981895}}

@inproceedings{Wyk:Context-aware:2007,
	Address = {New York, NY, USA},
	Author = {Eric R. Van Wyk and August C. Schwerdfeger},
	Booktitle = {GPCE '07: Proceedings of the 6th international conference on Generative programming and component engineering},
	Date-Added = {2007-12-22 20:28:09 -0500},
	Date-Modified = {2007-12-22 20:33:22 -0500},
	Doi = {http://doi.acm.org/10.1145/1289971.1289983},
	Isbn = {978-1-59593-855-8},
	Keywords = {parsing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Wyk/Wyk-Schwerdfeger%20-%20Context-aware%20scanning%20for%20parsing%20extensible%20languages%20(2007).pdf},
	Location = {Salzburg, Austria},
	Pages = {63--72},
	Publisher = {ACM},
	Title = {Context-aware scanning for parsing extensible languages},
	Year = {2007},
	Abstract = {This paper introduces new parsing and context-aware scanning algorithms in which the scanner uses contextual information to disambiguate lexical syntax. The parser uses a slightly modified LR-style algorithm that passes to the scanner the set of valid symbols that the scanner may return at that point in parsing. This set is those terminals whose entries in the parse table for the current parse state are shift, reduce, or accept, but not error. The scanner then only returns tokens in this set. An analysis is given that can statically verify that the scanner will never return more than one token for a single input. Context-aware scanning is especially useful when parsing and scanning extensible languages in which domain specific languages can be embedded. It has been used in extensible versions of Java 1.4 and ANSI C. We illustrate this approach with a declarative specification of a subset of Java and extensions that embed SQL queries and Boolean expression tables into Java.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGYuLi8uLi9QYXBlcnMvV3lrL1d5ay1TY2h3ZXJkZmVnZXIgLSBDb250ZXh0LWF3YXJlIHNjYW5uaW5nIGZvciBwYXJzaW5nIGV4dGVuc2libGUgbGFuZ3VhZ2VzICgyMDA3KS5wZGbSGw8cHVdOUy5kYXRhTxECSgAAAAACSgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZLhH1d5ay1TY2h3ZXJkZmVnZXIgLSBDIzJEOTJERi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkt/DkyRBUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAANXeWsAABAACAAAwTR+XQAAABEACAAAw5NqkQAAAAEAEAAtkuEALZE/AANHrAAAa9gAAgA8T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOld5azpXeWstU2Nod2VyZGZlZ2VyIC0gQyMyRDkyREYucGRmAA4ArABVAFcAeQBrAC0AUwBjAGgAdwBlAHIAZABmAGUAZwBlAHIAIAAtACAAQwBvAG4AdABlAHgAdAAtAGEAdwBhAHIAZQAgAHMAYwBhAG4AbgBpAG4AZwAgAGYAbwByACAAcABhAHIAcwBpAG4AZwAgAGUAeAB0AGUAbgBzAGkAYgBsAGUAIABsAGEAbgBnAHUAYQBnAGUAcwAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG1Vc2Vycy9qZXJlbXkvUGFwZXJzL1d5ay9XeWstU2Nod2VyZGZlZ2VyIC0gQ29udGV4dC1hd2FyZSBzY2FubmluZyBmb3IgcGFyc2luZyBleHRlbnNpYmxlIGxhbmd1YWdlcyAoMjAwNykucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgETARgBIANuA3ADdQN+A4kDjQObA6IDqwOwA7MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADwA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1289971.1289983}}

@article{Gray:Canonical:1973,
	Address = {New York, NY, USA},
	Author = {James N. Gray and Michael A. Harrison},
	Date-Added = {2007-12-22 20:27:11 -0500},
	Date-Modified = {2007-12-22 20:32:46 -0500},
	Doi = {http://doi.acm.org/10.1145/321752.321755},
	Issn = {0004-5411},
	Journal = {J. ACM},
	Keywords = {parsing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Gray/Gray-Harrison%20-%20Canonical%20Precedence%20Schemes%20(1973).pdf},
	Number = {2},
	Pages = {214--234},
	Publisher = {ACM},
	Title = {Canonical Precedence Schemes},
	Volume = {20},
	Year = {1973},
	Abstract = {A general theory of canonical precedence analysis is defined and studied. The familiar types of precedence analysis such as operator precedence or simple precedence occur as special cases of this theory. Among the theoretical results obtained are a characterization of the structure of precedence relations and the relation of canonical precedence schemes to operator sets.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEkuLi8uLi9QYXBlcnMvR3JheS9HcmF5LUhhcnJpc29uIC0gQ2Fub25pY2FsIFByZWNlZGVuY2UgU2NoZW1lcyAoMTk3MykucGRm0hsPHB1XTlMuZGF0YU8RAfIAAAAAAfIAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2TAB9HcmF5LUhhcnJpc29uIC0gQ2FubyMyRDkyRkQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZL9w5MkwVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAER3JheQAQAAgAAME0fl0AAAARAAgAAMOTaxEAAAABABAALZMAAC2RPwADR6wAAGvYAAIAPU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpHcmF5OkdyYXktSGFycmlzb24gLSBDYW5vIzJEOTJGRC5wZGYAAA4AcAA3AEcAcgBhAHkALQBIAGEAcgByAGkAcwBvAG4AIAAtACAAQwBhAG4AbwBuAGkAYwBhAGwAIABQAHIAZQBjAGUAZABlAG4AYwBlACAAUwBjAGgAZQBtAGUAcwAgACgAMQA5ADcAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFBVc2Vycy9qZXJlbXkvUGFwZXJzL0dyYXkvR3JheS1IYXJyaXNvbiAtIENhbm9uaWNhbCBQcmVjZWRlbmNlIFNjaGVtZXMgKDE5NzMpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD2APsBAwL5AvsDAAMJAxQDGAMmAy0DNgM7Az4AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADSw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/321752.321755}}

@inproceedings{Pager:The-lane:1973,
	Address = {New York, NY, USA},
	Author = {David Pager},
	Booktitle = {STOC '73: Proceedings of the fifth annual ACM symposium on Theory of computing},
	Date-Added = {2007-12-22 20:26:54 -0500},
	Date-Modified = {2008-01-17 21:17:29 -0500},
	Doi = {http://doi.acm.org/10.1145/800125.804048},
	Keywords = {parsing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Pager/Pager%20-%20The%20lane%20tracing%20algorithm%20for%20constructing%20LR(k)%20(1973).pdf},
	Location = {Austin, Texas, United States},
	Pages = {172--181},
	Publisher = {ACM},
	Rating = {3},
	Read = {Yes},
	Title = {The lane tracing algorithm for constructing LR(k) parsers},
	Year = {1973},
	Abstract = {The paper presents, as far as the author is aware, the first practical general method for constructing LR(k) parsers. It has been used, without computational difficulty, to produce LR(1), LR(2) and LR(3) parsers for grammars of the size of ALGOL.},
	Annote = {Pager's description of LR(0) parsing is the most lucid I've read thus far. Unfortunately, he's confusing when it comes to describing his new ideas. That's likely due to lack of oversight (it is a non-refereed tech report) and Pager still trying to figure out how best to describe his idea. This tech report grew up to be a publication in Acta Informatica.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFcuLi8uLi9QYXBlcnMvUGFnZXIvUGFnZXIgLSBUaGUgbGFuZSB0cmFjaW5nIGFsZ29yaXRobSBmb3IgY29uc3RydWN0aW5nIExSKGspICgxOTczKS5wZGbSGw8cHVdOUy5kYXRhTxECHAAAAAACHAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZL5H1BhZ2VyIC0gVGhlIGxhbmUgdHJhIzJEOTJGNy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkvfDkySuUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVQYWdlcgAAEAAIAADBNH5dAAAAEQAIAADDk2r+AAAAAQAQAC2S+QAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6UGFnZXI6UGFnZXIgLSBUaGUgbGFuZSB0cmEjMkQ5MkY3LnBkZgAOAIoARABQAGEAZwBlAHIAIAAtACAAVABoAGUAIABsAGEAbgBlACAAdAByAGEAYwBpAG4AZwAgAGEAbABnAG8AcgBpAHQAaABtACAAZgBvAHIAIABjAG8AbgBzAHQAcgB1AGMAdABpAG4AZwAgAEwAUgAoAGsAKQAgACgAMQA5ADcAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF5Vc2Vycy9qZXJlbXkvUGFwZXJzL1BhZ2VyL1BhZ2VyIC0gVGhlIGxhbmUgdHJhY2luZyBhbGdvcml0aG0gZm9yIGNvbnN0cnVjdGluZyBMUihrKSAoMTk3MykucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQQBCQERAzEDMwM4A0EDTANQA14DZQNuA3MDdgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOD},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/800125.804048}}

@inproceedings{Lammel:Design:2002,
	Address = {New York, NY, USA},
	Author = {Ralf L\"{a}mmel and Joost Visser},
	Booktitle = {RULE '02: Proceedings of the 2002 ACM SIGPLAN workshop on Rule-based programming},
	Date-Added = {2007-12-22 20:17:47 -0500},
	Date-Modified = {2007-12-22 20:19:09 -0500},
	Doi = {http://doi.acm.org/10.1145/570186.570187},
	Isbn = {1-58113-606-4},
	Local-Url = {file://localhost/Users/jeremy/Papers/Lammel/Lammel-Visser%20-%20Design%20patterns%20for%20functional%20strategic%20programming%20(2002).pdf},
	Location = {Pittsburgh, Pennsylvania},
	Pages = {1--14},
	Publisher = {ACM},
	Title = {Design patterns for functional strategic programming},
	Year = {2002},
	Abstract = {We believe that design patterns can be an effective means of consolidating and communicating program construction expertise for functional programming, just as they have proven to be in object-oriented programming. The emergence of combinator libraries that develop a specific domain or programming idiom has intensified, rather than reduced, the need for design patterns.In previous work, we introduced the fundamentals and a supporting combinator library for functional strategic programming. This is an idiom for (general purpose) generic programming based on the notion of a functional strategy: a first-class generic function that can not only be applied to terms of any type, but which also allows generic traversal into subterms and can be customised with type-specific behaviour.This paper seeks to provide practising functional programmers with pragmatic guidance in crafting their own generic programs using functional strategies. To this end, we propose a novel description format for functional design patterns, and we initiate a catalogue of strategy design patterns. These design patterns aim at consolidating strategic programming expertise in accessible form.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGMuLi8uLi9QYXBlcnMvTGFtbWVsL0xhbW1lbC1WaXNzZXIgLSBEZXNpZ24gcGF0dGVybnMgZm9yIGZ1bmN0aW9uYWwgc3RyYXRlZ2ljIHByb2dyYW1taW5nICgyMDAyKS5wZGbSGw8cHVdOUy5kYXRhTxECQAAAAAACQAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZKpH0xhbW1lbC1WaXNzZXIgLSBEZXNpIzJEOTJBNy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkqfDkyG2UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZMYW1tZWwAEAAIAADBNH5dAAAAEQAIAADDk2gGAAAAAQAQAC2SqQAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6TGFtbWVsOkxhbW1lbC1WaXNzZXIgLSBEZXNpIzJEOTJBNy5wZGYAAA4AoABPAEwAYQBtAG0AZQBsAC0AVgBpAHMAcwBlAHIAIAAtACAARABlAHMAaQBnAG4AIABwAGEAdAB0AGUAcgBuAHMAIABmAG8AcgAgAGYAdQBuAGMAdABpAG8AbgBhAGwAIABzAHQAcgBhAHQAZQBnAGkAYwAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMgAwADAAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGpVc2Vycy9qZXJlbXkvUGFwZXJzL0xhbW1lbC9MYW1tZWwtVmlzc2VyIC0gRGVzaWduIHBhdHRlcm5zIGZvciBmdW5jdGlvbmFsIHN0cmF0ZWdpYyBwcm9ncmFtbWluZyAoMjAwMikucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARABFQEdA2EDYwNoA3EDfAOAA44DlQOeA6MDpgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOz},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/570186.570187}}

@inproceedings{Burchett:Lowering::2007,
	Address = {New York, NY, USA},
	Author = {Kimberley Burchett and Gregory H. Cooper and Shriram Krishnamurthi},
	Booktitle = {PEPM '07: Proceedings of the 2007 ACM SIGPLAN symposium on Partial evaluation and semantics-based program manipulation},
	Date-Added = {2007-12-22 20:14:17 -0500},
	Date-Modified = {2007-12-22 20:56:33 -0500},
	Doi = {http://doi.acm.org/10.1145/1244381.1244393},
	Isbn = {978-1-59593-620-2},
	Keywords = {reactive programming, optimization, static analysis},
	Local-Url = {file://localhost/Users/jeremy/Papers/Burchett/Burchett-Cooper-Krishnamurthi%20-%20Lowering%20a%20static%20optimization%20technique%20for%20transparent%20(2007).pdf},
	Location = {Nice, France},
	Pages = {71--80},
	Publisher = {ACM},
	Title = {Lowering: a static optimization technique for transparent functional reactivity},
	Year = {2007},
	Abstract = {Functional Reactive Programming (FRP) extends traditional functional programming with dataflow evaluation, making it possible to write interactive programs in a declarative style. An FRP language creates a dynamic graph of data dependencies and reacts to changes by propagating updates through the graph. In a transparent FRP language, the primitive operators are implicitly lifted, so they construct graph nodes when they are applied to time-varying values. This model has some attractive properties, but it tends to produce a large graph that is costly to maintain. In this paper, we develop a transformation we call lowering, which improves performance by reducing the size of the graph. We present a static analysis that guides the sound application of this optimization, and we present benchmark results that demonstrate dramatic improvements in both speed and memory usage for real programs.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHkuLi8uLi9QYXBlcnMvQnVyY2hldHQvQnVyY2hldHQtQ29vcGVyLUtyaXNobmFtdXJ0aGkgLSBMb3dlcmluZyBhIHN0YXRpYyBvcHRpbWl6YXRpb24gdGVjaG5pcXVlIGZvciB0cmFuc3BhcmVudCAoMjAwNykucGRm0hsPHB1XTlMuZGF0YU8RAoIAAAAAAoIAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2Seh9CdXJjaGV0dC1Db29wZXItS3JpcyMyRDIyMTAucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALSIQw4b9mVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIQnVyY2hldHQAEAAIAADBNH5dAAAAEQAIAADDh0PpAAAAAQAQAC2SegAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QnVyY2hldHQ6QnVyY2hldHQtQ29vcGVyLUtyaXMjMkQyMjEwLnBkZgAADgDIAGMAQgB1AHIAYwBoAGUAdAB0AC0AQwBvAG8AcABlAHIALQBLAHIAaQBzAGgAbgBhAG0AdQByAHQAaABpACAALQAgAEwAbwB3AGUAcgBpAG4AZwAgAGEAIABzAHQAYQB0AGkAYwAgAG8AcAB0AGkAbQBpAHoAYQB0AGkAbwBuACAAdABlAGMAaABuAGkAcQB1AGUAIABmAG8AcgAgAHQAcgBhAG4AcwBwAGEAcgBlAG4AdAAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAIBVc2Vycy9qZXJlbXkvUGFwZXJzL0J1cmNoZXR0L0J1cmNoZXR0LUNvb3Blci1LcmlzaG5hbXVydGhpIC0gTG93ZXJpbmcgYSBzdGF0aWMgb3B0aW1pemF0aW9uIHRlY2huaXF1ZSBmb3IgdHJhbnNwYXJlbnQgKDIwMDcpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEmASsBMwO5A7sDwAPJA9QD2APmA+0D9gP7A/4AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAECw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1244381.1244393}}

@inproceedings{Swadi:A-monadic:2006,
	Address = {New York, NY, USA},
	Author = {Kedar Swadi and Walid Taha and Oleg Kiselyov and Emir Pasalic},
	Booktitle = {PEPM '06: Proceedings of the 2006 ACM SIGPLAN symposium on Partial evaluation and semantics-based program manipulation},
	Date-Added = {2007-12-22 20:10:38 -0500},
	Date-Modified = {2008-01-14 01:37:22 -0500},
	Doi = {http://doi.acm.org/10.1145/1111542.1111570},
	Isbn = {1-59593-196-1},
	Keywords = {monads, optimization},
	Local-Url = {file://localhost/Users/jeremy/Papers/Swadi/Swadi-Taha-Kiselyov%20-%20A%20monadic%20approach%20for%20avoiding%20code%20duplication%20(2006).pdf},
	Location = {Charleston, South Carolina},
	Pages = {160--169},
	Publisher = {ACM},
	Title = {A monadic approach for avoiding code duplication when staging memoized functions},
	Year = {2006},
	Abstract = {Building program generators that do not duplicate generated code can be challenging. At the same time, code duplication can easily increase both generation time and runtime of generated programs by an exponential factor. We identify an instance of this problem that can arise when memoized functions are staged. Without addressing this problem, it would be impossible to effectively stage dynamic programming algorithms. Intuitively, direct staging undoes the effect of memoization. To solve this problem once and for all, and for any function that uses memoization, we propose a staged monadic combinator library. Experimental results confirm that the library works as expected. Preliminary results also indicate that the library is useful even when memoization is not used.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGQuLi8uLi9QYXBlcnMvU3dhZGkvU3dhZGktVGFoYS1LaXNlbHlvdiAtIEEgbW9uYWRpYyBhcHByb2FjaCBmb3IgYXZvaWRpbmcgY29kZSBkdXBsaWNhdGlvbiAoMjAwNikucGRm0hsPHB1XTlMuZGF0YU8RAkQAAAAAAkQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2Sjh9Td2FkaS1UYWhhLUtpc2VseW92ICMyRDkyOEMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZKMw5MhP1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAFU3dhZGkAABAACAAAwTR+XQAAABEACAAAw5NnjwAAAAEAEAAtko4ALZE/AANHrAAAa9gAAgA+T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlN3YWRpOlN3YWRpLVRhaGEtS2lzZWx5b3YgIzJEOTI4Qy5wZGYADgCkAFEAUwB3AGEAZABpAC0AVABhAGgAYQAtAEsAaQBzAGUAbAB5AG8AdgAgAC0AIABBACAAbQBvAG4AYQBkAGkAYwAgAGEAcABwAHIAbwBhAGMAaAAgAGYAbwByACAAYQB2AG8AaQBkAGkAbgBnACAAYwBvAGQAZQAgAGQAdQBwAGwAaQBjAGEAdABpAG8AbgAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGtVc2Vycy9qZXJlbXkvUGFwZXJzL1N3YWRpL1N3YWRpLVRhaGEtS2lzZWx5b3YgLSBBIG1vbmFkaWMgYXBwcm9hY2ggZm9yIGF2b2lkaW5nIGNvZGUgZHVwbGljYXRpb24gKDIwMDYpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBEQEWAR4DZgNoA20DdgOBA4UDkwOaA6MDqAOrAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA7g=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1111542.1111570}}

@inproceedings{Hutton:Fold:1998,
	Address = {New York, NY, USA},
	Author = {Graham Hutton},
	Booktitle = {ICFP '98: Proceedings of the third ACM SIGPLAN international conference on Functional programming},
	Date-Added = {2007-12-22 20:08:57 -0500},
	Date-Modified = {2007-12-22 20:11:26 -0500},
	Doi = {http://doi.acm.org/10.1145/289423.289457},
	Isbn = {1-58113-024-4},
	Local-Url = {file://localhost/Users/jeremy/Papers/Hutton/Hutton%20-%20Fold%20and%20unfold%20for%20program%20semantics%20(1998).pdf},
	Location = {Baltimore, Maryland, United States},
	Pages = {280--288},
	Publisher = {ACM},
	Title = {Fold and unfold for program semantics},
	Year = {1998},
	Abstract = {In this paper we explain how recursion operators can be used to structure and reason about program semantics within a functional language. In particular, we show how the recursion operator fold can be used to structure denotational semantics, how the dual recursion operator unfold can be used to structure operational semantics, and how algebraic properties of these operators can be used to reason about program semantics. The techniques are explained with the aid of two main examples, the first concerning arithmetic expressions, and the second concerning Milner's concurrent language CCS. The aim of the paper is to give functional programmers new insights into recursion operators, program semantics, and the relationships between them.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE0uLi8uLi9QYXBlcnMvSHV0dG9uL0h1dHRvbiAtIEZvbGQgYW5kIHVuZm9sZCBmb3IgcHJvZ3JhbSBzZW1hbnRpY3MgKDE5OTgpLnBkZtIbDxwdV05TLmRhdGFPEQH+AAAAAAH+AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtkmAfSHV0dG9uIC0gRm9sZCBhbmQgdW4jMkQ5MjVFLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC2SXsOTH+FQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABkh1dHRvbgAQAAgAAME0fl0AAAARAAgAAMOTZjEAAAABABAALZJgAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpIdXR0b246SHV0dG9uIC0gRm9sZCBhbmQgdW4jMkQ5MjVFLnBkZgAADgB0ADkASAB1AHQAdABvAG4AIAAtACAARgBvAGwAZAAgAGEAbgBkACAAdQBuAGYAbwBsAGQAIABmAG8AcgAgAHAAcgBvAGcAcgBhAG0AIABzAGUAbQBhAG4AdABpAGMAcwAgACgAMQA5ADkAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFRVc2Vycy9qZXJlbXkvUGFwZXJzL0h1dHRvbi9IdXR0b24gLSBGb2xkIGFuZCB1bmZvbGQgZm9yIHByb2dyYW0gc2VtYW50aWNzICgxOTk4KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA+gD/AQcDCQMLAxADGQMkAygDNgM9A0YDSwNOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA1s=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/289423.289457}}

@article{Paakki:Attribute:1995,
	Address = {New York, NY, USA},
	Author = {Jukka Paakki},
	Date-Added = {2007-12-22 20:08:48 -0500},
	Date-Modified = {2008-01-14 01:38:24 -0500},
	Doi = {http://doi.acm.org/10.1145/210376.197409},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Keywords = {attribute grammars},
	Local-Url = {file://localhost/Users/jeremy/Papers/Paakki/Paakki%20-%20Attribute%20grammar%20paradigms---a%20high-level%20methodology%20(1995).pdf},
	Number = {2},
	Pages = {196--255},
	Publisher = {ACM},
	Title = {Attribute grammar paradigms---a high-level methodology in language implementation},
	Volume = {27},
	Year = {1995},
	Abstract = {Attribute grammars are a formalism for specifying programming languages. They have been applied to a great number of systems automatically producing language implementations from their specifications. The systems and their specification languages can be evaluated and classified according to their level of application support, linguistic characteristics, and degree of automation.A survey of attribute grammar-based specification languages is given. The modern advanced specification languages extend the core attribute grammar model with concepts and primitives from established programming paradigms. The main ideas behind the developed attribute grammar paradigms are discussed, and representative specification languages are presented with a common example grammar. The presentation is founded on mapping elements of attribute grammars to their counterparts in programming languages. This methodology of integrating two problem-solving disciplines together is explored with a classification of the paradigms into structured, modular, object-oriented, logic, and functional attribute grammars. The taxonomy is complemented by introducing approaches based on an implicit parallel or incremental attribute evaluation paradigm.  },
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEF4uLi8uLi9QYXBlcnMvUGFha2tpL1BhYWtraSAtIEF0dHJpYnV0ZSBncmFtbWFyIHBhcmFkaWdtcy0tLWEgaGlnaC1sZXZlbCBtZXRob2RvbG9neSAoMTk5NSkucGRm0hsPHB1XTlMuZGF0YU8RAjIAAAAAAjIAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2ShR9QYWFra2kgLSBBdHRyaWJ1dGUgZyMyRDkyODIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZKCw5MhH1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGUGFha2tpABAACAAAwTR+XQAAABEACAAAw5NnbwAAAAEAEAAtkoUALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlBhYWtraTpQYWFra2kgLSBBdHRyaWJ1dGUgZyMyRDkyODIucGRmAAAOAJYASgBQAGEAYQBrAGsAaQAgAC0AIABBAHQAdAByAGkAYgB1AHQAZQAgAGcAcgBhAG0AbQBhAHIAIABwAGEAcgBhAGQAaQBnAG0AcwAtAC0ALQBhACAAaABpAGcAaAAtAGwAZQB2AGUAbAAgAG0AZQB0AGgAbwBkAG8AbABvAGcAeQAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGVVc2Vycy9qZXJlbXkvUGFwZXJzL1BhYWtraS9QYWFra2kgLSBBdHRyaWJ1dGUgZ3JhbW1hciBwYXJhZGlnbXMtLS1hIGhpZ2gtbGV2ZWwgbWV0aG9kb2xvZ3kgKDE5OTUpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBCwEQARgDTgNQA1UDXgNpA20DewOCA4sDkAOTAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA6A=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/210376.197409}}

@inproceedings{Gibbons:Design:2006,
	Address = {New York, NY, USA},
	Author = {Jeremy Gibbons},
	Booktitle = {WGP '06: Proceedings of the 2006 ACM SIGPLAN workshop on Generic programming},
	Date-Added = {2007-12-22 20:06:01 -0500},
	Date-Modified = {2007-12-22 20:08:02 -0500},
	Doi = {http://doi.acm.org/10.1145/1159861.1159863},
	Isbn = {1-59593-492-6},
	Local-Url = {file://localhost/Users/jeremy/Papers/Gibbons/Gibbons%20-%20Design%20patterns%20as%20higher-order%20datatype-generic%20programs%20(2006).pdf},
	Location = {Portland, Oregon, USA},
	Pages = {1--12},
	Publisher = {ACM},
	Title = {Design patterns as higher-order datatype-generic programs},
	Year = {2006},
	Abstract = {Design patterns are reusable abstractions in object-oriented software. However, using current mainstream programming languages, these elements can only be expressed extra-linguistically: as prose, pictures, and prototypes. We believe that this is not inherent in the patterns themselves, but evidence of a lack of expressivity in the languages of today. We expect that, in the languages of the future, the code parts of design patterns will be expressible as reusable library components. Indeed, we claim that the languages of tomorrow will suffice; the future is not far away. All that is needed, in addition to commonly-available features, are higher-order and datatype-generic constructs; these features are already or nearly available now. We argue the case by presenting higher-order datatype-generic programs capturing ORIGAMI, a small suite of patterns for recursive data structures.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGMuLi8uLi9QYXBlcnMvR2liYm9ucy9HaWJib25zIC0gRGVzaWduIHBhdHRlcm5zIGFzIGhpZ2hlci1vcmRlciBkYXRhdHlwZS1nZW5lcmljIHByb2dyYW1zICgyMDA2KS5wZGbSGw8cHVdOUy5kYXRhTxECQAAAAAACQAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZI8H0dpYmJvbnMgLSBEZXNpZ24gcGF0IzJEOTIzOS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkjnDkx8XUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdHaWJib25zAAAQAAgAAME0fl0AAAARAAgAAMOTZWcAAAABABAALZI8AC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpHaWJib25zOkdpYmJvbnMgLSBEZXNpZ24gcGF0IzJEOTIzOS5wZGYADgCeAE4ARwBpAGIAYgBvAG4AcwAgAC0AIABEAGUAcwBpAGcAbgAgAHAAYQB0AHQAZQByAG4AcwAgAGEAcwAgAGgAaQBnAGgAZQByAC0AbwByAGQAZQByACAAZABhAHQAYQB0AHkAcABlAC0AZwBlAG4AZQByAGkAYwAgAHAAcgBvAGcAcgBhAG0AcwAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGpVc2Vycy9qZXJlbXkvUGFwZXJzL0dpYmJvbnMvR2liYm9ucyAtIERlc2lnbiBwYXR0ZXJucyBhcyBoaWdoZXItb3JkZXIgZGF0YXR5cGUtZ2VuZXJpYyBwcm9ncmFtcyAoMjAwNikucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARABFQEdA2EDYwNoA3EDfAOAA44DlQOeA6MDpgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOz},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1159861.1159863}}

@inproceedings{Turbak:Cycle:2001,
	Address = {New York, NY, USA},
	Author = {Franklyn Turbak and J. B. Wells},
	Booktitle = {PPDP '01: Proceedings of the 3rd ACM SIGPLAN international conference on Principles and practice of declarative programming},
	Date-Added = {2007-12-22 20:02:35 -0500},
	Date-Modified = {2007-12-22 20:08:24 -0500},
	Doi = {http://doi.acm.org/10.1145/773184.773200},
	Isbn = {1-58113-388-X},
	Local-Url = {file://localhost/Users/jeremy/Papers/Turbak/Turbak-Wells%20-%20Cycle%20therapy%20a%20prescription%20for%20fold%20and%20unfold%20(2001).pdf},
	Location = {Florence, Italy},
	Pages = {137--149},
	Publisher = {ACM},
	Title = {Cycle therapy: a prescription for fold and unfold on regular trees},
	Year = {2001},
	Abstract = {Cyclic data structures can be tricky to create and manipulate in declarative programming languages. In a declarative setting, a natural way to view cyclic structures is as denoting regular trees, those trees which may be infinite but have only a finite number of distinct subtrees. This paper shows how to implement the unfold (anamorphism) operator in both eager and lazy languages so as to create cyclic structures when the result is a regular tree as opposed to merely infinite lazy structures. The usual fold (catamorphism) operator when used with a strict combining function on any infinite tree yields an undefined result. As an alternative, this paper defines and show how to implement a cycfold operator with more useful semantics when used with a strict function on cyclic structures representing regular trees. This paper also introduces an abstract data type (cycamores) to simplify the use of cyclic structures representing regular trees in both eager and lazy languages. Implementions of cycamores in both SML and Haskell are presented.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEF4uLi8uLi9QYXBlcnMvVHVyYmFrL1R1cmJhay1XZWxscyAtIEN5Y2xlIHRoZXJhcHkgYSBwcmVzY3JpcHRpb24gZm9yIGZvbGQgYW5kIHVuZm9sZCAoMjAwMSkucGRm0hsPHB1XTlMuZGF0YU8RAjIAAAAAAjIAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2SAx9UdXJiYWstV2VsbHMgLSBDeWNsZSMyRDkyMDEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZIBw5MeEFBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGVHVyYmFrABAACAAAwTR+XQAAABEACAAAw5NkYAAAAAEAEAAtkgMALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlR1cmJhazpUdXJiYWstV2VsbHMgLSBDeWNsZSMyRDkyMDEucGRmAAAOAJYASgBUAHUAcgBiAGEAawAtAFcAZQBsAGwAcwAgAC0AIABDAHkAYwBsAGUAIAB0AGgAZQByAGEAcAB5ACAAYQAgAHAAcgBlAHMAYwByAGkAcAB0AGkAbwBuACAAZgBvAHIAIABmAG8AbABkACAAYQBuAGQAIAB1AG4AZgBvAGwAZAAgACgAMgAwADAAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGVVc2Vycy9qZXJlbXkvUGFwZXJzL1R1cmJhay9UdXJiYWstV2VsbHMgLSBDeWNsZSB0aGVyYXB5IGEgcHJlc2NyaXB0aW9uIGZvciBmb2xkIGFuZCB1bmZvbGQgKDIwMDEpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBCwEQARgDTgNQA1UDXgNpA20DewOCA4sDkAOTAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA6A=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/773184.773200}}

@article{Hudak:Conception:1989,
	Address = {New York, NY, USA},
	Author = {Paul Hudak},
	Date-Added = {2007-12-22 19:56:05 -0500},
	Date-Modified = {2008-01-02 18:46:01 -0500},
	Doi = {http://doi.acm.org/10.1145/72551.72554},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Keywords = {history of computing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Hudak/Hudak%20-%20Conception,%20evolution,%20and%20application%20of%20functional%20programming%20(1989).pdf},
	Number = {3},
	Pages = {359--411},
	Publisher = {ACM},
	Rating = {5},
	Read = {Yes},
	Title = {Conception, evolution, and application of functional programming languages},
	Volume = {21},
	Year = {1989},
	Abstract = {The foundations of functional programming languages are examined from both historical and technical perspectives. Their evolution is traced through several critical periods: early work on lambda calculus and combinatory calculus, Lisp, Iswim, FP, ML, and modern functional languages such as Miranda1 and Haskell. The fundamental premises on which the functional programming methodology stands are critically analyzed with respect to philosophical, theoretical, and pragmatic concerns. Particular attention is paid to the main features that characterize modern functional languages: higher-order functions, lazy evaluation, equations and pattern matching, strong static typing and type inference, and data abstraction. In addition, current research areas---such as parallelism, nondeterminism, input/output, and state-oriented computations---are examined with the goal of predicting the future development and application of functional languages.},
	Annote = {Tremendously useful. Quickly moves on from Lisp, and also points out how Lisp isn't really functional so much as a major influence on functional languages. Very valuable for its lucid introduction to lambda calculus basics, including typed lambda calculi. Distinguishes between normal-order reduction and its specific implementation as lazy evaluation. Argues strongly for lazy evaluation being practically useful as well as theoretically. Addresses annotated functional languages (for parallelism or the like) as "parafunctional languages"; also touches briefly on dataflow languages and machines and mentions functional-logic programming in passing as an appealing but at the time not really very viable approach.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGYuLi8uLi9QYXBlcnMvSHVkYWsvSHVkYWsgLSBDb25jZXB0aW9uLCBldm9sdXRpb24sIGFuZCBhcHBsaWNhdGlvbiBvZiBmdW5jdGlvbmFsIHByb2dyYW1taW5nICgxOTg5KS5wZGbSGw8cHVdOUy5kYXRhTxECSgAAAAACSgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZF5H0h1ZGFrIC0gQ29uY2VwdGlvbiwgIzI5Rjg3Qi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp+HsAAAAAAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVIdWRhawAAEAAIAADBNH5dAAAAEQAIAAAAAAAAAAAAAQAQAC2ReQAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6SHVkYWs6SHVkYWsgLSBDb25jZXB0aW9uLCAjMjlGODdCLnBkZgAOAKgAUwBIAHUAZABhAGsAIAAtACAAQwBvAG4AYwBlAHAAdABpAG8AbgAsACAAZQB2AG8AbAB1AHQAaQBvAG4ALAAgAGEAbgBkACAAYQBwAHAAbABpAGMAYQB0AGkAbwBuACAAbwBmACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMQA5ADgAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG1Vc2Vycy9qZXJlbXkvUGFwZXJzL0h1ZGFrL0h1ZGFrIC0gQ29uY2VwdGlvbiwgZXZvbHV0aW9uLCBhbmQgYXBwbGljYXRpb24gb2YgZnVuY3Rpb25hbCBwcm9ncmFtbWluZyAoMTk4OSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgETARgBIANuA3ADdQN+A4kDjQObA6IDqwOwA7MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADwA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/72551.72554}}

@inproceedings{Wadler:Monads:1995,
	Address = {London, UK},
	Author = {Wadler, Philip},
	Booktitle = {Advanced Functional Programming},
	Date-Added = {2007-12-20 19:50:42 -0500},
	Date-Modified = {2007-12-22 19:54:28 -0500},
	Editor = {Jeuring, Johan and Meijer, Erik},
	Keywords = {monads, input-output},
	Local-Url = {file://localhost/Users/jeremy/Papers/Wadler/Wadler%20-%20Monads%20for%20functional%20programming%20(1995).pdf},
	Month = {May},
	Pages = {24--52},
	Publisher = {Springer-Verlag},
	Rating = {3},
	Read = {Yes},
	Series = {Lecture Notes in Computer Science},
	Title = {Monads for functional programming},
	Url = {http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf},
	Volume = {925},
	Year = {1995},
	Abstract = {The use of monads to structure functional programs is described. Moands provide a convenient framework for simulating efects found in other languages, such as global state, exception handling, output, or non-determinism. Three case studies are looked at in detail: how monads ease the modification of a simple evaluator; how monads act as the basis of a datatype of arrays subject to in-place update; and how monads can be used to build parsers.},
	Annote = {Opens with a very lucid discussion of pure versus impure: pure === lambda calculus (easy to reason about), impure === lambda calculus + effects (sometimes enables more compact expression). Shows how monads enable simulation of effects while retaining purity, and derives the monad laws without reference to category theory.

Also gives a good high-level overview of what a pure functional program is (a set of equations), and so the good and bad of being pure: all data flow is (painfully) explicit. 

Raises an interesting question for compile-time optimization: just because we can perform an optimization, should we? What if a program's feasibility depends on the use of that optimization? Is it then time to migrate that optimization from being the compiler's responsibility to the programmer's/language's? When do we cross the line from optimization and simple improvement to a real, marked change?},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEkuLi8uLi9QYXBlcnMvV2FkbGVyL1dhZGxlciAtIE1vbmFkcyBmb3IgZnVuY3Rpb25hbCBwcm9ncmFtbWluZyAoMTk5NSkucGRm0hsPHB1XTlMuZGF0YU8RAfIAAAAAAfIAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2ReB9XYWRsZXIgLSBNb25hZHMgZm9yICMyOUY4OTUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKfiVAAAAAAAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGV2FkbGVyABAACAAAwTR+XQAAABEACAAAAAAAAAAAAAEAEAAtkXgALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOldhZGxlcjpXYWRsZXIgLSBNb25hZHMgZm9yICMyOUY4OTUucGRmAAAOAGwANQBXAGEAZABsAGUAcgAgAC0AIABNAG8AbgBhAGQAcwAgAGYAbwByACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFBVc2Vycy9qZXJlbXkvUGFwZXJzL1dhZGxlci9XYWRsZXIgLSBNb25hZHMgZm9yIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgKDE5OTUpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD2APsBAwL5AvsDAAMJAxQDGAMmAy0DNgM7Az4AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADSw==},
	Bdsk-Url-1 = {http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf}}

@book{Cooper:Engineering:2004,
	Address = {San Francisco},
	Author = {Cooper, Keith D. and Torczon, Linda},
	Date-Added = {2007-12-15 17:09:56 -0500},
	Date-Modified = {2008-02-10 11:14:27 -0500},
	Keywords = {compilation},
	Publisher = {Morgan Kaufmann Publishers},
	Rating = {3},
	Read = {Yes},
	Title = {Engineering a Compiler},
	Year = {2004}}

@book{Scott:Programming:2006,
	Address = {San Francisco},
	Author = {Scott, Michael L.},
	Date-Added = {2007-12-15 17:03:52 -0500},
	Date-Modified = {2008-04-03 12:58:15 -0400},
	Edition = {Second},
	Publisher = {Morgan Kaufmann Publishers},
	Title = {Programming Language Pragmatics},
	Year = {2006}}

@inproceedings{Hudak:A-history:2007,
	Address = {New York},
	Author = {Paul Hudak and John Hughes and Peyton Jones, Simon and Philip Wadler},
	Booktitle = {HOPL III: Proceedings of the third ACM SIGPLAN conference on History of programming languages},
	Date-Added = {2007-12-13 14:58:46 -0500},
	Date-Modified = {2007-12-22 19:54:28 -0500},
	Doi = {http://doi.acm.org/10.1145/1238844.1238856},
	Isbn = {978-1-59593-766-X},
	Keywords = {history of computing, haskell},
	Local-Url = {file://localhost/Users/jeremy/Papers/Hudak/Hudak-Hughes-Peyton%20Jones%20-%20A%20history%20of%20%7BH%7Daskell%20being%20lazy%20with%20(2007).pdf},
	Location = {San Diego, California},
	Pages = {12-1--12-55},
	Publisher = {ACM},
	Rating = {4},
	Read = {Yes},
	Title = {A history of {H}askell: being lazy with class},
	Year = {2007},
	Abstract = {This paper describes the history of Haskell, including its genesis and principles, technical contributions, implementations and tools, and applications and impact.},
	Annote = {Its discussion of implementations and history is particularly helpful for orienting one to Haskell, since there are a lot of compiler/interpreter hangers-on and a lot of history that I haven't seen anywhere else. The section towards the end on Haskell's influence is also very interesting: functional-logic languages, constraint-based programming, functional reactive programming. Neat stuff.

Also includes a concise introduction to Haskell I/O before and after monads.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGAuLi8uLi9QYXBlcnMvSHVkYWsvSHVkYWstSHVnaGVzLVBleXRvbiBKb25lcyAtIEEgaGlzdG9yeSBvZiB7SH1hc2tlbGwgYmVpbmcgbGF6eSB3aXRoICgyMDA3KS5wZGbSGw8cHVdOUy5kYXRhTxECOAAAAAACOAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZF5H0h1ZGFrLUh1Z2hlcy1QZXl0b24gIzI5Rjg3Qy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp+HwAAAAAAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVIdWRhawAAEAAIAADBNH5dAAAAEQAIAAAAAAAAAAAAAQAQAC2ReQAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6SHVkYWs6SHVkYWstSHVnaGVzLVBleXRvbiAjMjlGODdDLnBkZgAOAJwATQBIAHUAZABhAGsALQBIAHUAZwBoAGUAcwAtAFAAZQB5AHQAbwBuACAASgBvAG4AZQBzACAALQAgAEEAIABoAGkAcwB0AG8AcgB5ACAAbwBmACAAewBIAH0AYQBzAGsAZQBsAGwAIABiAGUAaQBuAGcAIABsAGEAegB5ACAAdwBpAHQAaAAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGdVc2Vycy9qZXJlbXkvUGFwZXJzL0h1ZGFrL0h1ZGFrLUh1Z2hlcy1QZXl0b24gSm9uZXMgLSBBIGhpc3Rvcnkgb2Yge0h9YXNrZWxsIGJlaW5nIGxhenkgd2l0aCAoMjAwNykucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgENARIBGgNWA1gDXQNmA3EDdQODA4oDkwOYA5sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1238844.1238856}}

@article{Wadler:Fixing:1987,
	Author = {Philip Wadler},
	Date-Added = {2007-12-13 14:15:18 -0500},
	Date-Modified = {2007-12-22 19:54:28 -0500},
	Journal = {Software Practice and Experience},
	Keywords = {space leak, garbage collection, functional languages, lazy evaluation},
	Local-Url = {file://localhost/Users/jeremy/Papers/Wadler/Wadler%20-%20Fixing%20some%20space%20leaks%20with%20(1987).pdf},
	Month = {September},
	Number = {17(9)},
	Pages = {595-608},
	Rating = {3},
	Read = {Yes},
	Title = {Fixing some space leaks with a garbage collector},
	Url = {http://www.research.avayalabs.com/user/wadler/papers/leak/leak.ps},
	Year = {1987},
	Abstract = {Some functional programs may use more space than would be expected. A modification to the garbage collector is suggested which solves this problem in some cases. Related work is discussed.},
	Annote = {Proposes having the garbage collector perform limited evaluation to eliminate a certain class of space leaks involving tuples and pattern-matched where clauses (as allowed in Miranda and Haskell). Contrasts to a more general but more obnoxious solution of forcing programmers to insert parallelism annotations.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEQuLi8uLi9QYXBlcnMvV2FkbGVyL1dhZGxlciAtIEZpeGluZyBzb21lIHNwYWNlIGxlYWtzIHdpdGggKDE5ODcpLnBkZtIbDxwdV05TLmRhdGFPEQHkAAAAAAHkAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtkXgfV2FkbGVyIC0gRml4aW5nIHNvbWUjMkM3NzdCLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACx3e8NqGCgAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABldhZGxlcgAQAAgAAME0fl0AAAARAAgAAMNqXngAAAABABAALZF4AC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpXYWRsZXI6V2FkbGVyIC0gRml4aW5nIHNvbWUjMkM3NzdCLnBkZgAADgBiADAAVwBhAGQAbABlAHIAIAAtACAARgBpAHgAaQBuAGcAIABzAG8AbQBlACAAcwBwAGEAYwBlACAAbABlAGEAawBzACAAdwBpAHQAaAAgACgAMQA5ADgANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAEtVc2Vycy9qZXJlbXkvUGFwZXJzL1dhZGxlci9XYWRsZXIgLSBGaXhpbmcgc29tZSBzcGFjZSBsZWFrcyB3aXRoICgxOTg3KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPEA9gD+AuYC6ALtAvYDAQMFAxMDGgMjAygDKwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAM4},
	Bdsk-Url-1 = {http://www.research.avayalabs.com/user/wadler/papers/leak/leak.ps}}

@inproceedings{Peyton-Jones:Tackling:2000,
	Author = {Peyton Jones, Simon L.},
	Booktitle = {2000 Marktoberdorf Summer School},
	Date-Added = {2007-12-12 09:58:16 -0500},
	Date-Modified = {2007-12-22 19:54:28 -0500},
	Keywords = {haskell, monads, input-output, foreign-function interface, lazy evaluation},
	Local-Url = {file://localhost/Users/jeremy/Papers/Peyton%20Jones/Peyton%20Jones%20-%20Tackling%20the%20awkward%20squad%20monadic%20input-output,%20(2000).pdf},
	Rating = {3},
	Read = {Yes},
	Title = {Tackling the awkward squad: monadic input/output, concurrency, exceptions, and foreign-language calls in {H}askell},
	Url = {http://research.microsoft.com/Users/simonpj/papers/marktoberdorf.ps.gz},
	Year = {2000},
	Abstract = {Functional programming may be beautiful, but to write real applications we must grapple with awkward real-world issues: input/output, robustness, concurrency, and interfacing to programs written in other languages.

These lecture notes give an overview of the techniques that have been developed by the Haskell community to address these problems. I introduce various proposed extensions to Haskell along the way, and I offer an operational semantics that explains what these extensions mean.},
	Annote = {Provides a clear introduction to the I/O monad and why it is useful. Introduces briefly the stream model it replaced. Also discusses explicitly parallelizing Haskell via Concurrent Haskell, using IORefs and MVars, exceptions, and the Haskell foreign-function interface and related issues. Valuable as well for its step-by-step development of an operational semantics for these issues.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGQuLi8uLi9QYXBlcnMvUGV5dG9uIEpvbmVzL1BleXRvbiBKb25lcyAtIFRhY2tsaW5nIHRoZSBhd2t3YXJkIHNxdWFkIG1vbmFkaWMgaW5wdXQtb3V0cHV0LCAoMjAwMCkucGRm0hsPHB1XTlMuZGF0YU8RAkQAAAAAAkQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2Reh9QZXl0b24gSm9uZXMgLSBUYWNrbCMyOUY4OTgucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKfiYAAAAAAAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAMUGV5dG9uIEpvbmVzABAACAAAwTR+XQAAABEACAAAAAAAAAAAAAEAEAAtkXoALZE/AANHrAAAa9gAAgBFT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlBleXRvbiBKb25lczpQZXl0b24gSm9uZXMgLSBUYWNrbCMyOUY4OTgucGRmAAAOAJYASgBQAGUAeQB0AG8AbgAgAEoAbwBuAGUAcwAgAC0AIABUAGEAYwBrAGwAaQBuAGcAIAB0AGgAZQAgAGEAdwBrAHcAYQByAGQAIABzAHEAdQBhAGQAIABtAG8AbgBhAGQAaQBjACAAaQBuAHAAdQB0AC0AbwB1AHQAcAB1AHQALAAgACgAMgAwADAAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGtVc2Vycy9qZXJlbXkvUGFwZXJzL1BleXRvbiBKb25lcy9QZXl0b24gSm9uZXMgLSBUYWNrbGluZyB0aGUgYXdrd2FyZCBzcXVhZCBtb25hZGljIGlucHV0LW91dHB1dCwgKDIwMDApLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBEQEWAR4DZgNoA20DdgOBA4UDkwOaA6MDqAOrAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA7g=},
	Bdsk-Url-1 = {http://research.microsoft.com/Users/simonpj/papers/marktoberdorf.ps.gz}}

@comment{BibDesk Static Groups{
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>group name</key>
		<string>NCF Thesis</string>
		<key>keys</key>
		<string>Wyk:Context-aware:2007,Stoyan:Early:1984,Hovemeyer:Finding:2004,Barendregt:Types:1990,Bannerjee:Loop:1993,Grune:Parsing:2007,Herken:The-Universal:1995,Pottier:Menhir:2007,Bravenboer:Declarative:2006,Scott:Programming:2006,Kulkarni:Fast:2005,Pierce:Types:2002,Steele-Jr.:The-evolution:1993,Wadler:Monads:1995,Iverson:A-programming:1962,McPeak:Elkhound:2002,Paakki:Attribute:1995,McBride:Functional:2004,Olszewski:Churchs:2006,Peyton-Jones:Tackling:2000,Pager:The-lane:1973,Turner:Church:2006,Landin:The-next:1966,Turing:On-Computable:1937,Backus:Can-programming:1978,Cooper:Engineering:2004,Bravenboer:Concrete:2004,Sestoft:Demonstrating:2002,Lattner:LLVM:2002,Zima:Supercompilers:1991,Hines:Using:2005,Bravenboer:Preventing:2007,Pierce:Advanced:2005,Aho:Principles:1977,Aho:Compilers:1986,Aho:Compilers:2006,Cardelli:On-understanding:1985,Parr:ANTLR:1995,Visser:Scannerless:1997,Hennessy:Computer:2006,Wolfe:High-Performance:1996,Patterson:Computer:2007,Spector:Efficient:1988,Hudak:A-history:2007,Thompson:Type:1991,Hopcroft:Introduction:2007,Layer:Lisp:1991,Brand:Disambiguation:2002,Demaine:Cache-Oblivious:2002,Bannerjee:Loop:1994,Bannerjee:Dependence:1988,Muchnick:Advanced:1997,Barendregt:The-Lambda:1984,Hudak:Conception:1989,McCarthy:LISP:1980</string>
	</dict>
	<dict>
		<key>group name</key>
		<string>Textbooks</string>
		<key>keys</key>
		<string>Thompson:Type:1991,Scott:Programming:2006,Patterson:Computer:2007,Cooper:Engineering:2004,Hopcroft:Introduction:2007,Hennessy:Computer:2006,Barendregt:The-Lambda:1984,Muchnick:Advanced:1997</string>
	</dict>
</array>
</plist>
}}

@comment{BibDesk Smart Groups{
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>conditions</key>
		<array>
			<dict>
				<key>comparison</key>
				<integer>4</integer>
				<key>key</key>
				<string>Abstract</string>
				<key>value</key>
				<string></string>
				<key>version</key>
				<string>1</string>
			</dict>
		</array>
		<key>conjunction</key>
		<integer>0</integer>
		<key>group name</key>
		<string>Abstract missing</string>
	</dict>
	<dict>
		<key>conditions</key>
		<array>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Journal</string>
				<key>value</key>
				<string>csur</string>
				<key>version</key>
				<string>1</string>
			</dict>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Journal</string>
				<key>value</key>
				<string>comput. surv.</string>
				<key>version</key>
				<string>1</string>
			</dict>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Journal</string>
				<key>value</key>
				<string>survey</string>
				<key>version</key>
				<string>1</string>
			</dict>
		</array>
		<key>conjunction</key>
		<integer>1</integer>
		<key>group name</key>
		<string>CSUR</string>
	</dict>
	<dict>
		<key>conditions</key>
		<array>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Url</string>
				<key>value</key>
				<string>~</string>
				<key>version</key>
				<string>1</string>
			</dict>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Url</string>
				<key>value</key>
				<string>$</string>
				<key>version</key>
				<string>1</string>
			</dict>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Url</string>
				<key>value</key>
				<string>#</string>
				<key>version</key>
				<string>1</string>
			</dict>
		</array>
		<key>conjunction</key>
		<integer>1</integer>
		<key>group name</key>
		<string>Problem URLs</string>
	</dict>
	<dict>
		<key>conditions</key>
		<array>
			<dict>
				<key>comparison</key>
				<integer>4</integer>
				<key>key</key>
				<string>Read</string>
				<key>value</key>
				<string>No</string>
				<key>version</key>
				<string>1</string>
			</dict>
		</array>
		<key>conjunction</key>
		<integer>0</integer>
		<key>group name</key>
		<string>Unread</string>
	</dict>
</array>
</plist>
}}
