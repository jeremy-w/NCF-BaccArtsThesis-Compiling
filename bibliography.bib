
%% Created for jeremy at 2008-02-24 18:32:53 -0500 


%% Saved with string encoding Western (ASCII) 



@inproceedings{Hovemeyer:Finding:2004,
	Address = {New York, NY, USA},
	Author = {David Hovemeyer and William Pugh},
	Booktitle = {OOPSLA '04: Companion to the 19th annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications},
	Date-Added = {2008-02-24 18:11:09 -0500},
	Date-Modified = {2008-02-24 18:14:39 -0500},
	Doi = {http://doi.acm.org/10.1145/1028664.1028717},
	Isbn = {1-58113-833-4},
	Location = {Vancouver, BC, CANADA},
	Note = {{\em See \url{http://findbugs.sourceforge.net/}.}},
	Pages = {132--136},
	Publisher = {ACM},
	Title = {Finding Bugs Is Easy},
	Url = {http://findbugs.sourceforge.net/docs/oopsla2004.pdf},
	Year = {2004},
	Abstract = {Many techniques have been developed over the years to automatically find bugs in software. Often, these techniques rely on formal methods and sophisticated program analysis. While these techniques are valuable, they can be difficult to apply, and they aren't always effective in finding real bugs.<i>Bug patterns</i> are code idioms that are often errors. We have implemented automatic detectors for a variety of bug patterns found in Java programs. In this extended abstract<sup>1</sup>, we describe how we have used bug pattern detectors to find serious bugs in several widely used Java applications and libraries. We have found that the effort required to implement a bug pattern detector tends to be low, and that even extremely simple detectors find bugs in real applications.From our experience applying bug pattern detectors to real programs, we have drawn several interesting conclusions. First, we have found that even well tested code written by experts contains a surprising number of obvious bugs. Second, Java (and similar languages) have many language features and APIs which are prone to misuse. Finally, that simple automatic techniques can be effective at countering the impact of both ordinary mistakes and misunderstood language features.},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1028664.1028717}}

@mastersthesis{Lattner:LLVM:2002,
	Address = {Urbana, Ill., USA},
	Author = {Chris Lattner},
	Date-Added = {2008-02-24 18:00:35 -0500},
	Date-Modified = {2008-02-24 18:02:21 -0500},
	Month = {Dec},
	Note = {{\em See \url{http://llvm.cs.uiuc.edu}.}},
	School = {{Computer Science Dept., University of Illinois at Urbana-Champaign}},
	Title = {{LLVM: An Infrastructure for Multi-Stage Optimization}},
	Year = {2002}}

@book{Zima:Supercompilers:1991,
	Address = {Reading, Mass., USA},
	Author = {Zima, Hans and Barbara Chapman},
	Date-Added = {2008-02-24 17:48:41 -0500},
	Date-Modified = {2008-02-24 17:56:48 -0500},
	Publisher = {ACM Press/Addison-Wesley},
	Title = {Supercompilers for Parallel and Vector Machines},
	Year = {1991}}

@book{Wolfe:High-Performance:1996,
	Address = {Redwood City, Calif., USA},
	Author = {Wolfe, Michael R.},
	Date-Added = {2008-02-24 17:48:37 -0500},
	Date-Modified = {2008-02-24 17:55:04 -0500},
	Publisher = {Addison-Wesley},
	Title = {High-Performance Compilers for Parallel Computing},
	Year = {1996}}

@book{Bannerjee:Loop:1994,
	Address = {Boston, Mass., USA},
	Author = {Bannerjee, Utpal},
	Date-Added = {2008-02-24 17:48:34 -0500},
	Date-Modified = {2008-02-24 17:53:30 -0500},
	Publisher = {Kluwer Academic Publishers},
	Title = {Loop Parallelization},
	Year = {1994}}

@book{Bannerjee:Loop:1993,
	Address = {Boston, Mass., USA},
	Author = {Bannerjee, Utpal},
	Date-Added = {2008-02-24 17:48:28 -0500},
	Date-Modified = {2008-02-24 17:52:50 -0500},
	Publisher = {Kluwer Academic Publishers},
	Title = {Loop Transformations for Restructuring Compilers},
	Year = {1993}}

@book{Bannerjee:Dependence:1988,
	Address = {Boston, Mass., USA},
	Author = {Bannerjee, Utpal},
	Date-Added = {2008-02-24 17:48:06 -0500},
	Date-Modified = {2008-02-24 17:52:15 -0500},
	Publisher = {Kluwer Academic Publishers},
	Title = {Dependence Analysis for Supercomputing},
	Year = {1988}}

@book{Aho:Compilers:2006,
	Author = {Aho, Alfred V. and Sethi, Ravi and Ullman, Jeffrey D. and Lam, Monica S.},
	Date-Added = {2008-02-10 14:28:34 -0500},
	Date-Modified = {2008-02-10 14:37:19 -0500},
	Edition = {Second},
	Isbn = {978--0--321--48681--1},
	Month = {August},
	Note = {Also known as the ``Purple Dragon''},
	Publisher = {Addison-Wesley Higher Education},
	Title = {Compilers: {P}rinciples, Techniques, and Tools},
	Year = {2006}}

@article{Wadler:Fixing:1987,
	Author = {Philip Wadler},
	Date-Added = {2007-12-13 14:15:18 -0500},
	Date-Modified = {2007-12-22 19:54:28 -0500},
	Journal = {Software Practice and Experience},
	Keywords = {space leak, garbage collection, functional languages, lazy evaluation},
	Local-Url = {file://localhost/Users/jeremy/Papers/Wadler/Wadler%20-%20Fixing%20some%20space%20leaks%20with%20(1987).pdf},
	Month = {September},
	Number = {17(9)},
	Pages = {595-608},
	Rating = {3},
	Read = {Yes},
	Title = {Fixing some space leaks with a garbage collector},
	Url = {http://www.research.avayalabs.com/user/wadler/papers/leak/leak.ps},
	Year = {1987},
	Abstract = {Some functional programs may use more space than would be expected. A modification to the garbage collector is suggested which solves this problem in some cases. Related work is discussed.},
	Annote = {Proposes having the garbage collector perform limited evaluation to eliminate a certain class of space leaks involving tuples and pattern-matched where clauses (as allowed in Miranda and Haskell). Contrasts to a more general but more obnoxious solution of forcing programmers to insert parallelism annotations.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEQuLi8uLi9QYXBlcnMvV2FkbGVyL1dhZGxlciAtIEZpeGluZyBzb21lIHNwYWNlIGxlYWtzIHdpdGggKDE5ODcpLnBkZtIbDxwdV05TLmRhdGFPEQHkAAAAAAHkAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtkXgfV2FkbGVyIC0gRml4aW5nIHNvbWUjMkM3NzdCLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACx3e8NqGCgAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABldhZGxlcgAQAAgAAME0fl0AAAARAAgAAMNqXngAAAABABAALZF4AC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpXYWRsZXI6V2FkbGVyIC0gRml4aW5nIHNvbWUjMkM3NzdCLnBkZgAADgBiADAAVwBhAGQAbABlAHIAIAAtACAARgBpAHgAaQBuAGcAIABzAG8AbQBlACAAcwBwAGEAYwBlACAAbABlAGEAawBzACAAdwBpAHQAaAAgACgAMQA5ADgANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAEtVc2Vycy9qZXJlbXkvUGFwZXJzL1dhZGxlci9XYWRsZXIgLSBGaXhpbmcgc29tZSBzcGFjZSBsZWFrcyB3aXRoICgxOTg3KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPEA9gD+AuYC6ALtAvYDAQMFAxMDGgMjAygDKwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAM4},
	Bdsk-Url-1 = {http://www.research.avayalabs.com/user/wadler/papers/leak/leak.ps}}

@book{Grune:Parsing:2007,
	Author = {Grune, Dick and Jacobs, Ceriel J.\ H.},
	Date-Added = {2008-02-10 14:04:15 -0500},
	Date-Modified = {2008-02-10 14:08:47 -0500},
	Edition = {Second},
	Isbn = {978--0--387--20248--8},
	Keywords = {parsing},
	Note = {Complete first edition available online at \url{http://www.cs.vu.nl/$\sim$dick/PTAPG.html}},
	Publisher = {Spring-Verlag},
	Title = {Parsing Techniques: {A} Practical Guide},
	Year = {2007}}

@article{Parr:ANTLR:1995,
	Address = {New York, NY, USA},
	Author = {T. J. Parr and R. W. Quong},
	Date-Added = {2008-02-10 13:49:52 -0500},
	Date-Modified = {2008-02-10 14:10:28 -0500},
	Doi = {http://dx.doi.org/10.1002/spe.4380250705},
	Issn = {0038-0644},
	Journal = {Softw. Pract. Exper.},
	Keywords = {parsing},
	Note = {Current information on ANTLR is available from \url{http://www.antlr.org/}},
	Number = {7},
	Pages = {789--810},
	Publisher = {John Wiley \& Sons, Inc.},
	Title = {{ANTLR}: {A} predicated-{LL}($k$) parser generator},
	Url = {http://www.antlr.org/article/1055550346383/antlr.pdf},
	Volume = {25},
	Year = {1995},
	Abstract = {Despite the parsing power of LR/LALR algorithms, e.g. YACC, programmers often choose to write recursive-descent parsers by hand to obtain increased flexibility, better error handling, and ease of debugging. We introduce ANTLR, a public-domain parser generator that combines the flexibility of hand-coded parsing with the convenience of a parser generator, which is a component of PCCTS. ANTLR has many features that make it easier to use than other language tools. Most important, ANTLR provides predicates which let the programmer systematically direct the parse via arbitrary expressions using semantic and syntactic context; in practice, the use of predicates eliminates the need to hand-tweak the ANTLR output, even for difficult parsing problems. ANTLR also integrates the description of lexical and syntactic analysis, accepts LL(k) grammars for k > 1 with extended BNF notation, and can automatically generate abstract syntax trees.

ANTLR is widely used, with over 1000 registered industrial and academic users in 37 countries. It has been ported to many popular systems such as the PC, Macintosh, and a variety of UNIX platforms; a commercial C++ front-end has been developed as a result of one of our industrial collaborations.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFYuLi8uLi9QYXBlcnMvUGFyci9QYXJyLVF1b25nIC0gQU5UTFI6IEEgcHJlZGljYXRlZC1MTCgkayQpIHBhcnNlciBnZW5lcmF0b3IgKDE5OTUpLnBkZtIbDxwdV05TLmRhdGFPEQIaAAAAAAIaAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAwFAQfUGFyci1RdW9uZyAtIEFOVExSLyAjMzAxM0Y1LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAT9cPUslQAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABFBhcnIAEAAIAADBNH5dAAAAEQAIAADD1PikAAAAAQAQADAUBAAtkT8AA0esAABr2AACAD1PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6UGFycjpQYXJyLVF1b25nIC0gQU5UTFIvICMzMDEzRjUucGRmAAAOAIoARABQAGEAcgByAC0AUQB1AG8AbgBnACAALQAgAEEATgBUAEwAUgAvACAAQQAgAHAAcgBlAGQAaQBjAGEAdABlAGQALQBMAEwAKAAkAGsAJAApACAAcABhAHIAcwBlAHIAIABnAGUAbgBlAHIAYQB0AG8AcgAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF1Vc2Vycy9qZXJlbXkvUGFwZXJzL1BhcnIvUGFyci1RdW9uZyAtIEFOVExSOiBBIHByZWRpY2F0ZWQtTEwoJGskKSBwYXJzZXIgZ2VuZXJhdG9yICgxOTk1KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQMBCAEQAy4DMAM1Az4DSQNNA1sDYgNrA3ADcwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOA},
	Bdsk-Url-1 = {http://dx.doi.org/10.1002/spe.4380250705},
	Bdsk-Url-2 = {http://www.antlr.org/article/1055550346383/antlr.pdf}}

@manual{Pottier:Menhir:2007,
	Author = {Pottier, Fran{\c c}ois and R{\'e}gis-Gianis, Yann},
	Date-Added = {2008-02-10 13:29:59 -0500},
	Date-Modified = {2008-02-10 14:43:37 -0500},
	Keywords = {parsing},
	Month = {December},
	Organization = {INRIA},
	Title = {Menhir Reference Manual},
	Url = {http://cristal.inria.fr/~fpottier/menhir/},
	Year = {2007},
	Bdsk-Url-1 = {http://cristal.inria.fr/~fpottier/menhir/}}

@techreport{McPeak:Elkhound:2002,
	Address = {Berkeley, California, USA},
	Author = {McPeak, Scott},
	Date-Added = {2008-02-10 12:54:30 -0500},
	Date-Modified = {2008-02-10 14:43:23 -0500},
	Institution = {University of California, Berkeley},
	Keywords = {parsing},
	Month = {December},
	Number = {UCB/CSD--2--1214},
	Title = {Elkhound: {A} Fast, Practical {GLR} Parser Generator},
	Url = {http://www.cs.berkeley.edu/~smcpeak/elkhound/},
	Year = {2002},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFguLi8uLi9QYXBlcnMvTWNQZWFrL01jUGVhayAtIEVsa2hvdW5kOiBBIEZhc3QsIFByYWN0aWNhbCBHTFIgUGFyc2VyIEdlbmVyYXRvciAoMjAwMikucGRm0hsPHB1XTlMuZGF0YU8RAiAAAAAAAiAAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAADAS+B9NY1BlYWsgLSBFbGtob3VuZC8gQSMyRTdGRkQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALn/9w7BQaQAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGTWNQZWFrABAACAAAwTR+XQAAABEACAAAw7CWuQAAAAEAEAAwEvgALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOk1jUGVhazpNY1BlYWsgLSBFbGtob3VuZC8gQSMyRTdGRkQucGRmAAAOAIoARABNAGMAUABlAGEAawAgAC0AIABFAGwAawBoAG8AdQBuAGQALwAgAEEAIABGAGEAcwB0ACwAIABQAHIAYQBjAHQAaQBjAGEAbAAgAEcATABSACAAUABhAHIAcwBlAHIAIABHAGUAbgBlAHIAYQB0AG8AcgAgACgAMgAwADAAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF9Vc2Vycy9qZXJlbXkvUGFwZXJzL01jUGVhay9NY1BlYWsgLSBFbGtob3VuZDogQSBGYXN0LCBQcmFjdGljYWwgR0xSIFBhcnNlciBHZW5lcmF0b3IgKDIwMDIpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBBQEKARIDNgM4Az0DRgNRA1UDYwNqA3MDeAN7AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA4g=},
	Bdsk-Url-1 = {http://www.cs.berkeley.edu/~smcpeak/elkhound/}}

@book{Muchnick:Advanced:1997,
	Author = {Muchnick, Steven S.},
	Date-Added = {2008-02-10 11:11:29 -0500},
	Date-Modified = {2008-02-10 12:15:06 -0500},
	Isbn = {978--1-55860--320--4},
	Keywords = {compilation},
	Publisher = {Academic Press},
	Title = {Advanced Compiler Design and Implementation},
	Year = {1997}}

@book{Hopcroft:Introduction:2007,
	Author = {Hopcroft, John E. and Motwani, Rajeev and Ullman, Jeffrey D.},
	Date-Added = {2008-02-08 18:53:33 -0500},
	Date-Modified = {2008-02-10 14:43:14 -0500},
	Edition = {Third},
	Isbn = {978--0--23--146225--1},
	Month = {July},
	Publisher = {Addison-Wesley Higher Education},
	Title = {Introduction to Automata Theory, Languages, and Computation},
	Url = {http://infolab.stanford.edu/~ullman/ialc.html},
	Year = {2007},
	Bdsk-Url-1 = {http://infolab.stanford.edu/~ullman/ialc.html}}

@inproceedings{Pereira:Register:2006,
	Address = {Vienna, Austria},
	Author = {Pereira, Fernando Magno Quint{\~a}o and Palsberg, Jens},
	Booktitle = {Proceedings of FOSSACS'06},
	Date-Added = {2008-02-08 16:15:40 -0500},
	Date-Modified = {2008-02-08 16:20:12 -0500},
	Keywords = {compilation},
	Month = {March},
	Pages = {79--93},
	Publisher = {Springer-Verlag (LNCS 3921)},
	Series = {Foundations of Software Science and Computation Structures},
	Title = {Register Allocation after Classical {SSA} Elimination Is {NP}-Complete},
	Url = {http://www.cs.ucla.edu/~palsberg/paper/fossacs06.pdf},
	Year = {2006},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGYuLi8uLi9QYXBlcnMvUGVyZWlyYS9QZXJlaXJhLVBhbHNiZXJnIC0gUmVnaXN0ZXIgQWxsb2NhdGlvbiBhZnRlciBDbGFzc2ljYWwgU1NBIEVsaW1pbmF0aW9uICgyMDA2KS5wZGbSGw8cHVdOUy5kYXRhTxECSgAAAAACSgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAL/JjH1BlcmVpcmEtUGFsc2JlcmcgLSBSIzJGRjIzOS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv8jnD0jAuUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdQZXJlaXJhAAAQAAgAAME0fl0AAAARAAgAAMPSdn4AAAABABAAL/JjAC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpQZXJlaXJhOlBlcmVpcmEtUGFsc2JlcmcgLSBSIzJGRjIzOS5wZGYADgCkAFEAUABlAHIAZQBpAHIAYQAtAFAAYQBsAHMAYgBlAHIAZwAgAC0AIABSAGUAZwBpAHMAdABlAHIAIABBAGwAbABvAGMAYQB0AGkAbwBuACAAYQBmAHQAZQByACAAQwBsAGEAcwBzAGkAYwBhAGwAIABTAFMAQQAgAEUAbABpAG0AaQBuAGEAdABpAG8AbgAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG1Vc2Vycy9qZXJlbXkvUGFwZXJzL1BlcmVpcmEvUGVyZWlyYS1QYWxzYmVyZyAtIFJlZ2lzdGVyIEFsbG9jYXRpb24gYWZ0ZXIgQ2xhc3NpY2FsIFNTQSBFbGltaW5hdGlvbiAoMjAwNikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgETARgBIANuA3ADdQN+A4kDjQObA6IDqwOwA7MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADwA==},
	Bdsk-Url-1 = {http://www.cs.ucla.edu/~palsberg/paper/fossacs06.pdf}}

@inproceedings{Pereira:Register:2008,
	Address = {Tucson, Arizona, USA},
	Author = {Pereira, Fernando Magno Quint{\~a}o and Palsberg, Jens},
	Booktitle = {Proceedings of PLDI'08},
	Date-Added = {2008-02-08 15:24:30 -0500},
	Date-Modified = {2008-02-08 16:14:06 -0500},
	Keywords = {compilation},
	Month = {June},
	Note = {To appear},
	Series = {ACM SIGPLAN Conference on Programming Language Design and Implementation},
	Title = {Register Allocation by Puzzle Solving},
	Url = {http://www.cs.ucla.edu/~palsberg/paper/PereiraPalsberg08.pdf},
	Year = {2008},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFkuLi8uLi9QYXBlcnMvUGFsc2JlcmcvUGFsc2JlcmctUGVyZWlyYSAtIFJlZ2lzdGVyIEFsbG9jYXRpb24gYnkgUHV6emxlIFNvbHZpbmcgKDIwMDgpLnBkZtIbDxwdV05TLmRhdGFPEQIiAAAAAAIiAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAv8ZofUGFsc2JlcmctUGVyZWlyYSAtIFIjMkZGMERELnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC/w3cPSJJsAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAACFBhbHNiZXJnABAACAAAwTR+XQAAABEACAAAw9Jq6wAAAAEAEAAv8ZoALZE/AANHrAAAa9gAAgBBT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlBhbHNiZXJnOlBhbHNiZXJnLVBlcmVpcmEgLSBSIzJGRjBERC5wZGYAAA4AiABDAFAAYQBsAHMAYgBlAHIAZwAtAFAAZQByAGUAaQByAGEAIAAtACAAUgBlAGcAaQBzAHQAZQByACAAQQBsAGwAbwBjAGEAdABpAG8AbgAgAGIAeQAgAFAAdQB6AHoAbABlACAAUwBvAGwAdgBpAG4AZwAgACgAMgAwADAAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGBVc2Vycy9qZXJlbXkvUGFwZXJzL1BhbHNiZXJnL1BhbHNiZXJnLVBlcmVpcmEgLSBSZWdpc3RlciBBbGxvY2F0aW9uIGJ5IFB1enpsZSBTb2x2aW5nICgyMDA4KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBBgELARMDOQM7A0ADSQNUA1gDZgNtA3YDewN+AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA4s=},
	Bdsk-Url-1 = {http://www.cs.ucla.edu/~palsberg/paper/PereiraPalsberg08.pdf}}

@inproceedings{Hines:Using:2005,
	Address = {New York, NY, USA},
	Author = {Stephen Hines and Prasad Kulkarni and David Whalley and Jack Davidson},
	Booktitle = {EMSOFT '05: Proceedings of the 5th ACM international conference on Embedded software},
	Date-Added = {2008-02-04 20:41:39 -0500},
	Date-Modified = {2008-02-04 20:45:28 -0500},
	Doi = {http://doi.acm.org/10.1145/1086228.1086251},
	Isbn = {1-59593-091-4},
	Keywords = {optimization phase ordering},
	Location = {Jersey City, NJ, USA},
	Pages = {114--123},
	Publisher = {ACM},
	Title = {Using de-optimization to re-optimize code},
	Year = {2005},
	Abstract = {The nature of embedded systems development places a great deal of importance on meeting strict requirements in areas such as static code size, power consumption, and execution time. In order to meet these requirements, embedded developers frequently generate and tune assembly code for applications by hand, despite the disadvantages of coding at a low level. The phase ordering problem is a well-known problem affecting the design of optimizing compilers. Hand-tuned code is susceptible to an analogous problem to phase ordering due to the process of iterative refinement, but there has been little research in mitigating its effect on the quality of the generated code. This paper presents an extension of the VISTA framework for investigating the effect and potential benefit of performing de-optimization before re-optimizing assembly code. The design and implementation of algorithms for de-optimization of both loop-invariant code motion and register allocation, along with results of experiments regarding de-optimization and re-optimization of previously generated assembly code are also presented.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGAuLi8uLi9QYXBlcnMvSGluZXMvSGluZXMtS3Vsa2FybmktV2hhbGxleSAtIFVzaW5nIGRlLW9wdGltaXphdGlvbiB0byByZS1vcHRpbWl6ZSBjb2RlICgyMDA1KS5wZGbSGw8cHVdOUy5kYXRhTxECOAAAAAACOAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAL9j2H0hpbmVzLUt1bGthcm5pLVdoYWxsIzJGRDhFQy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv2OzDzSjwUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVIaW5lcwAAEAAIAADBNH5dAAAAEQAIAADDzW9AAAAAAQAQAC/Y9gAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6SGluZXM6SGluZXMtS3Vsa2FybmktV2hhbGwjMkZEOEVDLnBkZgAOAJwATQBIAGkAbgBlAHMALQBLAHUAbABrAGEAcgBuAGkALQBXAGgAYQBsAGwAZQB5ACAALQAgAFUAcwBpAG4AZwAgAGQAZQAtAG8AcAB0AGkAbQBpAHoAYQB0AGkAbwBuACAAdABvACAAcgBlAC0AbwBwAHQAaQBtAGkAegBlACAAYwBvAGQAZQAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGdVc2Vycy9qZXJlbXkvUGFwZXJzL0hpbmVzL0hpbmVzLUt1bGthcm5pLVdoYWxsZXkgLSBVc2luZyBkZS1vcHRpbWl6YXRpb24gdG8gcmUtb3B0aW1pemUgY29kZSAoMjAwNSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgENARIBGgNWA1gDXQNmA3EDdQODA4oDkwOYA5sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1086228.1086251}}

@inproceedings{Edwards:No-ifs-ands:2007,
	Address = {New York, NY, USA},
	Author = {Jonathan Edwards},
	Booktitle = {OOPSLA '07: Proceedings of the 22nd annual ACM SIGPLAN conference on Object oriented programming systems and applications},
	Date-Added = {2008-01-29 22:26:53 -0500},
	Date-Modified = {2008-01-29 22:29:55 -0500},
	Doi = {http://doi.acm.org/10.1145/1297027.1297075},
	Isbn = {978-1-59593-786-5},
	Keywords = {language design},
	Location = {Montreal, Quebec, Canada},
	Pages = {639--658},
	Publisher = {ACM},
	Title = {No ifs, ands, or buts: uncovering the simplicity of conditionals},
	Year = {2007},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFouLi8uLi9QYXBlcnMvRWR3YXJkcy9FZHdhcmRzIC0gTm8gaWZzLCBhbmRzLCBvciBidXRzOiB1bmNvdmVyaW5nIHRoZSBzaW1wbGljaXR5ICgyMDA3KS5wZGbSGw8cHVdOUy5kYXRhTxECJgAAAAACJgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAAL7JXH0Vkd2FyZHMgLSBObyBpZnMsIGFuIzJGQjI1Ni5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvslbDxVjPUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdFZHdhcmRzAAAQAAgAAME0fl0AAAARAAgAAMPFnx8AAAABABAAL7JXAC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpFZHdhcmRzOkVkd2FyZHMgLSBObyBpZnMsIGFuIzJGQjI1Ni5wZGYADgCMAEUARQBkAHcAYQByAGQAcwAgAC0AIABOAG8AIABpAGYAcwAsACAAYQBuAGQAcwAsACAAbwByACAAYgB1AHQAcwAvACAAdQBuAGMAbwB2AGUAcgBpAG4AZwAgAHQAaABlACAAcwBpAG0AcABsAGkAYwBpAHQAeQAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGFVc2Vycy9qZXJlbXkvUGFwZXJzL0Vkd2FyZHMvRWR3YXJkcyAtIE5vIGlmcywgYW5kcywgb3IgYnV0czogdW5jb3ZlcmluZyB0aGUgc2ltcGxpY2l0eSAoMjAwNykucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEHAQwBFAM+A0ADRQNOA1kDXQNrA3IDewOAA4MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1297027.1297075}}

@article{Pippenger:Pure:1997,
	Address = {New York, NY, USA},
	Author = {Nicholas Pippenger},
	Date-Added = {2008-01-19 10:30:22 -0500},
	Date-Modified = {2008-01-19 10:32:31 -0500},
	Doi = {http://doi.acm.org/10.1145/244795.244798},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Number = {2},
	Pages = {223--238},
	Publisher = {ACM},
	Title = {Pure versus impure Lisp},
	Volume = {19},
	Year = {1997},
	Annote = {Appears from the abstract that pure Lisp is strictly more powerful (in that it can compute faster) than impure Lisp when online operation, as in an interpreter, is required. Not sure how this affects interactive programs---probably the same difference remains. This is where the details would come in handy....},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEUuLi8uLi9QYXBlcnMvUGlwcGVuZ2VyL1BpcHBlbmdlciAtIFB1cmUgdmVyc3VzIGltcHVyZSBMaXNwICgxOTk3KS5wZGbSGw8cHVdOUy5kYXRhTxEB5gAAAAAB5gACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALuySH1BpcHBlbmdlciAtIFB1cmUgdmVyIzJFRUM4Qy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAu7IzDt4HrUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAlQaXBwZW5nZXIAABAACAAAwTR+XQAAABEACAAAw7fIOwAAAAEAEAAu7JIALZE/AANHrAAAa9gAAgBCT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlBpcHBlbmdlcjpQaXBwZW5nZXIgLSBQdXJlIHZlciMyRUVDOEMucGRmAA4AXgAuAFAAaQBwAHAAZQBuAGcAZQByACAALQAgAFAAdQByAGUAIAB2AGUAcgBzAHUAcwAgAGkAbQBwAHUAcgBlACAATABpAHMAcAAgACgAMQA5ADkANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAExVc2Vycy9qZXJlbXkvUGFwZXJzL1BpcHBlbmdlci9QaXBwZW5nZXIgLSBQdXJlIHZlcnN1cyBpbXB1cmUgTGlzcCAoMTk5NykucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPIA9wD/AukC6wLwAvkDBAMIAxYDHQMmAysDLgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAM7},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/244795.244798}}

@article{Wadler:Lazy:1996,
	Address = {New York, NY, USA},
	Author = {Philip Wadler},
	Date-Added = {2008-01-19 10:29:44 -0500},
	Date-Modified = {2008-01-19 10:29:46 -0500},
	Doi = {http://doi.acm.org/10.1145/234528.234738},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Number = {2},
	Pages = {318--320},
	Publisher = {ACM},
	Title = {Lazy versus strict},
	Volume = {28},
	Year = {1996},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEDouLi8uLi9QYXBlcnMvV2FkbGVyL1dhZGxlciAtIExhenkgdmVyc3VzIHN0cmljdCAoMTk5NikucGRm0hsPHB1XTlMuZGF0YU8RAcYAAAAAAcYAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2ReB9XYWRsZXIgLSBMYXp5IHZlcnN1cyMyRUVDODIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALuyCw7eBzVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGV2FkbGVyABAACAAAwTR+XQAAABEACAAAw7fIHQAAAAEAEAAtkXgALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOldhZGxlcjpXYWRsZXIgLSBMYXp5IHZlcnN1cyMyRUVDODIucGRmAAAOAE4AJgBXAGEAZABsAGUAcgAgAC0AIABMAGEAegB5ACAAdgBlAHIAcwB1AHMAIABzAHQAcgBpAGMAdAAgACgAMQA5ADkANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAEFVc2Vycy9qZXJlbXkvUGFwZXJzL1dhZGxlci9XYWRsZXIgLSBMYXp5IHZlcnN1cyBzdHJpY3QgKDE5OTYpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA5wDsAPQCvgLAAsUCzgLZAt0C6wLyAvsDAAMDAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAxA=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/234528.234738}}

@inproceedings{Bravenboer:Concrete:2004,
	Address = {New York, NY, USA},
	Author = {Martin Bravenboer and Eelco Visser},
	Booktitle = {OOPSLA '04: Proceedings of the 19th annual ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications},
	Date-Added = {2008-01-19 09:34:24 -0500},
	Date-Modified = {2008-01-19 09:38:17 -0500},
	Doi = {http://doi.acm.org/10.1145/1028976.1029007},
	Isbn = {1-58113-831-9},
	Keywords = {parsing},
	Location = {Vancouver, BC, Canada},
	Pages = {365--383},
	Publisher = {ACM},
	Title = {Concrete syntax for objects: domain-specific language embedding and assimilation without restrictions},
	Year = {2004},
	Abstract = {Application programmer's interfaces give access to domain knowledge encapsulated in class libraries without providing the appropriate notation for expressing domain composition. Since object-oriented languages are designed for extensibility and reuse, the language constructs are often sufficient for expressing domain abstractions at the semantic level. However, they do not provide the right abstractions at the syntactic level. In this paper we describe MetaBorg, a method for providing <i>concrete syntax</i> for domain abstractions to application programmers. The method consists of <i>embedding</i> domain-specific languages in a general purpose host language and <i>assimilating</i> the embedded domain code into the surrounding host code. Instead of extending the implementation of the host language, the assimilation phase implements domain abstractions in terms of existing APIs leaving the host language undisturbed. Indeed, MetaBorg can be considered a method for promoting APIs to the language level. The method is supported by proven and available technology, i.e. the syntax definition formalism SDF and the program transformation language and toolset Stratego/XT. We illustrate the method with applications in three domains: code generation, XML generation, and user-interface construction.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGwuLi8uLi9QYXBlcnMvQnJhdmVuYm9lci9CcmF2ZW5ib2VyLVZpc3NlciAtIENvbmNyZXRlIHN5bnRheCBmb3Igb2JqZWN0czogZG9tYWluLXNwZWNpZmljIGxhbmd1YWdlICgyMDA0KS5wZGbSGw8cHVdOUy5kYXRhTxECXAAAAAACXAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALusHH0JyYXZlbmJvZXItVmlzc2VyIC0gIzJFRUI0NC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAu60TDt3U9UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAApCcmF2ZW5ib2VyABAACAAAwTR+XQAAABEACAAAw7e7jQAAAAEAEAAu6wcALZE/AANHrAAAa9gAAgBDT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkJyYXZlbmJvZXI6QnJhdmVuYm9lci1WaXNzZXIgLSAjMkVFQjQ0LnBkZgAADgCqAFQAQgByAGEAdgBlAG4AYgBvAGUAcgAtAFYAaQBzAHMAZQByACAALQAgAEMAbwBuAGMAcgBlAHQAZQAgAHMAeQBuAHQAYQB4ACAAZgBvAHIAIABvAGIAagBlAGMAdABzAC8AIABkAG8AbQBhAGkAbgAtAHMAcABlAGMAaQBmAGkAYwAgAGwAYQBuAGcAdQBhAGcAZQAgACgAMgAwADAANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHNVc2Vycy9qZXJlbXkvUGFwZXJzL0JyYXZlbmJvZXIvQnJhdmVuYm9lci1WaXNzZXIgLSBDb25jcmV0ZSBzeW50YXggZm9yIG9iamVjdHM6IGRvbWFpbi1zcGVjaWZpYyBsYW5ndWFnZSAoMjAwNCkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEZAR4BJgOGA4gDjQOWA6EDpQOzA7oDwwPIA8sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAD2A==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1028976.1029007}}

@inproceedings{Bravenboer:Preventing:2007,
	Address = {New York, NY, USA},
	Author = {Martin Bravenboer and Eelco Dolstra and Eelco Visser},
	Booktitle = {GPCE '07: Proceedings of the 6th international conference on Generative programming and component engineering},
	Date-Added = {2008-01-19 09:34:02 -0500},
	Date-Modified = {2008-01-19 09:38:17 -0500},
	Doi = {http://doi.acm.org/10.1145/1289971.1289975},
	Isbn = {978-1-59593-855-8},
	Keywords = {parsing},
	Location = {Salzburg, Austria},
	Pages = {3--12},
	Publisher = {ACM},
	Title = {Preventing injection attacks with syntax embeddings},
	Year = {2007},
	Abstract = {Software written in one language often needs to construct sentences in another language, such as SQL queries, XML output, or shell command invocations. This is almost always done using unhygienic string manipulation, the concatenation of constants and client-supplied strings. A client can then supply specially crafted input that causes the constructed sentence to be interpreted in an unintended way, leading to an injection attack. We describe a more natural style of programming that yields code that is impervious to injections by construction. Our approach embeds the grammars of the guest languages (e.g., SQL) into that of the host language (e.g., Java) and automatically generates code that maps the embedded language to constructs in the host language that reconstruct the embedded sentences, adding escaping functions where appropriate. This approach is generic, meaning that it can be applied with relative ease to any combination of host and guest languages.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGcuLi8uLi9QYXBlcnMvQnJhdmVuYm9lci9CcmF2ZW5ib2VyLURvbHN0cmEtVmlzc2VyIC0gUHJldmVudGluZyBpbmplY3Rpb24gYXR0YWNrcyB3aXRoIHN5bnRheCAoMjAwNykucGRm0hsPHB1XTlMuZGF0YU8RAkwAAAAAAkwAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC7rBx9CcmF2ZW5ib2VyLURvbHN0cmEtViMyRUVCM0QucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALus9w7d07FBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAKQnJhdmVuYm9lcgAQAAgAAME0fl0AAAARAAgAAMO3uzwAAAABABAALusHAC2RPwADR6wAAGvYAAIAQ09kaW46VXNlcnM6amVyZW15OlBhcGVyczpCcmF2ZW5ib2VyOkJyYXZlbmJvZXItRG9sc3RyYS1WIzJFRUIzRC5wZGYAAA4AoABPAEIAcgBhAHYAZQBuAGIAbwBlAHIALQBEAG8AbABzAHQAcgBhAC0AVgBpAHMAcwBlAHIAIAAtACAAUAByAGUAdgBlAG4AdABpAG4AZwAgAGkAbgBqAGUAYwB0AGkAbwBuACAAYQB0AHQAYQBjAGsAcwAgAHcAaQB0AGgAIABzAHkAbgB0AGEAeAAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG5Vc2Vycy9qZXJlbXkvUGFwZXJzL0JyYXZlbmJvZXIvQnJhdmVuYm9lci1Eb2xzdHJhLVZpc3NlciAtIFByZXZlbnRpbmcgaW5qZWN0aW9uIGF0dGFja3Mgd2l0aCBzeW50YXggKDIwMDcpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEUARkBIQNxA3MDeAOBA4wDkAOeA6UDrgOzA7YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADww==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1289971.1289975}}

@techreport{Bravenboer:Program:2005,
	Address = {Utrecht},
	Author = {Martin Bravenboer and Arthur van Dam and Karina Olmos and Eelco Visser},
	Date-Added = {2008-01-19 09:28:07 -0500},
	Date-Modified = {2008-01-19 13:23:20 -0500},
	Institution = {Utrecht University},
	Keywords = {parsing},
	Month = {June},
	Number = {UU-CS-2005-05},
	Title = {Program Transformation with Scoped Dynamic Rewrite Rules},
	Year = {2005},
	Annote = {Published as Bravenboer:Program:2006.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGQuLi8uLi9QYXBlcnMvQnJhdmVuYm9lci9CcmF2ZW5ib2VyLURhbS1PbG1vcyAtIFByb2dyYW0gVHJhbnNmb3JtYXRpb24gd2l0aCBTY29wZWQgRHluYW1pYyAoMjAwNSkucGRm0hsPHB1XTlMuZGF0YU8RAkQAAAAAAkQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC7rBx9CcmF2ZW5ib2VyLURhbS1PbG1vcyMyRUVBRkUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALur+w7dzH1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAKQnJhdmVuYm9lcgAQAAgAAME0fl0AAAARAAgAAMO3uW8AAAABABAALusHAC2RPwADR6wAAGvYAAIAQ09kaW46VXNlcnM6amVyZW15OlBhcGVyczpCcmF2ZW5ib2VyOkJyYXZlbmJvZXItRGFtLU9sbW9zIzJFRUFGRS5wZGYAAA4AmgBMAEIAcgBhAHYAZQBuAGIAbwBlAHIALQBEAGEAbQAtAE8AbABtAG8AcwAgAC0AIABQAHIAbwBnAHIAYQBtACAAVAByAGEAbgBzAGYAbwByAG0AYQB0AGkAbwBuACAAdwBpAHQAaAAgAFMAYwBvAHAAZQBkACAARAB5AG4AYQBtAGkAYwAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGtVc2Vycy9qZXJlbXkvUGFwZXJzL0JyYXZlbmJvZXIvQnJhdmVuYm9lci1EYW0tT2xtb3MgLSBQcm9ncmFtIFRyYW5zZm9ybWF0aW9uIHdpdGggU2NvcGVkIER5bmFtaWMgKDIwMDUpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBEQEWAR4DZgNoA20DdgOBA4UDkwOaA6MDqAOrAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA7g=}}

@inproceedings{Bravenboer:Declarative:2006,
	Address = {New York, NY, USA},
	Author = {Martin Bravenboer and \'{E}ric Tanter and Eelco Visser},
	Booktitle = {OOPSLA '06: Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications},
	Date-Added = {2008-01-19 09:25:07 -0500},
	Date-Modified = {2008-01-19 09:38:17 -0500},
	Doi = {http://doi.acm.org/10.1145/1167473.1167491},
	Isbn = {1-59593-348-4},
	Keywords = {parsing},
	Location = {Portland, Oregon, USA},
	Pages = {209--228},
	Publisher = {ACM},
	Title = {Declarative, formal, and extensible syntax definition for aspect{J}},
	Year = {2006},
	Abstract = {Aspect-Oriented Programming (AOP) is attracting attention from both research and industry, as illustrated by the ever-growing popularity of AspectJ, the de facto standard AOP extension of Java. From a compiler construction perspective AspectJ is interesting as it is a typical example of compositional language, ie a language composed of a number of separate languages with different syntactical styles: in addition to plain Java, AspectJ includes a language for defining pointcuts and one for defining advices. Language composition represents a non-trivial challenge for conventional parsing techniques. First, combining several languages with different lexical syntax leads to considerable complexity in the lexical states to processed. Second, as new language features for AOP are being explored, many research proposals are concerned with further extending the AspectJ language, resulting in a need for an extensible syntax definition.This paper shows how scannerless parsing elegantly addresses the issues encountered by conventional techniques when parsing AspectJ . We present the design of a modular, extensible, and formal definition of the lexical and context-free aspects of the AspectJ syntax in the Syntax Definition Formalism SDF, which is implemented by a scannerless, generalized-LR parser (SGLR). We introduce grammar mixins as a novel application of SDF's modularity features, which allows the declarative definition of different keyword policies and combination of extensions. We illustrate the modular extensibility of our definition with syntax extensions taken from current research on aspect languages. Finally, benchmarks show the reasonable performance of scannerless generalized-LR parsing for this grammar.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHMuLi8uLi9QYXBlcnMvQnJhdmVuYm9lci9CcmF2ZW5ib2VyLVRhbnRlci1WaXNzZXIgLSBEZWNsYXJhdGl2ZSwgZm9ybWFsLCBhbmQgZXh0ZW5zaWJsZSBzeW50YXggZGVmaW5pdGlvbiAoMjAwNikucGRm0hsPHB1XTlMuZGF0YU8RAnAAAAAAAnAAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC7rBx9CcmF2ZW5ib2VyLVRhbnRlci1WaSMyRUVCMkEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALusqw7d0slBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAKQnJhdmVuYm9lcgAQAAgAAME0fl0AAAARAAgAAMO3uwIAAAABABAALusHAC2RPwADR6wAAGvYAAIAQ09kaW46VXNlcnM6amVyZW15OlBhcGVyczpCcmF2ZW5ib2VyOkJyYXZlbmJvZXItVGFudGVyLVZpIzJFRUIyQS5wZGYAAA4AuABbAEIAcgBhAHYAZQBuAGIAbwBlAHIALQBUAGEAbgB0AGUAcgAtAFYAaQBzAHMAZQByACAALQAgAEQAZQBjAGwAYQByAGEAdABpAHYAZQAsACAAZgBvAHIAbQBhAGwALAAgAGEAbgBkACAAZQB4AHQAZQBuAHMAaQBiAGwAZQAgAHMAeQBuAHQAYQB4ACAAZABlAGYAaQBuAGkAdABpAG8AbgAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHpVc2Vycy9qZXJlbXkvUGFwZXJzL0JyYXZlbmJvZXIvQnJhdmVuYm9lci1UYW50ZXItVmlzc2VyIC0gRGVjbGFyYXRpdmUsIGZvcm1hbCwgYW5kIGV4dGVuc2libGUgc3ludGF4IGRlZmluaXRpb24gKDIwMDYpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEgASUBLQOhA6MDqAOxA7wDwAPOA9UD3gPjA+YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAD8w==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1167473.1167491}}

@article{Bravenboer:Program:2006,
	Address = {Amsterdam, The Netherlands, The Netherlands},
	Author = {Martin Bravenboer and Arthur van Dam and Karina Olmos and Eelco Visser},
	Date-Added = {2008-01-19 09:22:05 -0500},
	Date-Modified = {2008-01-19 09:38:17 -0500},
	Issn = {0169-2968},
	Journal = {Fundam. Inf.},
	Keywords = {parsing},
	Number = {1-2},
	Pages = {123--178},
	Publisher = {IOS Press},
	Title = {Program Transformation with Scoped Dynamic Rewrite Rules},
	Volume = {69},
	Year = {2006}}

@techreport{Visser:Scannerless:1997,
	Address = {Amsterdam},
	Author = {Eelco Visser},
	Date-Added = {2008-01-19 09:16:04 -0500},
	Date-Modified = {2008-01-19 09:18:59 -0500},
	Institution = {University of Amsterdam},
	Keywords = {parsing},
	Month = {July},
	Number = {P9707},
	Title = {Scannerless Generalized-LR Parsing},
	Year = {1997},
	Abstract = {Current deterministic parsing techniques have a number of problems. These include the limitations of parser generators for deterministic languages and the complex interface between scanner and parser. Scannerless parsing is a parsing technique in which lexical and context-free syntax are integrated into one grammar and are all handled by a single context-free analysis phase. This approach has a number of advantages including discarding of the scanner and lexical disambiguation by means of the context in which a lexical token occurs. Scannerless parsing generates a number of interesting problems as well. Integrated grammars do not fit the requirements of the conventional deterministic parsing techniques. A plain context-free grammar formalism leads to unwieldy grammars, if all lexical information is included. Lexical disambiguation needs to be reformulated for use in context-free parsing.

The scannerless generalized-LR parsing approach presented in this paper solves these problems. Grammar normalization is used to support an expressive grammar formalism without complicating the underlying machinery. Follow restrictions are used to express longest match lexical disambiguation. Reject productions are used to express the prefer keywords rule for lexical disambiguation. The SLR(1) parser generation algorithm is adapted to implement disambiguation by general priority and associativity declarations and to interpret follow restrictions. Generalized-LR parsing is used to provide dynamic lookahead and to support parsing of arbitrary context-free grammars including ambiguous ones. An adaptation of the GLR algorithm supports the interpretation of grammars with reject productions. },
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEouLi8uLi9QYXBlcnMvVmlzc2VyL1Zpc3NlciAtIFNjYW5uZXJsZXNzIEdlbmVyYWxpemVkLUxSIFBhcnNpbmcgKDE5OTcpLnBkZtIbDxwdV05TLmRhdGFPEQH2AAAAAAH2AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAu6sgfVmlzc2VyIC0gU2Nhbm5lcmxlc3MjMkVFQUMxLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC7qwcO3cNIAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABlZpc3NlcgAQAAgAAME0fl0AAAARAAgAAMO3tyIAAAABABAALurIAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpWaXNzZXI6Vmlzc2VyIC0gU2Nhbm5lcmxlc3MjMkVFQUMxLnBkZgAADgBuADYAVgBpAHMAcwBlAHIAIAAtACAAUwBjAGEAbgBuAGUAcgBsAGUAcwBzACAARwBlAG4AZQByAGEAbABpAHoAZQBkAC0ATABSACAAUABhAHIAcwBpAG4AZwAgACgAMQA5ADkANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFFVc2Vycy9qZXJlbXkvUGFwZXJzL1Zpc3Nlci9WaXNzZXIgLSBTY2FubmVybGVzcyBHZW5lcmFsaXplZC1MUiBQYXJzaW5nICgxOTk3KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPcA/AEEAv4DAAMFAw4DGQMdAysDMgM7A0ADQwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANQ}}

@article{Brand:Generation:1996,
	Address = {New York, NY, USA},
	Author = {van den Brand, Mark and Eelco Visser},
	Date-Added = {2008-01-19 09:12:26 -0500},
	Date-Modified = {2008-01-19 09:23:02 -0500},
	Doi = {http://doi.acm.org/10.1145/226155.226156},
	Issn = {1049-331X},
	Journal = {ACM Trans. Softw. Eng. Methodol.},
	Keywords = {parsing},
	Number = {1},
	Pages = {1--41},
	Publisher = {ACM},
	Title = {Generation of formatters for context-free languages},
	Volume = {5},
	Year = {1996},
	Abstract = {Good documentation is important for the production of reusable and maintainable software. For the production of accurate documentation it is necessary that the original program text is not copied manually to obtain a typeset version. Apart from being tedious, this will invariably introduce errors. The production of tools that support the production of legible and accurate documentation is a software engineering challenge in itself. We present an algebraic approach to the generation of tools that produce typographically effective presentations of computer programs. A specification of a formatter is generated from the context-free grammar of a (programming) language. These generated formatters translate abstract syntax trees of programs into box expressions. Box expressions are translated by language-independent interpreters of the box language into ASCII or TEX. The formatting rules that are generated can easily be tuned in order to get the desired formatting of programs. We demonstrate this by means of real-life applications. Furthermore, we give a practical solution for the problem of formatting comments, which occur in the original text. The formatter generation approach proposed in this article can be used to generate formatting programs for arbitrary programming environments. Our formatter generation approach can be used to automatically generate formatters that have to be programmed explicitly in other systems.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGAuLi8uLi9QYXBlcnMvQnJhbmQvQnJhbmQtVmlzc2VyIC0gR2VuZXJhdGlvbiBvZiBmb3JtYXR0ZXJzIGZvciBjb250ZXh0LWZyZWUgbGFuZ3VhZ2VzICgxOTk2KS5wZGbSGw8cHVdOUy5kYXRhTxECOAAAAAACOAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALupwH0JyYW5kLVZpc3NlciAtIEdlbmVyIzJFRUFEOS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAu6tnDt3HQUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVCcmFuZAAAEAAIAADBNH5dAAAAEQAIAADDt7ggAAAAAQAQAC7qcAAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QnJhbmQ6QnJhbmQtVmlzc2VyIC0gR2VuZXIjMkVFQUQ5LnBkZgAOAJwATQBCAHIAYQBuAGQALQBWAGkAcwBzAGUAcgAgAC0AIABHAGUAbgBlAHIAYQB0AGkAbwBuACAAbwBmACAAZgBvAHIAbQBhAHQAdABlAHIAcwAgAGYAbwByACAAYwBvAG4AdABlAHgAdAAtAGYAcgBlAGUAIABsAGEAbgBnAHUAYQBnAGUAcwAgACgAMQA5ADkANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGdVc2Vycy9qZXJlbXkvUGFwZXJzL0JyYW5kL0JyYW5kLVZpc3NlciAtIEdlbmVyYXRpb24gb2YgZm9ybWF0dGVycyBmb3IgY29udGV4dC1mcmVlIGxhbmd1YWdlcyAoMTk5NikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgENARIBGgNWA1gDXQNmA3EDdQODA4oDkwOYA5sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/226155.226156}}

@inproceedings{Brand:Disambiguation:2002,
	Address = {London, UK},
	Author = {Mark G. J. van den Brand and Jeroen Scheerder and Jurgen J. Vinju and Eelco Visser},
	Booktitle = {CC '02: Proceedings of the 11th International Conference on Compiler Construction},
	Date-Added = {2008-01-19 09:08:40 -0500},
	Date-Modified = {2008-01-19 09:10:25 -0500},
	Isbn = {3-540-43369-4},
	Keywords = {parsing},
	Pages = {143--158},
	Publisher = {Springer-Verlag},
	Title = {Disambiguation Filters for Scannerless Generalized LR Parsers},
	Year = {2002},
	Abstract = {In this paper we present the fusion of generalized LR parsing and scannerless parsing. This combination supports syntax definitions in which all aspects (lexical and context-free) of the syntax of a language are defined explicitly in one formalism. Furthermore, there are no restrictions on the class of grammars, thus allowing a natural syntax tree structure. Ambiguities that arise through the use of unrestricted grammars are handled by explicit disambiguation constructs, instead of implicit defaults that are taken by traditional scanner and parser generators. Hence, a syntax definition becomes a full declarative description of a language. Scannerless generalized LR parsing is a viable technique that has been applied in various industrial and academic projects.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHMuLi8uLi9QYXBlcnMvQnJhbmQvQnJhbmQtU2NoZWVyZGVyLVZpbmp1IC0gRGlzYW1iaWd1YXRpb24gRmlsdGVycyBmb3IgU2Nhbm5lcmxlc3MgR2VuZXJhbGl6ZWQgTFIgUGFyc2VycyAoMjAwMikucGRm0hsPHB1XTlMuZGF0YU8RAnAAAAAAAnAAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC7qcB9CcmFuZC1TY2hlZXJkZXItVmluaiMyRUVBNkEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALupqw7dv11BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAFQnJhbmQAABAACAAAwTR+XQAAABEACAAAw7e2JwAAAAEAEAAu6nAALZE/AANHrAAAa9gAAgA+T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkJyYW5kOkJyYW5kLVNjaGVlcmRlci1WaW5qIzJFRUE2QS5wZGYADgDCAGAAQgByAGEAbgBkAC0AUwBjAGgAZQBlAHIAZABlAHIALQBWAGkAbgBqAHUAIAAtACAARABpAHMAYQBtAGIAaQBnAHUAYQB0AGkAbwBuACAARgBpAGwAdABlAHIAcwAgAGYAbwByACAAUwBjAGEAbgBuAGUAcgBsAGUAcwBzACAARwBlAG4AZQByAGEAbABpAHoAZQBkACAATABSACAAUABhAHIAcwBlAHIAcwAgACgAMgAwADAAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHpVc2Vycy9qZXJlbXkvUGFwZXJzL0JyYW5kL0JyYW5kLVNjaGVlcmRlci1WaW5qdSAtIERpc2FtYmlndWF0aW9uIEZpbHRlcnMgZm9yIFNjYW5uZXJsZXNzIEdlbmVyYWxpemVkIExSIFBhcnNlcnMgKDIwMDIpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEgASUBLQOhA6MDqAOxA7wDwAPOA9UD3gPjA+YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAD8w==}}

@inproceedings{Soisalon-Soininen:Elimination:1977,
	Address = {New York, NY, USA},
	Author = {Eljas Soisalon-Soininen},
	Booktitle = {POPL '77: Proceedings of the 4th ACM SIGACT-SIGPLAN symposium on Principles of programming languages},
	Date-Added = {2008-01-17 22:28:17 -0500},
	Date-Modified = {2008-01-17 22:29:10 -0500},
	Doi = {http://doi.acm.org/10.1145/512950.512967},
	Location = {Los Angeles, California},
	Pages = {183--193},
	Publisher = {ACM},
	Title = {Elimination of single productions from LR parsers in conjunction with the use of default reductions},
	Year = {1977},
	Abstract = {The problem in the use of default reductions in conjunction with the elimination of reductions by single productions is discussed in Pager[1973a] and a method is given there to solve the problem. The basis of the solution is to apply first the algorithm for eliminating reductions by single productions and then to check every potential default reduction in order to decide whether it can be used or not. Hence, in the optimized parser all reductions by single productions are eliminated, but the use of default reductions can be limited. (Pager [1973a] has found that in the case of some practical grammars almost all of potential default reductions can be used.)

In the present paper we consider another approach to the problem. In our method the elimination process itself corresponds to the technique of Pager[1973a,1974], but the elimination is carried out only if it does not affect the applicability of default reductions. The main motivation of this approach is the fact that it leads to a method for eliminating reductions by single productions which is applicable for any type of LR parser, including LALR parsers and generalizations of them.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEG8uLi8uLi9QYXBlcnMvU29pc2Fsb24tU29pbmluZW4vU29pc2Fsb24tU29pbmluZW4gLSBFbGltaW5hdGlvbiBvZiBzaW5nbGUgcHJvZHVjdGlvbnMgZnJvbSBMUiBwYXJzZXJzICgxOTc3KS5wZGbSGw8cHVdOUy5kYXRhTxECZAAAAAACZAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALuIZH1NvaXNhbG9uLVNvaW5pbmVuIC0gIzJFRTIxOC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAu4hjDtYiaUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAABFTb2lzYWxvbi1Tb2luaW5lbgAAEAAIAADBNH5dAAAAEQAIAADDtc7qAAAAAQAQAC7iGQAtkT8AA0esAABr2AACAEpPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6U29pc2Fsb24tU29pbmluZW46U29pc2Fsb24tU29pbmluZW4gLSAjMkVFMjE4LnBkZgAOAKIAUABTAG8AaQBzAGEAbABvAG4ALQBTAG8AaQBuAGkAbgBlAG4AIAAtACAARQBsAGkAbQBpAG4AYQB0AGkAbwBuACAAbwBmACAAcwBpAG4AZwBsAGUAIABwAHIAbwBkAHUAYwB0AGkAbwBuAHMAIABmAHIAbwBtACAATABSACAAcABhAHIAcwBlAHIAcwAgACgAMQA5ADcANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHZVc2Vycy9qZXJlbXkvUGFwZXJzL1NvaXNhbG9uLVNvaW5pbmVuL1NvaXNhbG9uLVNvaW5pbmVuIC0gRWxpbWluYXRpb24gb2Ygc2luZ2xlIHByb2R1Y3Rpb25zIGZyb20gTFIgcGFyc2VycyAoMTk3NykucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARwBIQEpA5EDkwOYA6EDrAOwA74DxQPOA9MD1gAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAPj},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/512950.512967}}

@article{Aycock:Even:2001,
	Address = {Secaucus, NJ, USA},
	Author = {John Aycock and Nigel Horspool and Jan Janou\v{s}ek and Bo\v{r}ivoj Melichar},
	Date-Added = {2008-01-17 22:17:11 -0500},
	Date-Modified = {2008-01-17 22:19:40 -0500},
	Doi = {http://dx.doi.org/10.1007/PL00013319},
	Issn = {0001-5903},
	Journal = {Acta Inf.},
	Keywords = {parsing},
	Number = {9},
	Pages = {633--651},
	Publisher = {Springer-Verlag New York, Inc.},
	Title = {Even faster generalized LR parsing},
	Volume = {37},
	Year = {2001},
	Abstract = {We prove a property of generalized LR (GLR) parsing -- if the grammar is without right and hidden left recursions, then the number of consecutive reductions between the shifts of two adjacent symbols cannot be greater than a constant. Further, we show that this property can be used for constructing an optimized version of our GLR parser. Compared with a standard GLR parser, our optimized parser reads one symbol on every transition and performs significantly fewer stack operations. Our timings show that, especially for highly ambiguous grammars, our parser is significantly faster than a standard GLR parser.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFwuLi8uLi9QYXBlcnMvQXljb2NrL0F5Y29jay1Ib3JzcG9vbC1KYW5vdXNlayAtIEV2ZW4gZmFzdGVyIGdlbmVyYWxpemVkIExSIHBhcnNpbmcgKDIwMDEpLnBkZtIbDxwdV05TLmRhdGFPEQIsAAAAAAIsAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAugkAfQXljb2NrLUhvcnNwb29sLUphbm8jMkVFMTk1LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC7hlcO1hHhQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABkF5Y29jawAQAAgAAME0fl0AAAARAAgAAMO1ysgAAAABABAALoJAAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpBeWNvY2s6QXljb2NrLUhvcnNwb29sLUphbm8jMkVFMTk1LnBkZgAADgCSAEgAQQB5AGMAbwBjAGsALQBIAG8AcgBzAHAAbwBvAGwALQBKAGEAbgBvAHUAcwBlAGsAIAAtACAARQB2AGUAbgAgAGYAYQBzAHQAZQByACAAZwBlAG4AZQByAGEAbABpAHoAZQBkACAATABSACAAcABhAHIAcwBpAG4AZwAgACgAMgAwADAAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGNVc2Vycy9qZXJlbXkvUGFwZXJzL0F5Y29jay9BeWNvY2stSG9yc3Bvb2wtSmFub3VzZWsgLSBFdmVuIGZhc3RlciBnZW5lcmFsaXplZCBMUiBwYXJzaW5nICgyMDAxKS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQkBDgEWA0YDSANNA1YDYQNlA3MDegODA4gDiwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOY},
	Bdsk-Url-1 = {http://dx.doi.org/10.1007/PL00013319}}

@article{Horspool:Even:1990,
	Address = {New York, NY, USA},
	Author = {R. N. Horspool and M. Whitney},
	Date-Added = {2008-01-17 22:12:22 -0500},
	Date-Modified = {2008-01-17 22:13:09 -0500},
	Doi = {http://dx.doi.org/10.1002/spe.4380200602},
	Issn = {0038-0644},
	Journal = {Softw. Pract. Exper.},
	Keywords = {parsing},
	Number = {6},
	Pages = {515--535},
	Publisher = {John Wiley \& Sons, Inc.},
	Title = {Even faster LR parsing},
	Volume = {20},
	Year = {1990},
	Abstract = {Conventional LR parser generators create tables which are used to drive a standard parser procedure. Much faster parsers can be obtained by compiling the table entries into code that is directly executed. A possible drawback with a directly executable parser is its large size. In this paper, we introduce optimization techniques that increase the parsing speed even further while simultaneously reducing the size of the parser.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEouLi8uLi9QYXBlcnMvSG9yc3Bvb2wvSG9yc3Bvb2wtV2hpdG5leSAtIEV2ZW4gZmFzdGVyIExSIHBhcnNpbmcgKDE5OTApLnBkZtIbDxwdV05TLmRhdGFPEQH2AAAAAAH2AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAu4W8fSG9yc3Bvb2wtV2hpdG5leSAtIEUjMkVFMEI1LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC7gtcO1gBFQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAACEhvcnNwb29sABAACAAAwTR+XQAAABEACAAAw7XGYQAAAAEAEAAu4W8ALZE/AANHrAAAa9gAAgBBT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkhvcnNwb29sOkhvcnNwb29sLVdoaXRuZXkgLSBFIzJFRTBCNS5wZGYAAA4AagA0AEgAbwByAHMAcABvAG8AbAAtAFcAaABpAHQAbgBlAHkAIAAtACAARQB2AGUAbgAgAGYAYQBzAHQAZQByACAATABSACAAcABhAHIAcwBpAG4AZwAgACgAMQA5ADkAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFFVc2Vycy9qZXJlbXkvUGFwZXJzL0hvcnNwb29sL0hvcnNwb29sLVdoaXRuZXkgLSBFdmVuIGZhc3RlciBMUiBwYXJzaW5nICgxOTkwKS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPcA/AEEAv4DAAMFAw4DGQMdAysDMgM7A0ADQwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANQ},
	Bdsk-Url-1 = {http://dx.doi.org/10.1002/spe.4380200602}}

@article{Bhamidipaty:Very:1998,
	Address = {New York, NY, USA},
	Author = {Achyutram Bhamidipaty and Todd A. Proebsting},
	Date-Added = {2008-01-17 22:10:11 -0500},
	Date-Modified = {2008-01-17 22:13:47 -0500},
	Doi = {http://dx.doi.org/10.1002/(SICI)1097-024X(199802)28:2<181::AID-SPE139>3.3.CO;2-W},
	Issn = {0038-0644},
	Journal = {Softw. Pract. Exper.},
	Keywords = {parsing},
	Number = {2},
	Pages = {181--190},
	Publisher = {John Wiley \& Sons, Inc.},
	Title = {Very fast YACC-compatible parsers (for very little effort)},
	Volume = {28},
	Year = {1998},
	Abstract = {We have developed a yacc-compatible parser generator that creates parsers that are 2.0 to 6.0 times faster than those generated by yacc or bison. Our tool, mule, creates directly-executable, hard-coded parsers in ANSI; yacc produces interpreted, table-driven parsers. Two attributes distinguish mule from other parser generators that create hard-coded LR parsers; mule is compatible wtih yacc (including yacc's peculiar error recovery mechanisms), and mule does absolutely none of the complex automata analysis of previous hard-coded-parser generators. Mule creates simple, fast parsers after very little analysis.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGMuLi8uLi9QYXBlcnMvQmhhbWlkaXBhdHkvQmhhbWlkaXBhdHktUHJvZWJzdGluZyAtIFZlcnkgZmFzdCBZQUNDLWNvbXBhdGlibGUgcGFyc2VycyAoZm9yICgxOTk4KS5wZGbSGw8cHVdOUy5kYXRhTxECQAAAAAACQAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALuEWH0JoYW1pZGlwYXR5LVByb2Vic3RpIzJFRTBGQy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAu4PzDtYH0UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAtCaGFtaWRpcGF0eQAAEAAIAADBNH5dAAAAEQAIAADDtchEAAAAAQAQAC7hFgAtkT8AA0esAABr2AACAERPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QmhhbWlkaXBhdHk6QmhhbWlkaXBhdHktUHJvZWJzdGkjMkVFMEZDLnBkZgAOAJYASgBCAGgAYQBtAGkAZABpAHAAYQB0AHkALQBQAHIAbwBlAGIAcwB0AGkAbgBnACAALQAgAFYAZQByAHkAIABmAGEAcwB0ACAAWQBBAEMAQwAtAGMAbwBtAHAAYQB0AGkAYgBsAGUAIABwAGEAcgBzAGUAcgBzACAAKABmAG8AcgAgACgAMQA5ADkAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGpVc2Vycy9qZXJlbXkvUGFwZXJzL0JoYW1pZGlwYXR5L0JoYW1pZGlwYXR5LVByb2Vic3RpbmcgLSBWZXJ5IGZhc3QgWUFDQy1jb21wYXRpYmxlIHBhcnNlcnMgKGZvciAoMTk5OCkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARABFQEdA2EDYwNoA3EDfAOAA44DlQOeA6MDpgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOz},
	Bdsk-Url-1 = {http://dx.doi.org/10.1002/(SICI)1097-024X(199802)28:2%3C181::AID-SPE139%3E3.3.CO;2-W}}

@article{DeRemer:Efficient:1982,
	Address = {New York, NY, USA},
	Author = {Frank DeRemer and Thomas Pennello},
	Date-Added = {2008-01-17 21:50:13 -0500},
	Date-Modified = {2008-01-17 22:14:07 -0500},
	Doi = {http://doi.acm.org/10.1145/69622.357187},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Keywords = {parsing},
	Number = {4},
	Pages = {615--649},
	Publisher = {ACM},
	Title = {Efficient Computation of LALR(1) Look-Ahead Sets},
	Volume = {4},
	Year = {1982},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGMuLi8uLi9QYXBlcnMvRGVSZW1lci9EZVJlbWVyLVBlbm5lbGxvIC0gRWZmaWNpZW50IENvbXB1dGF0aW9uIG9mIExBTFIoMSkgTG9vay1BaGVhZCBTZXRzICgxOTgyKS5wZGbSGw8cHVdOUy5kYXRhTxECQAAAAAACQAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALuB1H0RlUmVtZXItUGVubmVsbG8gLSBFIzJFRTAyMS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAu4CHDtX5mUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdEZVJlbWVyAAAQAAgAAME0fl0AAAARAAgAAMO1xLYAAAABABAALuB1AC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpEZVJlbWVyOkRlUmVtZXItUGVubmVsbG8gLSBFIzJFRTAyMS5wZGYADgCeAE4ARABlAFIAZQBtAGUAcgAtAFAAZQBuAG4AZQBsAGwAbwAgAC0AIABFAGYAZgBpAGMAaQBlAG4AdAAgAEMAbwBtAHAAdQB0AGEAdABpAG8AbgAgAG8AZgAgAEwAQQBMAFIAKAAxACkAIABMAG8AbwBrAC0AQQBoAGUAYQBkACAAUwBlAHQAcwAgACgAMQA5ADgAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGpVc2Vycy9qZXJlbXkvUGFwZXJzL0RlUmVtZXIvRGVSZW1lci1QZW5uZWxsbyAtIEVmZmljaWVudCBDb21wdXRhdGlvbiBvZiBMQUxSKDEpIExvb2stQWhlYWQgU2V0cyAoMTk4MikucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARABFQEdA2EDYwNoA3EDfAOAA44DlQOeA6MDpgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOz},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/69622.357187}}

@inproceedings{Tan:iComment:2007,
	Address = {New York, NY, USA},
	Author = {Lin Tan and Ding Yuan and Gopal Krishna and Yuanyuan Zhou},
	Booktitle = {SOSP '07: Proceedings of twenty-first ACM SIGOPS symposium on Operating systems principles},
	Date-Added = {2008-01-14 01:46:49 -0500},
	Date-Modified = {2008-01-14 01:50:26 -0500},
	Doi = {http://doi.acm.org/10.1145/1294261.1294276},
	Isbn = {978-1-59593-591-5},
	Local-Url = {file://localhost/Users/jeremy/Papers/Tan/Tan-Yuan-Krishna%20-%20-*i%7BC%7Domment%20Bugs%20or%20Bad%20Comments%3F*-%20(2007).pdf},
	Location = {Stevenson, Washington, USA},
	Pages = {145--158},
	Publisher = {ACM},
	Title = {/*i{C}omment: Bugs or Bad Comments?*/},
	Year = {2007},
	Abstract = {Commenting source code has long been a common practice in software development. Compared to source code, comments are more direct, descriptive and easy-to-understand. Comments and sourcecode provide relatively redundant and independent information regarding a program's semantic behavior. As software evolves, they can easily grow out-of-sync, indicating two problems: (1) bugs -the source code does not follow the assumptions and requirements specified by correct program comments; (2) bad comments - comments that are inconsistent with correct code, which can confuse and mislead programmers to introduce bugs in subsequent versions. Unfortunately, as most comments are written in natural language, no solution has been proposed to automatically analyze commentsand detect inconsistencies between comments and source code. This paper takes the first step in automatically analyzing commentswritten in natural language to extract implicit program rulesand use these rules to automatically detect inconsistencies between comments and source code, indicating either bugs or bad comments. Our solution, iComment, combines Natural Language Processing(NLP), Machine Learning, Statistics and Program Analysis techniques to achieve these goals. We evaluate iComment on four large code bases: Linux, Mozilla, Wine and Apache. Our experimental results show that iComment automatically extracts 1832 rules from comments with 90.8-100% accuracy and detects 60 comment-code inconsistencies, 33 newbugs and 27 bad comments, in the latest versions of the four programs. Nineteen of them (12 bugs and 7 bad comments) have already been confirmed by the corresponding developers while the others are currently being analyzed by the developers.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFMuLi8uLi9QYXBlcnMvVGFuL1Rhbi1ZdWFuLUtyaXNobmEgLSAtKml7Q31vbW1lbnQgQnVncyBvciBCYWQgQ29tbWVudHM/Ki0gKDIwMDcpLnBkZtIbDxwdV05TLmRhdGFPEQIQAAAAAAIQAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAugwsfVGFuLVl1YW4tS3Jpc2huYSAtIC0jMkU4MzA5LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC6DCcOwcDFQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAA1RhbgAAEAAIAADBNH5dAAAAEQAIAADDsLaBAAAAAQAQAC6DCwAtkT8AA0esAABr2AACADxPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6VGFuOlRhbi1ZdWFuLUtyaXNobmEgLSAtIzJFODMwOS5wZGYADgCGAEIAVABhAG4ALQBZAHUAYQBuAC0ASwByAGkAcwBoAG4AYQAgAC0AIAAtACoAaQB7AEMAfQBvAG0AbQBlAG4AdAAgAEIAdQBnAHMAIABvAHIAIABCAGEAZAAgAEMAbwBtAG0AZQBuAHQAcwA/ACoALQAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFpVc2Vycy9qZXJlbXkvUGFwZXJzL1Rhbi9UYW4tWXVhbi1LcmlzaG5hIC0gLSppe0N9b21tZW50IEJ1Z3Mgb3IgQmFkIENvbW1lbnRzPyotICgyMDA3KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBAAEFAQ0DIQMjAygDMQM8A0ADTgNVA14DYwNmAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA3M=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1294261.1294276}}

@inproceedings{Minsky:Caml:2008,
	Address = {New York, NY, USA},
	Author = {Yaron M. Minsky},
	Booktitle = {POPL '08: Proceedings of the 35th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
	Date-Added = {2008-01-14 01:45:40 -0500},
	Date-Modified = {2008-01-14 01:51:48 -0500},
	Doi = {http://doi.acm.org/10.1145/1328438.1328441},
	Isbn = {978-1-59593-689-9},
	Keywords = {functional languages},
	Local-Url = {file://localhost/Users/jeremy/Papers/Minsky/Minsky%20-%20Caml%20trading%20(2008).pdf},
	Location = {San Francisco, California, USA},
	Pages = {285--285},
	Publisher = {ACM},
	Title = {Caml trading},
	Year = {2008},
	Abstract = {Jane Street Capital is a successful proprietary trading company that has shifted from developing software in mainstream programming languages to developing software almost entirely in OCaml, a statically typed functional programming language that has only modest industrial use. The scope of the enterprise is small but growing: Jane Street now has over 20 OCaml programmers that have collectively written hundreds of thousands of lines of OCaml code. OCaml is used for building everything from trading systems to research infrastructure to user interfaces to systems administration tools. This talk will discuss the motivations behind Jane Street's adoption of OCaml, and why we think that statically typed functional programming languages are such a good fit for the world of trading and finance.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEDQuLi8uLi9QYXBlcnMvTWluc2t5L01pbnNreSAtIENhbWwgdHJhZGluZyAoMjAwOCkucGRm0hsPHB1XTlMuZGF0YU8RAbQAAAAAAbQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC6DBB9NaW5za3kgLSBDYW1sIHRyYWRpbiMyRTgzMDIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALoMCw7BwClBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGTWluc2t5ABAACAAAwTR+XQAAABEACAAAw7C2WgAAAAEAEAAugwQALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOk1pbnNreTpNaW5za3kgLSBDYW1sIHRyYWRpbiMyRTgzMDIucGRmAAAOAEIAIABNAGkAbgBzAGsAeQAgAC0AIABDAGEAbQBsACAAdAByAGEAZABpAG4AZwAgACgAMgAwADAAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASADtVc2Vycy9qZXJlbXkvUGFwZXJzL01pbnNreS9NaW5za3kgLSBDYW1sIHRyYWRpbmcgKDIwMDgpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA4QDmAO4CpgKoAq0CtgLBAsUC0wLaAuMC6ALrAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAvg=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1328438.1328441}}

@article{Abadi:Just:2007,
	Address = {New York, NY, USA},
	Author = {Mart\'{\i}n Abadi and Bruno Blanchet and C\'{e}dric Fournet},
	Date-Added = {2008-01-14 01:44:39 -0500},
	Date-Modified = {2008-01-14 01:48:44 -0500},
	Doi = {http://doi.acm.org/10.1145/1266977.1266978},
	Issn = {1094-9224},
	Journal = {ACM Trans. Inf. Syst. Secur.},
	Local-Url = {file://localhost/Users/jeremy/Papers/Abadi/Abadi-Blanchet-Fournet%20-%20Just%20fast%20keying%20in%20the%20pi%20calculus%20(2007).pdf},
	Number = {3},
	Pages = {9},
	Publisher = {ACM},
	Title = {Just fast keying in the pi calculus},
	Volume = {10},
	Year = {2007},
	Abstract = {JFK is a recent, attractive protocol for fast key establishment as part of securing IP communication. In this paper, we formally analyze this protocol in the applied pi calculus (partly in terms of observational equivalences and partly with the assistance of an automatic protocol verifier). We treat JFK's core security properties and also other properties that are rarely articulated and rigorously studied, such as plausible deniability and resistance to denial-of-service attacks. In the course of this analysis, we found some ambiguities and minor problems, such as limitations in identity protection, but we mostly obtain positive results about JFK. For this purpose, we develop ideas and techniques that should be more generally useful in the specification and verification of security protocols.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFouLi8uLi9QYXBlcnMvQWJhZGkvQWJhZGktQmxhbmNoZXQtRm91cm5ldCAtIEp1c3QgZmFzdCBrZXlpbmcgaW4gdGhlIHBpIGNhbGN1bHVzICgyMDA3KS5wZGbSGw8cHVdOUy5kYXRhTxECJgAAAAACJgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALoL+H0FiYWRpLUJsYW5jaGV0LUZvdXJuIzJFODJGQi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAugvvDsG/mUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVBYmFkaQAAEAAIAADBNH5dAAAAEQAIAADDsLY2AAAAAQAQAC6C/gAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QWJhZGk6QWJhZGktQmxhbmNoZXQtRm91cm4jMkU4MkZCLnBkZgAOAJAARwBBAGIAYQBkAGkALQBCAGwAYQBuAGMAaABlAHQALQBGAG8AdQByAG4AZQB0ACAALQAgAEoAdQBzAHQAIABmAGEAcwB0ACAAawBlAHkAaQBuAGcAIABpAG4AIAB0AGgAZQAgAHAAaQAgAGMAYQBsAGMAdQBsAHUAcwAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGFVc2Vycy9qZXJlbXkvUGFwZXJzL0FiYWRpL0FiYWRpLUJsYW5jaGV0LUZvdXJuZXQgLSBKdXN0IGZhc3Qga2V5aW5nIGluIHRoZSBwaSBjYWxjdWx1cyAoMjAwNykucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEHAQwBFAM+A0ADRQNOA1kDXQNrA3IDewOAA4MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1266977.1266978}}

@inproceedings{Renieris:Almost::1999,
	Address = {New York, NY, USA},
	Author = {Manos Renieris and Steven P. Reiss},
	Booktitle = {NPIVM '99: Proceedings of the 1999 workshop on new paradigms in information visualization and manipulation in conjunction with the eighth ACM internation conference on Information and knowledge management},
	Date-Added = {2008-01-14 01:43:28 -0500},
	Date-Modified = {2008-01-14 01:51:32 -0500},
	Doi = {http://doi.acm.org/10.1145/331770.331788},
	Isbn = {1-58113-254-9},
	Keywords = {optimization},
	Local-Url = {file://localhost/Users/jeremy/Papers/Renieris/Renieris-Reiss%20-%20Almost%20exploring%20program%20traces%20(1999).pdf},
	Location = {Kansas City, Missouri, United States},
	Pages = {70--77},
	Publisher = {ACM},
	Title = {Almost: exploring program traces},
	Year = {1999},
	Abstract = {We built a tool to visualize and explore program execution traces. Our goal was to help programmers without any prior knowledge of a program, quickly get enough knowledge about its structure so that they can make small to medium changes. In the process, a number of problems were faced and tackled concerning the efficient use of screen space, interaction with multiple concurrent views, and linking of asymmetric views.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFEuLi8uLi9QYXBlcnMvUmVuaWVyaXMvUmVuaWVyaXMtUmVpc3MgLSBBbG1vc3QgZXhwbG9yaW5nIHByb2dyYW0gdHJhY2VzICgxOTk5KS5wZGbSGw8cHVdOUy5kYXRhTxECCgAAAAACCgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALoLyH1JlbmllcmlzLVJlaXNzIC0gQWxtIzJFODJGMC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAugvDDsG9vUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAhSZW5pZXJpcwAQAAgAAME0fl0AAAARAAgAAMOwtb8AAAABABAALoLyAC2RPwADR6wAAGvYAAIAQU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpSZW5pZXJpczpSZW5pZXJpcy1SZWlzcyAtIEFsbSMyRTgyRjAucGRmAAAOAHgAOwBSAGUAbgBpAGUAcgBpAHMALQBSAGUAaQBzAHMAIAAtACAAQQBsAG0AbwBzAHQAIABlAHgAcABsAG8AcgBpAG4AZwAgAHAAcgBvAGcAcgBhAG0AIAB0AHIAYQBjAGUAcwAgACgAMQA5ADkAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFhVc2Vycy9qZXJlbXkvUGFwZXJzL1JlbmllcmlzL1JlbmllcmlzLVJlaXNzIC0gQWxtb3N0IGV4cGxvcmluZyBwcm9ncmFtIHRyYWNlcyAoMTk5OSkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAP4BAwELAxkDGwMgAykDNAM4A0YDTQNWA1sDXgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANr},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/331770.331788}}

@article{Mernik:When:2005,
	Address = {New York, NY, USA},
	Author = {Marjan Mernik and Jan Heering and Anthony M. Sloane},
	Date-Added = {2008-01-14 01:32:38 -0500},
	Date-Modified = {2008-01-14 01:36:28 -0500},
	Doi = {http://doi.acm.org/10.1145/1118890.1118892},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Keywords = {dsls, language design},
	Local-Url = {file://localhost/Users/jeremy/Papers/Mernik/Mernik-Heering-Sloane%20-%20When%20and%20how%20to%20develop%20domain-specific%20languages%20(2005).pdf},
	Number = {4},
	Pages = {316--344},
	Publisher = {ACM},
	Title = {When and how to develop domain-specific languages},
	Volume = {37},
	Year = {2005},
	Abstract = {Domain-specific languages (DSLs) are languages tailored to a specific application domain. They offer substantial gains in expressiveness and ease of use compared with general-purpose programming languages in their domain of application. DSL development is hard, requiring both domain knowledge and language development expertise. Few people have both. Not surprisingly, the decision to develop a DSL is often postponed indefinitely, if considered at all, and most DSLs never get beyond the application library stage.Although many articles have been written on the development of particular DSLs, there is very limited literature on DSL development methodologies and many questions remain regarding when and how to develop a DSL. To aid the DSL developer, we identify patterns in the decision, analysis, design, and implementation phases of DSL development. Our patterns improve and extend earlier work on DSL design patterns. We also discuss domain analysis tools and language development systems that may help to speed up DSL development. Finally, we present a number of open problems.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGguLi8uLi9QYXBlcnMvTWVybmlrL01lcm5pay1IZWVyaW5nLVNsb2FuZSAtIFdoZW4gYW5kIGhvdyB0byBkZXZlbG9wIGRvbWFpbi1zcGVjaWZpYyBsYW5ndWFnZXMgKDIwMDUpLnBkZtIbDxwdV05TLmRhdGFPEQJQAAAAAAJQAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAugtcfTWVybmlrLUhlZXJpbmctU2xvYW4jMkU4MkQ1LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC6C1cOwbQNQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABk1lcm5pawAQAAgAAME0fl0AAAARAAgAAMOws1MAAAABABAALoLXAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpNZXJuaWs6TWVybmlrLUhlZXJpbmctU2xvYW4jMkU4MkQ1LnBkZgAADgCqAFQATQBlAHIAbgBpAGsALQBIAGUAZQByAGkAbgBnAC0AUwBsAG8AYQBuAGUAIAAtACAAVwBoAGUAbgAgAGEAbgBkACAAaABvAHcAIAB0AG8AIABkAGUAdgBlAGwAbwBwACAAZABvAG0AYQBpAG4ALQBzAHAAZQBjAGkAZgBpAGMAIABsAGEAbgBnAHUAYQBnAGUAcwAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG9Vc2Vycy9qZXJlbXkvUGFwZXJzL01lcm5pay9NZXJuaWstSGVlcmluZy1TbG9hbmUgLSBXaGVuIGFuZCBob3cgdG8gZGV2ZWxvcCBkb21haW4tc3BlY2lmaWMgbGFuZ3VhZ2VzICgyMDA1KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARUBGgEiA3YDeAN9A4YDkQOVA6MDqgOzA7gDuwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAPI},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1118890.1118892}}

@article{Kelleher:Lowering:2005,
	Address = {New York, NY, USA},
	Author = {Caitlin Kelleher and Randy Pausch},
	Date-Added = {2008-01-14 01:31:01 -0500},
	Date-Modified = {2008-01-14 01:35:13 -0500},
	Doi = {http://doi.acm.org/10.1145/1089733.1089734},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Local-Url = {file://localhost/Users/jeremy/Papers/Kelleher/Kelleher-Pausch%20-%20Lowering%20the%20barriers%20to%20programming%20A%20taxonomy%20of%20programming%20(2005).pdf},
	Number = {2},
	Pages = {83--137},
	Publisher = {ACM},
	Title = {Lowering the barriers to programming: A taxonomy of programming environments and languages for novice programmers},
	Volume = {37},
	Year = {2005},
	Abstract = {Since the early 1960's, researchers have built a number of programming languages and environments with the intention of making programming accessible to a larger number of people. This article presents a taxonomy of languages and environments designed to make programming more accessible to novice programmers of all ages. The systems are organized by their primary goal, either to teach programming or to use programming to empower their users, and then, by each system's authors' approach, to making learning to program easier for novice programmers. The article explains all categories in the taxonomy, provides a brief description of the systems in each category, and suggests some avenues for future work in novice programming environments and languages.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHEuLi8uLi9QYXBlcnMvS2VsbGVoZXIvS2VsbGVoZXItUGF1c2NoIC0gTG93ZXJpbmcgdGhlIGJhcnJpZXJzIHRvIHByb2dyYW1taW5nIEEgdGF4b25vbXkgb2YgcHJvZ3JhbW1pbmcgKDIwMDUpLnBkZtIbDxwdV05TLmRhdGFPEQJqAAAAAAJqAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAugtAfS2VsbGVoZXItUGF1c2NoIC0gTG8jMkU4MkNGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC6Cz8OwbMRQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAACEtlbGxlaGVyABAACAAAwTR+XQAAABEACAAAw7CzFAAAAAEAEAAugtAALZE/AANHrAAAa9gAAgBBT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOktlbGxlaGVyOktlbGxlaGVyLVBhdXNjaCAtIExvIzJFODJDRi5wZGYAAA4AuABbAEsAZQBsAGwAZQBoAGUAcgAtAFAAYQB1AHMAYwBoACAALQAgAEwAbwB3AGUAcgBpAG4AZwAgAHQAaABlACAAYgBhAHIAcgBpAGUAcgBzACAAdABvACAAcAByAG8AZwByAGEAbQBtAGkAbgBnACAAQQAgAHQAYQB4AG8AbgBvAG0AeQAgAG8AZgAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHhVc2Vycy9qZXJlbXkvUGFwZXJzL0tlbGxlaGVyL0tlbGxlaGVyLVBhdXNjaCAtIExvd2VyaW5nIHRoZSBiYXJyaWVycyB0byBwcm9ncmFtbWluZyBBIHRheG9ub215IG9mIHByb2dyYW1taW5nICgyMDA1KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBHgEjASsDmQObA6ADqQO0A7gDxgPNA9YD2wPeAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA+s=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1089733.1089734}}

@article{Black:Object-oriented:,
	Address = {New York, NY, USA},
	Author = {A. P. Black},
	Date-Added = {2008-01-14 01:28:14 -0500},
	Date-Modified = {2008-01-14 01:30:00 -0500},
	Doi = {http://doi.acm.org/10.1145/242224.242414},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Keywords = {monads, object-oriented languages},
	Local-Url = {file://localhost/Users/jeremy/Papers/Black/Black%20-%20Object-oriented%20languages%20the%20next%20generation%20(1996).pdf},
	Month = {December},
	Number = {4},
	Pages = {149},
	Publisher = {ACM},
	Title = {Object-oriented languages: the next generation},
	Volume = {28},
	Year = {1996},
	Abstract = {This position paper outlines some important future directions for object-oriented programming languages. It was prepared as input to the object-oriented programming working group of the Workshop on Strategic Directions in Computing. It highlights the influence of Distribution, User-orientation, Monads, Types and Higher-Order programming on Object-Oriented languages.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFMuLi8uLi9QYXBlcnMvQmxhY2svQmxhY2sgLSBPYmplY3Qtb3JpZW50ZWQgbGFuZ3VhZ2VzIHRoZSBuZXh0IGdlbmVyYXRpb24gKDE5OTYpLnBkZtIbDxwdV05TLmRhdGFPEQIQAAAAAAIQAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAugrMfQmxhY2sgLSBPYmplY3Qtb3JpZW4jMkU4MkFGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC6Cr8OwaxMAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABUJsYWNrAAAQAAgAAME0fl0AAAARAAgAAMOwsWMAAAABABAALoKzAC2RPwADR6wAAGvYAAIAPk9kaW46VXNlcnM6amVyZW15OlBhcGVyczpCbGFjazpCbGFjayAtIE9iamVjdC1vcmllbiMyRTgyQUYucGRmAA4AggBAAEIAbABhAGMAawAgAC0AIABPAGIAagBlAGMAdAAtAG8AcgBpAGUAbgB0AGUAZAAgAGwAYQBuAGcAdQBhAGcAZQBzACAAdABoAGUAIABuAGUAeAB0ACAAZwBlAG4AZQByAGEAdABpAG8AbgAgACgAMQA5ADkANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFpVc2Vycy9qZXJlbXkvUGFwZXJzL0JsYWNrL0JsYWNrIC0gT2JqZWN0LW9yaWVudGVkIGxhbmd1YWdlcyB0aGUgbmV4dCBnZW5lcmF0aW9uICgxOTk2KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBAAEFAQ0DIQMjAygDMQM8A0ADTgNVA14DYwNmAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA3M=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/242224.242414}}

@article{Beszedes:Survey:2003,
	Address = {New York, NY, USA},
	Author = {\'{A}rp\'{a}d Besz\'{e}des and Rudolf Ferenc and Tibor Gyim\'{o}thy and Andr\'{e} Dolenc and Konsta Karsisto},
	Date-Added = {2008-01-14 01:22:42 -0500},
	Date-Modified = {2008-01-14 01:23:59 -0500},
	Doi = {http://doi.acm.org/10.1145/937503.937504},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Keywords = {optimization},
	Local-Url = {file://localhost/Users/jeremy/Papers/Beszedes/Beszedes-Ferenc-Gyimothy%20-%20Survey%20of%20code-size%20reduction%20methods%20(2003).pdf},
	Number = {3},
	Pages = {223--267},
	Publisher = {ACM},
	Title = {Survey of code-size reduction methods},
	Volume = {35},
	Year = {2003},
	Abstract = {Program code compression is an emerging research activity that is having an impact in several production areas such as networking and embedded systems. This is because the reduced-sized code can have a positive impact on network traffic and embedded system costs such as memory requirements and power consumption. Although code-size reduction is a relatively new research area, numerous publications already exist on it. The methods published usually have different motivations and a variety of application contexts. They may use different principles and their publications often use diverse notations. To our knowledge, there are no publications that present a good overview of this broad range of methods and give a useful assessment. This article surveys twelve methods and several related works appearing in some 50 papers published up to now. We provide extensive assessment criteria for evaluating the methods and offer a basis for comparison. We conclude that it is fairly hard to make any fair comparisons of the methods or draw conclusions about their applicability.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGEuLi8uLi9QYXBlcnMvQmVzemVkZXMvQmVzemVkZXMtRmVyZW5jLUd5aW1vdGh5IC0gU3VydmV5IG9mIGNvZGUtc2l6ZSByZWR1Y3Rpb24gbWV0aG9kcyAoMjAwMykucGRm0hsPHB1XTlMuZGF0YU8RAjoAAAAAAjoAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC6Cgh9CZXN6ZWRlcy1GZXJlbmMtR3lpbSMyRTgyN0YucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALoJ/w7BqGlBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIQmVzemVkZXMAEAAIAADBNH5dAAAAEQAIAADDsLBqAAAAAQAQAC6CggAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QmVzemVkZXM6QmVzemVkZXMtRmVyZW5jLUd5aW0jMkU4MjdGLnBkZgAADgCYAEsAQgBlAHMAegBlAGQAZQBzAC0ARgBlAHIAZQBuAGMALQBHAHkAaQBtAG8AdABoAHkAIAAtACAAUwB1AHIAdgBlAHkAIABvAGYAIABjAG8AZABlAC0AcwBpAHoAZQAgAHIAZQBkAHUAYwB0AGkAbwBuACAAbQBlAHQAaABvAGQAcwAgACgAMgAwADAAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGhVc2Vycy9qZXJlbXkvUGFwZXJzL0Jlc3plZGVzL0Jlc3plZGVzLUZlcmVuYy1HeWltb3RoeSAtIFN1cnZleSBvZiBjb2RlLXNpemUgcmVkdWN0aW9uIG1ldGhvZHMgKDIwMDMpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEOARMBGwNZA1sDYANpA3QDeAOGA40DlgObA54AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/937503.937504}}

@article{Aycock:A-brief:2003,
	Address = {New York, NY, USA},
	Author = {John Aycock},
	Date-Added = {2008-01-14 01:15:44 -0500},
	Date-Modified = {2008-01-14 01:16:43 -0500},
	Doi = {http://doi.acm.org/10.1145/857076.857077},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Keywords = {compilation},
	Local-Url = {file://localhost/Users/jeremy/Papers/Aycock/Aycock%20-%20A%20brief%20history%20of%20just-in-time%20(2003).pdf},
	Number = {2},
	Pages = {97--113},
	Publisher = {ACM},
	Title = {A brief history of just-in-time},
	Volume = {35},
	Year = {2003},
	Abstract = {Software systems have been using "just-in-time" compilation (JIT) techniques since the 1960s. Broadly, JIT compilation includes any translation performed dynamically, after a program has started execution. We examine the motivation behind JIT compilation and constraints imposed on JIT compilation systems, and present a classification scheme for such systems. This classification emerges as we survey forty years of JIT work, from 1960--2000.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEcuLi8uLi9QYXBlcnMvQXljb2NrL0F5Y29jayAtIEEgYnJpZWYgaGlzdG9yeSBvZiBqdXN0LWluLXRpbWUgKDIwMDMpLnBkZtIbDxwdV05TLmRhdGFPEQHsAAAAAAHsAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAugkAfQXljb2NrIC0gQSBicmllZiBoaXMjMkU4MjNGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC6CP8OwaG9QREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABkF5Y29jawAQAAgAAME0fl0AAAARAAgAAMOwrr8AAAABABAALoJAAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpBeWNvY2s6QXljb2NrIC0gQSBicmllZiBoaXMjMkU4MjNGLnBkZgAADgBoADMAQQB5AGMAbwBjAGsAIAAtACAAQQAgAGIAcgBpAGUAZgAgAGgAaQBzAHQAbwByAHkAIABvAGYAIABqAHUAcwB0AC0AaQBuAC0AdABpAG0AZQAgACgAMgAwADAAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAE5Vc2Vycy9qZXJlbXkvUGFwZXJzL0F5Y29jay9BeWNvY2sgLSBBIGJyaWVmIGhpc3Rvcnkgb2YganVzdC1pbi10aW1lICgyMDAzKS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA9AD5AQEC8QLzAvgDAQMMAxADHgMlAy4DMwM2AAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA0M=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/857076.857077}}

@article{Spector:Efficient:1988,
	Address = {New York, NY, USA},
	Author = {D. Spector},
	Date-Added = {2008-01-14 01:10:52 -0500},
	Date-Modified = {2008-01-17 21:19:51 -0500},
	Doi = {http://doi.acm.org/10.1145/57669.57684},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Keywords = {parsing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Spector/Spector%20-%20Efficient%20full%20LR(I)%20parser%20generation%20(1988).pdf},
	Number = {12},
	Pages = {143--150},
	Publisher = {ACM},
	Rating = {4},
	Read = {Yes},
	Title = {Efficient full LR(I) parser generation},
	Volume = {23},
	Year = {1988},
	Abstract = {This paper proposes that full LR(1) parser generators are easier to use than the LALR(1) parser generators commonly in use, and that minimal-state full LR(1) tables are not much larger than LALR(1) tables. A method is presented for the automatic construction of minimal-state full LR(1) parser tables. The method is fast and accurate because it starts with the LR(0) table and resolves lookahead ambiguities as necessary by tracing the LR(0) table and splitting the minimum number of states, and because there is no need for generalized set manipulation.},
	Annote = {Spector clearly explains in one page what Pager spent ten pages being confusing about. Basically: Generate an LR(0) parser, throw in one token of lookahead, zero in on inadequate states, and split them to reflect the left context that suffices to disambiguate them. Spector includes output from a parser generator he wrote that employs this technique.

Spector also gives a good, concise argument for why LR(1) parser generators are better than LALR(1). His arguments against LALR(1) parser generators are still valid twenty years later.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFAuLi8uLi9QYXBlcnMvU3BlY3Rvci9TcGVjdG9yIC0gRWZmaWNpZW50IGZ1bGwgTFIoSSkgcGFyc2VyIGdlbmVyYXRpb24gKDE5ODgpLnBkZtIbDxwdV05TLmRhdGFPEQIIAAAAAAIIAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAugiMfU3BlY3RvciAtIEVmZmljaWVudCAjMkU4MjE3LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC6CF8OwZuVQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAB1NwZWN0b3IAABAACAAAwTR+XQAAABEACAAAw7CtNQAAAAEAEAAugiMALZE/AANHrAAAa9gAAgBAT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlNwZWN0b3I6U3BlY3RvciAtIEVmZmljaWVudCAjMkU4MjE3LnBkZgAOAHgAOwBTAHAAZQBjAHQAbwByACAALQAgAEUAZgBmAGkAYwBpAGUAbgB0ACAAZgB1AGwAbAAgAEwAUgAoAEkAKQAgAHAAYQByAHMAZQByACAAZwBlAG4AZQByAGEAdABpAG8AbgAgACgAMQA5ADgAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFdVc2Vycy9qZXJlbXkvUGFwZXJzL1NwZWN0b3IvU3BlY3RvciAtIEVmZmljaWVudCBmdWxsIExSKEkpIHBhcnNlciBnZW5lcmF0aW9uICgxOTg4KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAP0BAgEKAxYDGAMdAyYDMQM1A0MDSgNTA1gDWwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANo},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/57669.57684}}

@article{Appel:SSA-is-functional:1998,
	Address = {New York, NY, USA},
	Author = {Andrew W. Appel},
	Date-Added = {2007-12-23 01:26:18 -0500},
	Date-Modified = {2008-01-14 01:39:56 -0500},
	Doi = {http://doi.acm.org/10.1145/278283.278285},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Keywords = {functional languages, intermediate representations},
	Local-Url = {file://localhost/Users/jeremy/Papers/Appel/Appel%20-%20SSA%20is%20functional%20programming%20(1998).pdf},
	Number = {4},
	Pages = {17--20},
	Publisher = {ACM},
	Title = {SSA is functional programming},
	Volume = {33},
	Year = {1998},
	Abstract = {Static Single-Assignment (SSA) form is an intermediate language designed to make optimization clean and efficient for imperative-language (Fortran, C) compilers. Lambda-calculus is an intermediate language that makes optimization clean and efficient for functional-language (Scheme, ML, Haskell) compilers. The SSA community draws pictures of graphs with basic blocks and flow edges, and the functional-language community writes lexically nested functions, but (as Richard Kelsey recently pointed out [9]) they're both doing exactly the same thing in different notation.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEMuLi8uLi9QYXBlcnMvQXBwZWwvQXBwZWwgLSBTU0EgaXMgZnVuY3Rpb25hbCBwcm9ncmFtbWluZyAoMTk5OCkucGRm0hsPHB1XTlMuZGF0YU8RAeAAAAAAAeAAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2aGx9BcHBlbCAtIFNTQSBpcyBmdW5jdCMyRDlBMTgucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZoYw5Npx1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAFQXBwZWwAABAACAAAwTR+XQAAABEACAAAw5OwFwAAAAEAEAAtmhsALZE/AANHrAAAa9gAAgA+T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkFwcGVsOkFwcGVsIC0gU1NBIGlzIGZ1bmN0IzJEOUExOC5wZGYADgBiADAAQQBwAHAAZQBsACAALQAgAFMAUwBBACAAaQBzACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMQA5ADkAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAEpVc2Vycy9qZXJlbXkvUGFwZXJzL0FwcGVsL0FwcGVsIC0gU1NBIGlzIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgKDE5OTgpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgDwAPUA/QLhAuMC6ALxAvwDAAMOAxUDHgMjAyYAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADMw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/278283.278285}}

@article{Ball:Paths:1999,
	Address = {New York, NY, USA},
	Author = {Thomas Ball},
	Date-Added = {2007-12-23 01:23:34 -0500},
	Date-Modified = {2008-01-14 01:39:32 -0500},
	Doi = {http://doi.acm.org/10.1145/307903.307910},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Keywords = {functional languages, imperative languages},
	Local-Url = {file://localhost/Users/jeremy/Papers/Ball/Ball%20-%20Paths%20between%20imperative%20and%20functional%20programming%20(1999).pdf},
	Number = {2},
	Pages = {21--25},
	Publisher = {ACM},
	Title = {Paths between imperative and functional programming},
	Volume = {34},
	Year = {1999},
	Abstract = {This article explores relationships between imperative and functional programming by viewing a program as a set of paths. We argue, through a small case study, that the presence of infeasible (or unexecutable) paths makes programs harder to understand. We identify two main causes of infeasible paths, "unnecessary" sequencing and destructive update, hallmarks of an imperative programming style. Functional programming eschews sequencing and destructive update, which can result in programs with fewer infeasible paths that are easier to understand. No proofs are included. We intend to provoke discussion regarding imperative and functional programming styles.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFcuLi8uLi9QYXBlcnMvQmFsbC9CYWxsIC0gUGF0aHMgYmV0d2VlbiBpbXBlcmF0aXZlIGFuZCBmdW5jdGlvbmFsIHByb2dyYW1taW5nICgxOTk5KS5wZGbSGw8cHVdOUy5kYXRhTxECHAAAAAACHAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZoSH0JhbGwgLSBQYXRocyBiZXR3ZWVuIzJEOUEwRC5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtmg3Dk2mfUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAARCYWxsABAACAAAwTR+XQAAABEACAAAw5Ov7wAAAAEAEAAtmhIALZE/AANHrAAAa9gAAgA9T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkJhbGw6QmFsbCAtIFBhdGhzIGJldHdlZW4jMkQ5QTBELnBkZgAADgCMAEUAQgBhAGwAbAAgAC0AIABQAGEAdABoAHMAIABiAGUAdAB3AGUAZQBuACAAaQBtAHAAZQByAGEAdABpAHYAZQAgAGEAbgBkACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMQA5ADkAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF5Vc2Vycy9qZXJlbXkvUGFwZXJzL0JhbGwvQmFsbCAtIFBhdGhzIGJldHdlZW4gaW1wZXJhdGl2ZSBhbmQgZnVuY3Rpb25hbCBwcm9ncmFtbWluZyAoMTk5OSkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQQBCQERAzEDMwM4A0EDTANQA14DZQNuA3MDdgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOD},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/307903.307910}}

@inproceedings{Thiemann:Unboxed:1995,
	Address = {New York, NY, USA},
	Author = {Peter J. Thiemann},
	Booktitle = {FPCA '95: Proceedings of the seventh international conference on Functional programming languages and computer architecture},
	Date-Added = {2007-12-22 21:40:38 -0500},
	Date-Modified = {2007-12-22 21:40:58 -0500},
	Doi = {http://doi.acm.org/10.1145/224164.224175},
	Isbn = {0-89791-719-7},
	Keywords = {compilation, unboxing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Thiemann/Thiemann%20-%20Unboxed%20values%20and%20polymorphic%20typing%20revisited%20(1995).pdf},
	Location = {La Jolla, California, United States},
	Pages = {24--35},
	Publisher = {ACM},
	Title = {Unboxed values and polymorphic typing revisited},
	Year = {1995},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFsuLi8uLi9QYXBlcnMvVGhpZW1hbm4vVGhpZW1hbm4gLSBVbmJveGVkIHZhbHVlcyBhbmQgcG9seW1vcnBoaWMgdHlwaW5nIHJldmlzaXRlZCAoMTk5NSkucGRm0hsPHB1XTlMuZGF0YU8RAigAAAAAAigAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2UhB9UaGllbWFubiAtIFVuYm94ZWQgdiMyRDk0ODAucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZSAw5M0x1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIVGhpZW1hbm4AEAAIAADBNH5dAAAAEQAIAADDk3sXAAAAAQAQAC2UhAAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6VGhpZW1hbm46VGhpZW1hbm4gLSBVbmJveGVkIHYjMkQ5NDgwLnBkZgAADgCMAEUAVABoAGkAZQBtAGEAbgBuACAALQAgAFUAbgBiAG8AeABlAGQAIAB2AGEAbAB1AGUAcwAgAGEAbgBkACAAcABvAGwAeQBtAG8AcgBwAGgAaQBjACAAdAB5AHAAaQBuAGcAIAByAGUAdgBpAHMAaQB0AGUAZAAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGJVc2Vycy9qZXJlbXkvUGFwZXJzL1RoaWVtYW5uL1RoaWVtYW5uIC0gVW5ib3hlZCB2YWx1ZXMgYW5kIHBvbHltb3JwaGljIHR5cGluZyByZXZpc2l0ZWQgKDE5OTUpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEIAQ0BFQNBA0MDSANRA1wDYANuA3UDfgODA4YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/224164.224175}}

@inproceedings{Shao:A-type-based:1995,
	Address = {New York, NY, USA},
	Author = {Zhong Shao and Andrew W. Appel},
	Booktitle = {PLDI '95: Proceedings of the ACM SIGPLAN 1995 conference on Programming language design and implementation},
	Date-Added = {2007-12-22 21:36:46 -0500},
	Date-Modified = {2008-01-02 18:49:53 -0500},
	Doi = {http://doi.acm.org/10.1145/207110.207123},
	Isbn = {0-89791-697-2},
	Keywords = {history of computing, compilation},
	Local-Url = {file://localhost/Users/jeremy/Papers/Shao/Shao-Appel%20-%20A%20type-based%20compiler%20for%20standard%20ML%20(1995).pdf},
	Location = {La Jolla, California, United States},
	Pages = {116--129},
	Publisher = {ACM},
	Read = {Yes},
	Title = {A type-based compiler for standard ML},
	Year = {1995},
	Abstract = {Compile-time type information should be valuable in efficient compilation of statically typed functional languages such as Standard ML. But how should type-directed compilation work in real compilers, and how much performance gain will type-based optimizations yield? In order to support more efficient data representations and gain more experience about type-directed compilation, we have implemented a new type-based middle end and back end for the Standard ML of New Jersey compiler. We describe the basic design of the new compiler, identify a number of practical issues, and then compare the performance of our new compiler with the old non-type-based compiler. Our measurement shows that a combination of several simple type-based optimizations reduces heap allocation by 36%; and improves the already-efficient code generated by the old non-type-based compiler by about 19% on a DECstation 500.},
	Annote = {I'll need to reread this one. It's pretty dense. The conclusion sheds a lot of light on why they're bothering with this, but a lot of the story seems tied up in Appel's book "Compiling with Continuations" and its development of CPS as an intermediate representation.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE8uLi8uLi9QYXBlcnMvU2hhby9TaGFvLUFwcGVsIC0gQSB0eXBlLWJhc2VkIGNvbXBpbGVyIGZvciBzdGFuZGFyZCBNTCAoMTk5NSkucGRm0hsPHB1XTlMuZGF0YU8RAgQAAAAAAgQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2UbR9TaGFvLUFwcGVsIC0gQSB0eXBlLSMyRDk0NkIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZRrw5M0GVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAEU2hhbwAQAAgAAME0fl0AAAARAAgAAMOTemkAAAABABAALZRtAC2RPwADR6wAAGvYAAIAPU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpTaGFvOlNoYW8tQXBwZWwgLSBBIHR5cGUtIzJEOTQ2Qi5wZGYAAA4AfAA9AFMAaABhAG8ALQBBAHAAcABlAGwAIAAtACAAQQAgAHQAeQBwAGUALQBiAGEAcwBlAGQAIABjAG8AbQBwAGkAbABlAHIAIABmAG8AcgAgAHMAdABhAG4AZABhAHIAZAAgAE0ATAAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFZVc2Vycy9qZXJlbXkvUGFwZXJzL1NoYW8vU2hhby1BcHBlbCAtIEEgdHlwZS1iYXNlZCBjb21waWxlciBmb3Igc3RhbmRhcmQgTUwgKDE5OTUpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD8AQEBCQMRAxMDGAMhAywDMAM+A0UDTgNTA1YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADYw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/207110.207123}}

@article{Fradet:Compilation:1991,
	Address = {New York, NY, USA},
	Author = {Pascal Fradet and Daniel Le M\'{e}tayer},
	Date-Added = {2007-12-22 21:11:18 -0500},
	Date-Modified = {2007-12-22 21:12:37 -0500},
	Doi = {http://doi.acm.org/10.1145/114005.102805},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Keywords = {compilation},
	Local-Url = {file://localhost/Users/jeremy/Papers/Fradet/Fradet-Metayer%20-%20Compilation%20of%20functional%20languages%20by%20program%20transformation%20(1991).pdf},
	Number = {1},
	Pages = {21--51},
	Publisher = {ACM},
	Title = {Compilation of functional languages by program transformation},
	Volume = {13},
	Year = {1991},
	Abstract = {One of the most important issues concerning functional languages is the efficiency and the correctness of their implementation. We focus on sequential implementations for conventional von Neumann computers. The compilation process is described in terms of program transformations in the functional framework. The original functional expression is transformed into a functional term that can be seen as a traditional machine code. The two main steps are the compilation of the computation rule by the introduction of continuation functions and the compilation of the environment management using combinators. The advantage of this approach is that we do not have to introduce an abstract machine, which makes correctness proofs much simpler. As far as efficiency is concerned, this approach is promising since many optimizations can be described and formally justified in the functional framework.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEG0uLi8uLi9QYXBlcnMvRnJhZGV0L0ZyYWRldC1NZXRheWVyIC0gQ29tcGlsYXRpb24gb2YgZnVuY3Rpb25hbCBsYW5ndWFnZXMgYnkgcHJvZ3JhbSB0cmFuc2Zvcm1hdGlvbiAoMTk5MSkucGRm0hsPHB1XTlMuZGF0YU8RAl4AAAAAAl4AAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2UDx9GcmFkZXQtTWV0YXllciAtIENvbSMyRDk0MEQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZQNw5MuQVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGRnJhZGV0ABAACAAAwTR+XQAAABEACAAAw5N0kQAAAAEAEAAtlA8ALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOkZyYWRldDpGcmFkZXQtTWV0YXllciAtIENvbSMyRDk0MEQucGRmAAAOALQAWQBGAHIAYQBkAGUAdAAtAE0AZQB0AGEAeQBlAHIAIAAtACAAQwBvAG0AcABpAGwAYQB0AGkAbwBuACAAbwBmACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgAGwAYQBuAGcAdQBhAGcAZQBzACAAYgB5ACAAcAByAG8AZwByAGEAbQAgAHQAcgBhAG4AcwBmAG8AcgBtAGEAdABpAG8AbgAgACgAMQA5ADkAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHRVc2Vycy9qZXJlbXkvUGFwZXJzL0ZyYWRldC9GcmFkZXQtTWV0YXllciAtIENvbXBpbGF0aW9uIG9mIGZ1bmN0aW9uYWwgbGFuZ3VhZ2VzIGJ5IHByb2dyYW0gdHJhbnNmb3JtYXRpb24gKDE5OTEpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEaAR8BJwOJA4sDkAOZA6QDqAO2A70DxgPLA84AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAD2w==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/114005.102805}}

@article{Kulkarni:Fast:2005,
	Address = {New York, NY, USA},
	Author = {Prasad A. Kulkarni and Stephen R. Hines and David B. Whalley and Jason D. Hiser and Jack W. Davidson and Douglas L. Jones},
	Date-Added = {2007-12-22 21:09:24 -0500},
	Date-Modified = {2007-12-22 21:10:19 -0500},
	Doi = {http://doi.acm.org/10.1145/1071604.1071607},
	Issn = {1544-3566},
	Journal = {ACM Trans. Archit. Code Optim.},
	Keywords = {optimization phase ordering},
	Local-Url = {file://localhost/Users/jeremy/Papers/Kulkarni/Kulkarni-Hines-Whalley%20-%20Fast%20and%20efficient%20searches%20for%20effective%20optimization-phase%20(2005).pdf},
	Number = {2},
	Pages = {165--198},
	Publisher = {ACM},
	Title = {Fast and efficient searches for effective optimization-phase sequences},
	Volume = {2},
	Year = {2005},
	Abstract = {It has long been known that a fixed ordering of optimization phases will not produce the best code for every application. One approach for addressing this phase-ordering problem is to use an evolutionary algorithm to search for a specific sequence of phases for each module or function. While such searches have been shown to produce more efficient code, the approach can be extremely slow because the application is compiled and possibly executed to evaluate each sequence's effectiveness. Consequently, evolutionary or iterative compilation schemes have been promoted for compilation systems targeting embedded applications where meeting strict constraints on execution time, code size, and power consumption is paramount and longer compilation times may be tolerated in the final stage of development, when an application is compiled one last time and embedded in a product. Unfortunately, even for small embedded applications, the search process can take many hours or even days making the approach less attractive to developers. In this paper, we describe two complementary general approaches for achieving faster searches for effective optimization sequences when using a genetic algorithm. The first approach reduces the search time by avoiding unnecessary executions of the application when possible. Results indicate search time reductions of 62%;, on average, often reducing searches from hours to minutes. The second approach modifies the search so fewer generations are required to achieve the same results. Measurements show this approach decreases the average number of required generations by 59%. These improvements have the potential for making evolutionary compilation a viable choice for tuning embedded applications.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHYuLi8uLi9QYXBlcnMvS3Vsa2FybmkvS3Vsa2FybmktSGluZXMtV2hhbGxleSAtIEZhc3QgYW5kIGVmZmljaWVudCBzZWFyY2hlcyBmb3IgZWZmZWN0aXZlIG9wdGltaXphdGlvbi1waGFzZSAoMjAwNSkucGRm0hsPHB1XTlMuZGF0YU8RAnoAAAAAAnoAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2T8h9LdWxrYXJuaS1IaW5lcy1XaGFsbCMyRDkzRkIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZP7w5MtkFBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIS3Vsa2FybmkAEAAIAADBNH5dAAAAEQAIAADDk3PgAAAAAQAQAC2T8gAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6S3Vsa2Fybmk6S3Vsa2FybmktSGluZXMtV2hhbGwjMkQ5M0ZCLnBkZgAADgDCAGAASwB1AGwAawBhAHIAbgBpAC0ASABpAG4AZQBzAC0AVwBoAGEAbABsAGUAeQAgAC0AIABGAGEAcwB0ACAAYQBuAGQAIABlAGYAZgBpAGMAaQBlAG4AdAAgAHMAZQBhAHIAYwBoAGUAcwAgAGYAbwByACAAZQBmAGYAZQBjAHQAaQB2AGUAIABvAHAAdABpAG0AaQB6AGEAdABpAG8AbgAtAHAAaABhAHMAZQAgACgAMgAwADAANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAH1Vc2Vycy9qZXJlbXkvUGFwZXJzL0t1bGthcm5pL0t1bGthcm5pLUhpbmVzLVdoYWxsZXkgLSBGYXN0IGFuZCBlZmZpY2llbnQgc2VhcmNoZXMgZm9yIGVmZmVjdGl2ZSBvcHRpbWl6YXRpb24tcGhhc2UgKDIwMDUpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBIwEoATADrgOwA7UDvgPJA80D2wPiA+sD8APzAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAABAA=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1071604.1071607}}

@inproceedings{Kulkarni:In-search:2006,
	Address = {New York, NY, USA},
	Author = {Prasad A. Kulkarni and David B. Whalley and Gary S. Tyson and Jack W. Davidson},
	Booktitle = {LCTES '06: Proceedings of the 2006 ACM SIGPLAN/SIGBED conference on Language, compilers, and tool support for embedded systems},
	Date-Added = {2007-12-22 21:07:56 -0500},
	Date-Modified = {2007-12-22 21:08:57 -0500},
	Doi = {http://doi.acm.org/10.1145/1134650.1134663},
	Isbn = {1-59593-362-X},
	Keywords = {optimization phase ordering},
	Local-Url = {file://localhost/Users/jeremy/Papers/Kulkarni/Kulkarni-Whalley-Tyson%20-%20In%20search%20of%20near-optimal%20optimization%20phase%20orderings%20(2006).pdf},
	Location = {Ottawa, Ontario, Canada},
	Pages = {83--92},
	Publisher = {ACM},
	Title = {In search of near-optimal optimization phase orderings},
	Year = {2006},
	Abstract = {Phase ordering is a long standing challenge for traditional optimizing compilers. Varying the order of applying optimization phases to a program can produce different code, with potentially significant performance variation amongst them. A key insight to addressing the phase ordering problem is that many different optimization sequences produce the same code. In an earlier study, we used this observation to restate the phase ordering problem to concentrate on finding all distinct function instances that can be produced due to different phase orderings, instead of attempting to generate code for all possible optimization sequences. Using a novel search algorithm we were able to show that it is possible to exhaustively enumerate the set of all possible function instances that can be produced by different phase orderings in our compiler for most of the functions in our benchmark suite [1]. Finding the optimal function instance within this set for almost any dynamic measure of performance still appears impractical since that would involve execution/simulation of all generated function instances. To find the dynamically optimal function instance we exploit the observation that the enumeration space for a function typically contains a very small number of distinct control flow paths. We simulate only one function instance from each group of function instances having the identical control flow, and use that information to estimate the dynamic performance of the remaining functions in that group. We further show that the estimated dynamic frequency counts obtained by using our method correlate extremely well to simulated processor cycle counts. Thus, by using our measure of dynamic frequencies to identify a small number of the best performing function instances we can often find the optimal phase ordering for a function within a reasonable amount of time. Finally, we perform a case study to evaluate how adept our genetic algorithm is for finding optimal phase orderings within our compiler, and demonstrate how the algorithm can be improved.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHAuLi8uLi9QYXBlcnMvS3Vsa2FybmkvS3Vsa2FybmktV2hhbGxleS1UeXNvbiAtIEluIHNlYXJjaCBvZiBuZWFyLW9wdGltYWwgb3B0aW1pemF0aW9uIHBoYXNlIG9yZGVyaW5ncyAoMjAwNikucGRm0hsPHB1XTlMuZGF0YU8RAmgAAAAAAmgAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2T8h9LdWxrYXJuaS1XaGFsbGV5LVR5cyMyRDkzRUUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZPuw5MtVlBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIS3Vsa2FybmkAEAAIAADBNH5dAAAAEQAIAADDk3OmAAAAAQAQAC2T8gAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6S3Vsa2Fybmk6S3Vsa2FybmktV2hhbGxleS1UeXMjMkQ5M0VFLnBkZgAADgC2AFoASwB1AGwAawBhAHIAbgBpAC0AVwBoAGEAbABsAGUAeQAtAFQAeQBzAG8AbgAgAC0AIABJAG4AIABzAGUAYQByAGMAaAAgAG8AZgAgAG4AZQBhAHIALQBvAHAAdABpAG0AYQBsACAAbwBwAHQAaQBtAGkAegBhAHQAaQBvAG4AIABwAGgAYQBzAGUAIABvAHIAZABlAHIAaQBuAGcAcwAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHdVc2Vycy9qZXJlbXkvUGFwZXJzL0t1bGthcm5pL0t1bGthcm5pLVdoYWxsZXktVHlzb24gLSBJbiBzZWFyY2ggb2YgbmVhci1vcHRpbWFsIG9wdGltaXphdGlvbiBwaGFzZSBvcmRlcmluZ3MgKDIwMDYpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBHQEiASoDlgOYA50DpgOxA7UDwwPKA9MD2APbAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA+g=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1134650.1134663}}

@article{Kumar:When:2004,
	Address = {New York, NY, USA},
	Author = {K. V. Seshu Kumar},
	Date-Added = {2007-12-22 21:06:22 -0500},
	Date-Modified = {2007-12-22 21:07:27 -0500},
	Doi = {http://doi.acm.org/10.1145/981009.981015},
	Issn = {0362-1340},
	Journal = {SIGPLAN Not.},
	Keywords = {compilation, optimization, virtual machines},
	Local-Url = {file://localhost/Users/jeremy/Papers/Kumar/Kumar%20-%20When%20and%20what%20to%20compile-optimize%20in%20a%20virtual%20machine%3F%20(2004).pdf},
	Number = {3},
	Pages = {38--45},
	Publisher = {ACM},
	Title = {When and what to compile/optimize in a virtual machine?},
	Volume = {39},
	Year = {2004},
	Abstract = {To speed up the computation of some of the object languages, virtual machines use dynamic compilation. But due to compilation taking place during user application runtime, one has to choose which methods to compile, so that the compile time has little impact on the total runtime of the actual application. In order to achieve this, we have to use an estimate to determine the process of compilation. Current virtual machines use run time information such as number of calls made to this method, size of the method and as well as number of times the back edges taken to determine the hotness of a method. They use this information against some threshold which does not have any relationship with the method that is being considered for compilation.

Detecting the hot routines is very important from the perspective of performance since optimized methods run 10 times faster than the interpreted version. In this paper we propose a new technique called relative estimation for determining the hotness of the functions. For each method in the application, we estimate the cost/benefits for compilation or optimization by doing method analysis. We select the methods for compilation or optimization initially based on the above metrics using the proposed relative estimation technique. Later on we use the online profile information such as backedge counters and invocation counts to adjust the relative estimation process itself. We have performed experiments to validate the effectiveness of the proposed method on SPECjvm98 benchmark suite and found that up to 4% performance improvement in the application execution time occurs.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEF0uLi8uLi9QYXBlcnMvS3VtYXIvS3VtYXIgLSBXaGVuIGFuZCB3aGF0IHRvIGNvbXBpbGUtb3B0aW1pemUgaW4gYSB2aXJ0dWFsIG1hY2hpbmU/ICgyMDA0KS5wZGbSGw8cHVdOUy5kYXRhTxECLgAAAAACLgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZPgH0t1bWFyIC0gV2hlbiBhbmQgd2hhIzJEOTNENi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtk9bDkyy2UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVLdW1hcgAAEAAIAADBNH5dAAAAEQAIAADDk3MGAAAAAQAQAC2T4AAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6S3VtYXI6S3VtYXIgLSBXaGVuIGFuZCB3aGEjMkQ5M0Q2LnBkZgAOAJYASgBLAHUAbQBhAHIAIAAtACAAVwBoAGUAbgAgAGEAbgBkACAAdwBoAGEAdAAgAHQAbwAgAGMAbwBtAHAAaQBsAGUALQBvAHAAdABpAG0AaQB6AGUAIABpAG4AIABhACAAdgBpAHIAdAB1AGEAbAAgAG0AYQBjAGgAaQBuAGUAPwAgACgAMgAwADAANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGRVc2Vycy9qZXJlbXkvUGFwZXJzL0t1bWFyL0t1bWFyIC0gV2hlbiBhbmQgd2hhdCB0byBjb21waWxlLW9wdGltaXplIGluIGEgdmlydHVhbCBtYWNoaW5lPyAoMjAwNCkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQoBDwEXA0kDSwNQA1kDZANoA3YDfQOGA4sDjgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOb},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/981009.981015}}

@article{Sansom:Formally:1997,
	Address = {New York, NY, USA},
	Author = {Patrick M. Sansom and Simon L. Peyton Jones},
	Date-Added = {2007-12-22 21:03:49 -0500},
	Date-Modified = {2007-12-22 21:04:56 -0500},
	Doi = {http://doi.acm.org/10.1145/244795.244802},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Keywords = {profiling},
	Local-Url = {file://localhost/Users/jeremy/Papers/Sansom/Sansom-Jones%20-%20Formally%20based%20profiling%20for%20higher-order%20functional%20(1997).pdf},
	Number = {2},
	Pages = {334--385},
	Publisher = {ACM},
	Title = {Formally based profiling for higher-order functional languages},
	Volume = {19},
	Year = {1997},
	Abstract = {We present the first source-level profiler for a compiled, nonstrict, higher-order, purely functional language capable of measuring time as well as space usage. Our profiler is implemented in a production-quality optimizing compiler for Haskell and can successfully profile large applications. A unique feature of our approach is that we give a formal specification of the attribution of execution costs to cost centers. This specification enables us to discuss our design decisions in a precise framework, prove properties about the attribution of costs, and examine to effects of different program transformations on the attribution of costs. Since it is not obvious how to map this specification onto a particular implementation, we also present an implementation-oriented operational semantics, and prove it equivalent to the specification.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGIuLi8uLi9QYXBlcnMvU2Fuc29tL1NhbnNvbS1Kb25lcyAtIEZvcm1hbGx5IGJhc2VkIHByb2ZpbGluZyBmb3IgaGlnaGVyLW9yZGVyIGZ1bmN0aW9uYWwgKDE5OTcpLnBkZtIbDxwdV05TLmRhdGFPEQI+AAAAAAI+AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtk8UfU2Fuc29tLUpvbmVzIC0gRm9ybWEjMkQ5M0MzLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC2Tw8OTLFJQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABlNhbnNvbQAQAAgAAME0fl0AAAARAAgAAMOTcqIAAAABABAALZPFAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpTYW5zb206U2Fuc29tLUpvbmVzIC0gRm9ybWEjMkQ5M0MzLnBkZgAADgCeAE4AUwBhAG4AcwBvAG0ALQBKAG8AbgBlAHMAIAAtACAARgBvAHIAbQBhAGwAbAB5ACAAYgBhAHMAZQBkACAAcAByAG8AZgBpAGwAaQBuAGcAIABmAG8AcgAgAGgAaQBnAGgAZQByAC0AbwByAGQAZQByACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgACgAMQA5ADkANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGlVc2Vycy9qZXJlbXkvUGFwZXJzL1NhbnNvbS9TYW5zb20tSm9uZXMgLSBGb3JtYWxseSBiYXNlZCBwcm9maWxpbmcgZm9yIGhpZ2hlci1vcmRlciBmdW5jdGlvbmFsICgxOTk3KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQ8BFAEcA14DYANlA24DeQN9A4sDkgObA6ADowAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOw},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/244795.244802}}

@inproceedings{Cardelli:Compiling:1984,
	Address = {New York, NY, USA},
	Author = {Luca Cardelli},
	Booktitle = {LFP '84: Proceedings of the 1984 ACM Symposium on LISP and functional programming},
	Date-Added = {2007-12-22 20:58:15 -0500},
	Date-Modified = {2008-01-02 18:37:41 -0500},
	Doi = {http://doi.acm.org/10.1145/800055.802037},
	Isbn = {0-89791-142-3},
	Keywords = {history of computing, compilation},
	Local-Url = {file://localhost/Users/jeremy/Papers/Cardelli/Cardelli%20-%20Compiling%20a%20functional%20language%20(1984).pdf},
	Location = {Austin, Texas, United States},
	Pages = {208--217},
	Publisher = {ACM},
	Rating = {2},
	Read = {Yes},
	Title = {Compiling a functional language},
	Year = {1984},
	Abstract = {This paper summarizes my experience in implementing a compiler for a functional language. The language is ML(1) [Milner 84] and the compiler was first implemented in 1980 as a personal project when I was a postgraduate student at the University of Edinburgh(2). At the time, I was familiar with programming language semantics but knew very little about compiler technology; interpreters had been my main programming concern. Major influences in the design of this compiler have been [Steele 77] [Steele 78] and the implementation folklore for statically and dynamically scoped dialects of Lisp [Allen 78]. As a result, the internal structure of the compiler is fairly unorthodox, if compared for example with [Aho 78]. Anyway, a compiler for a language like ML has to be different. ML is interactive, statically scoped, strongly typed, polymorphic, and has first class higher-order functions, type inference and dynamic allocation. These features preclude many well-known implementation styles, particularly the ones used for Lisp (because of static scoping), the Algol family (because of functional values) and C (because of nested scoping and strong typing). The interaction of these features is what gives ML its ``character'', and makes compilation challenging. The compiler has been recently partially converted to the new ML standard. The major points of interest which are discussed in this paper are: (a) the interactive interpreter-like usage; (b) the polymorphic type inference algorithm; (c) the compilation of pattern matching; (d) the optimization of the representation of user defined data types; (e) the compilation of functional closures, function application and variable access; (f) the intermediate abstract machine and its formal operational semantics; (g) modules and type-safe separate compilation.},
	Annote = {Regards functional compilation as distinct from imperative, and considers techniques such as register allocation to be a "mistake in functional languages because of frequent context switching" (209). In building her compiler, Cardelli drew primarily on Lisp compilation experience and folklore, rather than imperative compilation theory and technique as exemplified in the dragon book.

The module system was still under construction at the time. Already uses unboxed representations for small values (booleans, small ints, etc.). Discusses pattern-matching via discrimination trees in some detail. Correctly observes that how to represent the many datatypes, particularly closures, is an important issue. Argues for use of an abstract machine in order to simplify the process of compilation, and seems particularly fond of using a typefree machine. Her functional abstract machine (FAM) is basically an SECD machine, though it uses several other stacks for different purposes.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEsuLi8uLi9QYXBlcnMvQ2FyZGVsbGkvQ2FyZGVsbGkgLSBDb21waWxpbmcgYSBmdW5jdGlvbmFsIGxhbmd1YWdlICgxOTg0KS5wZGbSGw8cHVdOUy5kYXRhTxEB+AAAAAAB+AACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZOmH0NhcmRlbGxpIC0gQ29tcGlsaW5nIzJEOTNBMi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtk6LDkys+UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAhDYXJkZWxsaQAQAAgAAME0fl0AAAARAAgAAMOTcY4AAAABABAALZOmAC2RPwADR6wAAGvYAAIAQU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpDYXJkZWxsaTpDYXJkZWxsaSAtIENvbXBpbGluZyMyRDkzQTIucGRmAAAOAGwANQBDAGEAcgBkAGUAbABsAGkAIAAtACAAQwBvAG0AcABpAGwAaQBuAGcAIABhACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgAGwAYQBuAGcAdQBhAGcAZQAgACgAMQA5ADgANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFJVc2Vycy9qZXJlbXkvUGFwZXJzL0NhcmRlbGxpL0NhcmRlbGxpIC0gQ29tcGlsaW5nIGEgZnVuY3Rpb25hbCBsYW5ndWFnZSAoMTk4NCkucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPgA/QEFAwEDAwMIAxEDHAMgAy4DNQM+A0MDRgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANT},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/800055.802037}}

@article{Webber:Optimization:1995,
	Address = {New York, NY, USA},
	Author = {Adam Webber},
	Date-Added = {2007-12-22 20:52:19 -0500},
	Date-Modified = {2007-12-22 20:57:44 -0500},
	Doi = {http://doi.acm.org/10.1145/201059.201067},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Keywords = {optimization},
	Local-Url = {file://localhost/Users/jeremy/Papers/Webber/Webber%20-%20Optimization%20of%20functional%20programs%20by%20grammar%20thinning%20(1995).pdf},
	Number = {2},
	Pages = {293--330},
	Publisher = {ACM},
	Title = {Optimization of functional programs by grammar thinning},
	Volume = {17},
	Year = {1995},
	Abstract = {We describe a new technique for optimizing first-order functional programs. Programs are represented as graph grammars, and optimization proceeds by counterexample: when a graph generated by the grammar is found to contain an unnecessary computation, the optimizer attempts to reformulates the grammar so that it never again generates any graph that contains that counterexample. This kind of program reformulation corresponds to an interesting problem on context-free grammars. Our reformulation technique is derived from an (approximate) solution to this CFG problem. An optimizer called Thinner is the proof of concept for this technique. Thinner is a fully automatic, source-to-source optimizer for a Lisp-like language of purely functional, first-order programs. Thinner rediscovers a wide variety of common compiler optimizations. It also finds other more exotic transformations, including the well-known Fibonacci reformulation and the Knuth-Morris-Pratt optimization.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEF8uLi8uLi9QYXBlcnMvV2ViYmVyL1dlYmJlciAtIE9wdGltaXphdGlvbiBvZiBmdW5jdGlvbmFsIHByb2dyYW1zIGJ5IGdyYW1tYXIgdGhpbm5pbmcgKDE5OTUpLnBkZtIbDxwdV05TLmRhdGFPEQI0AAAAAAI0AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtk3YfV2ViYmVyIC0gT3B0aW1pemF0aW8jMkQ5MzcyLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC2TcsOTKklQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABldlYmJlcgAQAAgAAME0fl0AAAARAAgAAMOTcJkAAAABABAALZN2AC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpXZWJiZXI6V2ViYmVyIC0gT3B0aW1pemF0aW8jMkQ5MzcyLnBkZgAADgCYAEsAVwBlAGIAYgBlAHIAIAAtACAATwBwAHQAaQBtAGkAegBhAHQAaQBvAG4AIABvAGYAIABmAHUAbgBjAHQAaQBvAG4AYQBsACAAcAByAG8AZwByAGEAbQBzACAAYgB5ACAAZwByAGEAbQBtAGEAcgAgAHQAaABpAG4AbgBpAG4AZwAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGZVc2Vycy9qZXJlbXkvUGFwZXJzL1dlYmJlci9XZWJiZXIgLSBPcHRpbWl6YXRpb24gb2YgZnVuY3Rpb25hbCBwcm9ncmFtcyBieSBncmFtbWFyIHRoaW5uaW5nICgxOTk1KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBDAERARkDUQNTA1gDYQNsA3ADfgOFA44DkwOWAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA6M=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/201059.201067}}

@inproceedings{Marlow:Making:2004,
	Address = {New York, NY, USA},
	Author = {Simon Marlow and Simon Peyton Jones},
	Booktitle = {ICFP '04: Proceedings of the ninth ACM SIGPLAN international conference on Functional programming},
	Date-Added = {2007-12-22 20:48:03 -0500},
	Date-Modified = {2008-01-14 01:40:34 -0500},
	Doi = {http://doi.acm.org/10.1145/1016850.1016856},
	Isbn = {1-58113-905-5},
	Keywords = {optimization, functional languages},
	Local-Url = {file://localhost/Users/jeremy/Papers/Marlow/Marlow-Jones%20-%20Making%20a%20fast%20curry%20push-enter%20vs.%20eval-apply%20(2004).pdf},
	Location = {Snow Bird, UT, USA},
	Pages = {4--15},
	Publisher = {ACM},
	Title = {Making a fast curry: push/enter vs. eval/apply for higher-order languages},
	Year = {2004},
	Abstract = {Higher-order languages that encourage currying are implemented using one of two basic evaluation models: push/enter or eval/apply. Implementors use their intuition and qualitative judgements to choose one model or the other.Our goal in this paper is to provide, for the first time, a more substantial basis for this choice, based on our qualitative and quantitative experience of implementing both models in a state-of-the-art compiler for Haskell.Our conclusion is simple, and contradicts our initial intuition: compiled implementations should use eval/apply.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFsuLi8uLi9QYXBlcnMvTWFybG93L01hcmxvdy1Kb25lcyAtIE1ha2luZyBhIGZhc3QgY3VycnkgcHVzaC1lbnRlciB2cy4gZXZhbC1hcHBseSAoMjAwNCkucGRm0hsPHB1XTlMuZGF0YU8RAigAAAAAAigAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2TVB9NYXJsb3ctSm9uZXMgLSBNYWtpbiMyRDkzNTIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZNSw5MpJFBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGTWFybG93ABAACAAAwTR+XQAAABEACAAAw5NvdAAAAAEAEAAtk1QALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOk1hcmxvdzpNYXJsb3ctSm9uZXMgLSBNYWtpbiMyRDkzNTIucGRmAAAOAJAARwBNAGEAcgBsAG8AdwAtAEoAbwBuAGUAcwAgAC0AIABNAGEAawBpAG4AZwAgAGEAIABmAGEAcwB0ACAAYwB1AHIAcgB5ACAAcAB1AHMAaAAtAGUAbgB0AGUAcgAgAHYAcwAuACAAZQB2AGEAbAAtAGEAcABwAGwAeQAgACgAMgAwADAANAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGJVc2Vycy9qZXJlbXkvUGFwZXJzL01hcmxvdy9NYXJsb3ctSm9uZXMgLSBNYWtpbmcgYSBmYXN0IGN1cnJ5IHB1c2gtZW50ZXIgdnMuIGV2YWwtYXBwbHkgKDIwMDQpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEIAQ0BFQNBA0MDSANRA1wDYANuA3UDfgODA4YAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADkw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1016850.1016856}}

@article{Douence:A-systematic:1998,
	Address = {New York, NY, USA},
	Author = {R\'{e}mi Douence and Pascal Fradet},
	Date-Added = {2007-12-22 20:46:59 -0500},
	Date-Modified = {2008-01-14 01:39:13 -0500},
	Doi = {http://doi.acm.org/10.1145/276393.276397},
	Issn = {0164-0925},
	Journal = {ACM Trans. Program. Lang. Syst.},
	Keywords = {functional languages},
	Local-Url = {file://localhost/Users/jeremy/Papers/Douence/Douence-Fradet%20-%20A%20systematic%20study%20of%20functional%20language%20implementations%20(1998).pdf},
	Number = {2},
	Pages = {344--387},
	Publisher = {ACM},
	Title = {A systematic study of functional language implementations},
	Volume = {20},
	Year = {1998},
	Abstract = {We introduce a unified framework to describe, relate, compare, and classify functional language implementations. The compilation process is expressed as a succession of program transformations in the common framework. At each step, different transformations model fundamental choices. A benefit of this approach is to structure and decompose the implementation process. The correctness proofs can be tackled independently for each step and amount to proving program transformations in the functional world. This approach also paves the way to formal comparisons by making it possible to estimate the complexity of individual transformations or compositions of them. Our study aims at covering the whole known design space of sequential functional language implementations. In particular, we consider call-by-value, call-by-name, call-by-need reduction strategies as well as environment- and graph-based implementations. We describe for each compilation step the diverse alternatives as program transformations. In some cases, we illustrate how to compare or relate compilation techniques, express global optimizations, or hybrid implementations. We also provide a classification of well-known abstract machines.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGouLi8uLi9QYXBlcnMvRG91ZW5jZS9Eb3VlbmNlLUZyYWRldCAtIEEgc3lzdGVtYXRpYyBzdHVkeSBvZiBmdW5jdGlvbmFsIGxhbmd1YWdlIGltcGxlbWVudGF0aW9ucyAoMTk5OCkucGRm0hsPHB1XTlMuZGF0YU8RAlYAAAAAAlYAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2TSR9Eb3VlbmNlLUZyYWRldCAtIEEgcyMyRDkzNDYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZNGw5Moz1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAHRG91ZW5jZQAAEAAIAADBNH5dAAAAEQAIAADDk28fAAAAAQAQAC2TSQAtkT8AA0esAABr2AACAEBPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6RG91ZW5jZTpEb3VlbmNlLUZyYWRldCAtIEEgcyMyRDkzNDYucGRmAA4ArABVAEQAbwB1AGUAbgBjAGUALQBGAHIAYQBkAGUAdAAgAC0AIABBACAAcwB5AHMAdABlAG0AYQB0AGkAYwAgAHMAdAB1AGQAeQAgAG8AZgAgAGYAdQBuAGMAdABpAG8AbgBhAGwAIABsAGEAbgBnAHUAYQBnAGUAIABpAG0AcABsAGUAbQBlAG4AdABhAHQAaQBvAG4AcwAgACgAMQA5ADkAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAHFVc2Vycy9qZXJlbXkvUGFwZXJzL0RvdWVuY2UvRG91ZW5jZS1GcmFkZXQgLSBBIHN5c3RlbWF0aWMgc3R1ZHkgb2YgZnVuY3Rpb25hbCBsYW5ndWFnZSBpbXBsZW1lbnRhdGlvbnMgKDE5OTgpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBFwEcASQDfgOAA4UDjgOZA50DqwOyA7sDwAPDAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA9A=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/276393.276397}}

@inproceedings{Nederhof:Efficient:1996,
	Address = {Morristown, NJ, USA},
	Author = {Mark-Jan Nederhof and Giorgio Satta},
	Booktitle = {Proceedings of the 34th annual meeting on Association for Computational Linguistics},
	Date-Added = {2007-12-22 20:28:27 -0500},
	Date-Modified = {2007-12-22 20:32:55 -0500},
	Doi = {http://dx.doi.org/10.3115/981863.981895},
	Keywords = {parsing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Nederhof/Nederhof-Satta%20-%20Efficient%20tabular%20LR%20parsing%20(1996).pdf},
	Location = {Santa Cruz, California},
	Pages = {239--246},
	Publisher = {Association for Computational Linguistics},
	Title = {Efficient tabular LR parsing},
	Year = {1996},
	Abstract = {We give a new treatment of tabular LR parsing, which is an alternative to Tomita's generalized LR algorithm. The advantage is twofold. Firstly, our treatment is conceptually more attractive because it uses simpler concepts, such as grammar transformations and standard tabulation techniques also know as chart parsing. Secondly, the static and dynamic complexity of parsing, both in space and time, is significantly reduced.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE4uLi8uLi9QYXBlcnMvTmVkZXJob2YvTmVkZXJob2YtU2F0dGEgLSBFZmZpY2llbnQgdGFidWxhciBMUiBwYXJzaW5nICgxOTk2KS5wZGbSGw8cHVdOUy5kYXRhTxECAgAAAAACAgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZLtH05lZGVyaG9mLVNhdHRhIC0gRWZmIzJEOTJFOS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkunDkyRsUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAhOZWRlcmhvZgAQAAgAAME0fl0AAAARAAgAAMOTarwAAAABABAALZLtAC2RPwADR6wAAGvYAAIAQU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpOZWRlcmhvZjpOZWRlcmhvZi1TYXR0YSAtIEVmZiMyRDkyRTkucGRmAAAOAHIAOABOAGUAZABlAHIAaABvAGYALQBTAGEAdAB0AGEAIAAtACAARQBmAGYAaQBjAGkAZQBuAHQAIAB0AGEAYgB1AGwAYQByACAATABSACAAcABhAHIAcwBpAG4AZwAgACgAMQA5ADkANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFVVc2Vycy9qZXJlbXkvUGFwZXJzL05lZGVyaG9mL05lZGVyaG9mLVNhdHRhIC0gRWZmaWNpZW50IHRhYnVsYXIgTFIgcGFyc2luZyAoMTk5NikucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD7AQABCAMOAxADFQMeAykDLQM7A0IDSwNQA1MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADYA==},
	Bdsk-Url-1 = {http://dx.doi.org/10.3115/981863.981895}}

@inproceedings{Wyk:Context-aware:2007,
	Address = {New York, NY, USA},
	Author = {Eric R. Van Wyk and August C. Schwerdfeger},
	Booktitle = {GPCE '07: Proceedings of the 6th international conference on Generative programming and component engineering},
	Date-Added = {2007-12-22 20:28:09 -0500},
	Date-Modified = {2007-12-22 20:33:22 -0500},
	Doi = {http://doi.acm.org/10.1145/1289971.1289983},
	Isbn = {978-1-59593-855-8},
	Keywords = {parsing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Wyk/Wyk-Schwerdfeger%20-%20Context-aware%20scanning%20for%20parsing%20extensible%20languages%20(2007).pdf},
	Location = {Salzburg, Austria},
	Pages = {63--72},
	Publisher = {ACM},
	Title = {Context-aware scanning for parsing extensible languages},
	Year = {2007},
	Abstract = {This paper introduces new parsing and context-aware scanning algorithms in which the scanner uses contextual information to disambiguate lexical syntax. The parser uses a slightly modified LR-style algorithm that passes to the scanner the set of valid symbols that the scanner may return at that point in parsing. This set is those terminals whose entries in the parse table for the current parse state are shift, reduce, or accept, but not error. The scanner then only returns tokens in this set. An analysis is given that can statically verify that the scanner will never return more than one token for a single input. Context-aware scanning is especially useful when parsing and scanning extensible languages in which domain specific languages can be embedded. It has been used in extensible versions of Java 1.4 and ANSI C. We illustrate this approach with a declarative specification of a subset of Java and extensions that embed SQL queries and Boolean expression tables into Java.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGYuLi8uLi9QYXBlcnMvV3lrL1d5ay1TY2h3ZXJkZmVnZXIgLSBDb250ZXh0LWF3YXJlIHNjYW5uaW5nIGZvciBwYXJzaW5nIGV4dGVuc2libGUgbGFuZ3VhZ2VzICgyMDA3KS5wZGbSGw8cHVdOUy5kYXRhTxECSgAAAAACSgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZLhH1d5ay1TY2h3ZXJkZmVnZXIgLSBDIzJEOTJERi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkt/DkyRBUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAANXeWsAABAACAAAwTR+XQAAABEACAAAw5NqkQAAAAEAEAAtkuEALZE/AANHrAAAa9gAAgA8T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOld5azpXeWstU2Nod2VyZGZlZ2VyIC0gQyMyRDkyREYucGRmAA4ArABVAFcAeQBrAC0AUwBjAGgAdwBlAHIAZABmAGUAZwBlAHIAIAAtACAAQwBvAG4AdABlAHgAdAAtAGEAdwBhAHIAZQAgAHMAYwBhAG4AbgBpAG4AZwAgAGYAbwByACAAcABhAHIAcwBpAG4AZwAgAGUAeAB0AGUAbgBzAGkAYgBsAGUAIABsAGEAbgBnAHUAYQBnAGUAcwAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG1Vc2Vycy9qZXJlbXkvUGFwZXJzL1d5ay9XeWstU2Nod2VyZGZlZ2VyIC0gQ29udGV4dC1hd2FyZSBzY2FubmluZyBmb3IgcGFyc2luZyBleHRlbnNpYmxlIGxhbmd1YWdlcyAoMjAwNykucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgETARgBIANuA3ADdQN+A4kDjQObA6IDqwOwA7MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADwA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1289971.1289983}}

@article{Gray:Canonical:1973,
	Address = {New York, NY, USA},
	Author = {James N. Gray and Michael A. Harrison},
	Date-Added = {2007-12-22 20:27:11 -0500},
	Date-Modified = {2007-12-22 20:32:46 -0500},
	Doi = {http://doi.acm.org/10.1145/321752.321755},
	Issn = {0004-5411},
	Journal = {J. ACM},
	Keywords = {parsing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Gray/Gray-Harrison%20-%20Canonical%20Precedence%20Schemes%20(1973).pdf},
	Number = {2},
	Pages = {214--234},
	Publisher = {ACM},
	Title = {Canonical Precedence Schemes},
	Volume = {20},
	Year = {1973},
	Abstract = {A general theory of canonical precedence analysis is defined and studied. The familiar types of precedence analysis such as operator precedence or simple precedence occur as special cases of this theory. Among the theoretical results obtained are a characterization of the structure of precedence relations and the relation of canonical precedence schemes to operator sets.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEkuLi8uLi9QYXBlcnMvR3JheS9HcmF5LUhhcnJpc29uIC0gQ2Fub25pY2FsIFByZWNlZGVuY2UgU2NoZW1lcyAoMTk3MykucGRm0hsPHB1XTlMuZGF0YU8RAfIAAAAAAfIAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2TAB9HcmF5LUhhcnJpc29uIC0gQ2FubyMyRDkyRkQucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZL9w5MkwVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAER3JheQAQAAgAAME0fl0AAAARAAgAAMOTaxEAAAABABAALZMAAC2RPwADR6wAAGvYAAIAPU9kaW46VXNlcnM6amVyZW15OlBhcGVyczpHcmF5OkdyYXktSGFycmlzb24gLSBDYW5vIzJEOTJGRC5wZGYAAA4AcAA3AEcAcgBhAHkALQBIAGEAcgByAGkAcwBvAG4AIAAtACAAQwBhAG4AbwBuAGkAYwBhAGwAIABQAHIAZQBjAGUAZABlAG4AYwBlACAAUwBjAGgAZQBtAGUAcwAgACgAMQA5ADcAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFBVc2Vycy9qZXJlbXkvUGFwZXJzL0dyYXkvR3JheS1IYXJyaXNvbiAtIENhbm9uaWNhbCBQcmVjZWRlbmNlIFNjaGVtZXMgKDE5NzMpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD2APsBAwL5AvsDAAMJAxQDGAMmAy0DNgM7Az4AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADSw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/321752.321755}}

@inproceedings{Pager:The-lane:1973,
	Address = {New York, NY, USA},
	Author = {David Pager},
	Booktitle = {STOC '73: Proceedings of the fifth annual ACM symposium on Theory of computing},
	Date-Added = {2007-12-22 20:26:54 -0500},
	Date-Modified = {2008-01-17 21:17:29 -0500},
	Doi = {http://doi.acm.org/10.1145/800125.804048},
	Keywords = {parsing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Pager/Pager%20-%20The%20lane%20tracing%20algorithm%20for%20constructing%20LR(k)%20(1973).pdf},
	Location = {Austin, Texas, United States},
	Pages = {172--181},
	Publisher = {ACM},
	Rating = {3},
	Read = {Yes},
	Title = {The lane tracing algorithm for constructing LR(k) parsers},
	Year = {1973},
	Abstract = {The paper presents, as far as the author is aware, the first practical general method for constructing LR(k) parsers. It has been used, without computational difficulty, to produce LR(1), LR(2) and LR(3) parsers for grammars of the size of ALGOL.},
	Annote = {Pager's description of LR(0) parsing is the most lucid I've read thus far. Unfortunately, he's confusing when it comes to describing his new ideas. That's likely due to lack of oversight (it is a non-refereed tech report) and Pager still trying to figure out how best to describe his idea. This tech report grew up to be a publication in Acta Informatica.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEFcuLi8uLi9QYXBlcnMvUGFnZXIvUGFnZXIgLSBUaGUgbGFuZSB0cmFjaW5nIGFsZ29yaXRobSBmb3IgY29uc3RydWN0aW5nIExSKGspICgxOTczKS5wZGbSGw8cHVdOUy5kYXRhTxECHAAAAAACHAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZL5H1BhZ2VyIC0gVGhlIGxhbmUgdHJhIzJEOTJGNy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkvfDkySuUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVQYWdlcgAAEAAIAADBNH5dAAAAEQAIAADDk2r+AAAAAQAQAC2S+QAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6UGFnZXI6UGFnZXIgLSBUaGUgbGFuZSB0cmEjMkQ5MkY3LnBkZgAOAIoARABQAGEAZwBlAHIAIAAtACAAVABoAGUAIABsAGEAbgBlACAAdAByAGEAYwBpAG4AZwAgAGEAbABnAG8AcgBpAHQAaABtACAAZgBvAHIAIABjAG8AbgBzAHQAcgB1AGMAdABpAG4AZwAgAEwAUgAoAGsAKQAgACgAMQA5ADcAMwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAF5Vc2Vycy9qZXJlbXkvUGFwZXJzL1BhZ2VyL1BhZ2VyIC0gVGhlIGxhbmUgdHJhY2luZyBhbGdvcml0aG0gZm9yIGNvbnN0cnVjdGluZyBMUihrKSAoMTk3MykucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAQQBCQERAzEDMwM4A0EDTANQA14DZQNuA3MDdgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOD},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/800125.804048}}

@inproceedings{Lammel:Design:2002,
	Address = {New York, NY, USA},
	Author = {Ralf L\"{a}mmel and Joost Visser},
	Booktitle = {RULE '02: Proceedings of the 2002 ACM SIGPLAN workshop on Rule-based programming},
	Date-Added = {2007-12-22 20:17:47 -0500},
	Date-Modified = {2007-12-22 20:19:09 -0500},
	Doi = {http://doi.acm.org/10.1145/570186.570187},
	Isbn = {1-58113-606-4},
	Local-Url = {file://localhost/Users/jeremy/Papers/Lammel/Lammel-Visser%20-%20Design%20patterns%20for%20functional%20strategic%20programming%20(2002).pdf},
	Location = {Pittsburgh, Pennsylvania},
	Pages = {1--14},
	Publisher = {ACM},
	Title = {Design patterns for functional strategic programming},
	Year = {2002},
	Abstract = {We believe that design patterns can be an effective means of consolidating and communicating program construction expertise for functional programming, just as they have proven to be in object-oriented programming. The emergence of combinator libraries that develop a specific domain or programming idiom has intensified, rather than reduced, the need for design patterns.In previous work, we introduced the fundamentals and a supporting combinator library for functional strategic programming. This is an idiom for (general purpose) generic programming based on the notion of a functional strategy: a first-class generic function that can not only be applied to terms of any type, but which also allows generic traversal into subterms and can be customised with type-specific behaviour.This paper seeks to provide practising functional programmers with pragmatic guidance in crafting their own generic programs using functional strategies. To this end, we propose a novel description format for functional design patterns, and we initiate a catalogue of strategy design patterns. These design patterns aim at consolidating strategic programming expertise in accessible form.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGMuLi8uLi9QYXBlcnMvTGFtbWVsL0xhbW1lbC1WaXNzZXIgLSBEZXNpZ24gcGF0dGVybnMgZm9yIGZ1bmN0aW9uYWwgc3RyYXRlZ2ljIHByb2dyYW1taW5nICgyMDAyKS5wZGbSGw8cHVdOUy5kYXRhTxECQAAAAAACQAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZKpH0xhbW1lbC1WaXNzZXIgLSBEZXNpIzJEOTJBNy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkqfDkyG2UERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAZMYW1tZWwAEAAIAADBNH5dAAAAEQAIAADDk2gGAAAAAQAQAC2SqQAtkT8AA0esAABr2AACAD9PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6TGFtbWVsOkxhbW1lbC1WaXNzZXIgLSBEZXNpIzJEOTJBNy5wZGYAAA4AoABPAEwAYQBtAG0AZQBsAC0AVgBpAHMAcwBlAHIAIAAtACAARABlAHMAaQBnAG4AIABwAGEAdAB0AGUAcgBuAHMAIABmAG8AcgAgAGYAdQBuAGMAdABpAG8AbgBhAGwAIABzAHQAcgBhAHQAZQBnAGkAYwAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMgAwADAAMgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGpVc2Vycy9qZXJlbXkvUGFwZXJzL0xhbW1lbC9MYW1tZWwtVmlzc2VyIC0gRGVzaWduIHBhdHRlcm5zIGZvciBmdW5jdGlvbmFsIHN0cmF0ZWdpYyBwcm9ncmFtbWluZyAoMjAwMikucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARABFQEdA2EDYwNoA3EDfAOAA44DlQOeA6MDpgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOz},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/570186.570187}}

@inproceedings{Burchett:Lowering::2007,
	Address = {New York, NY, USA},
	Author = {Kimberley Burchett and Gregory H. Cooper and Shriram Krishnamurthi},
	Booktitle = {PEPM '07: Proceedings of the 2007 ACM SIGPLAN symposium on Partial evaluation and semantics-based program manipulation},
	Date-Added = {2007-12-22 20:14:17 -0500},
	Date-Modified = {2007-12-22 20:56:33 -0500},
	Doi = {http://doi.acm.org/10.1145/1244381.1244393},
	Isbn = {978-1-59593-620-2},
	Keywords = {reactive programming, optimization, static analysis},
	Local-Url = {file://localhost/Users/jeremy/Papers/Burchett/Burchett-Cooper-Krishnamurthi%20-%20Lowering%20a%20static%20optimization%20technique%20for%20transparent%20(2007).pdf},
	Location = {Nice, France},
	Pages = {71--80},
	Publisher = {ACM},
	Title = {Lowering: a static optimization technique for transparent functional reactivity},
	Year = {2007},
	Abstract = {Functional Reactive Programming (FRP) extends traditional functional programming with dataflow evaluation, making it possible to write interactive programs in a declarative style. An FRP language creates a dynamic graph of data dependencies and reacts to changes by propagating updates through the graph. In a transparent FRP language, the primitive operators are implicitly lifted, so they construct graph nodes when they are applied to time-varying values. This model has some attractive properties, but it tends to produce a large graph that is costly to maintain. In this paper, we develop a transformation we call lowering, which improves performance by reducing the size of the graph. We present a static analysis that guides the sound application of this optimization, and we present benchmark results that demonstrate dramatic improvements in both speed and memory usage for real programs.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEHkuLi8uLi9QYXBlcnMvQnVyY2hldHQvQnVyY2hldHQtQ29vcGVyLUtyaXNobmFtdXJ0aGkgLSBMb3dlcmluZyBhIHN0YXRpYyBvcHRpbWl6YXRpb24gdGVjaG5pcXVlIGZvciB0cmFuc3BhcmVudCAoMjAwNykucGRm0hsPHB1XTlMuZGF0YU8RAoIAAAAAAoIAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2Seh9CdXJjaGV0dC1Db29wZXItS3JpcyMyRDIyMTAucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALSIQw4b9mVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAIQnVyY2hldHQAEAAIAADBNH5dAAAAEQAIAADDh0PpAAAAAQAQAC2SegAtkT8AA0esAABr2AACAEFPZGluOlVzZXJzOmplcmVteTpQYXBlcnM6QnVyY2hldHQ6QnVyY2hldHQtQ29vcGVyLUtyaXMjMkQyMjEwLnBkZgAADgDIAGMAQgB1AHIAYwBoAGUAdAB0AC0AQwBvAG8AcABlAHIALQBLAHIAaQBzAGgAbgBhAG0AdQByAHQAaABpACAALQAgAEwAbwB3AGUAcgBpAG4AZwAgAGEAIABzAHQAYQB0AGkAYwAgAG8AcAB0AGkAbQBpAHoAYQB0AGkAbwBuACAAdABlAGMAaABuAGkAcQB1AGUAIABmAG8AcgAgAHQAcgBhAG4AcwBwAGEAcgBlAG4AdAAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAIBVc2Vycy9qZXJlbXkvUGFwZXJzL0J1cmNoZXR0L0J1cmNoZXR0LUNvb3Blci1LcmlzaG5hbXVydGhpIC0gTG93ZXJpbmcgYSBzdGF0aWMgb3B0aW1pemF0aW9uIHRlY2huaXF1ZSBmb3IgdHJhbnNwYXJlbnQgKDIwMDcpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgEmASsBMwO5A7sDwAPJA9QD2APmA+0D9gP7A/4AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAAECw==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1244381.1244393}}

@inproceedings{Swadi:A-monadic:2006,
	Address = {New York, NY, USA},
	Author = {Kedar Swadi and Walid Taha and Oleg Kiselyov and Emir Pasalic},
	Booktitle = {PEPM '06: Proceedings of the 2006 ACM SIGPLAN symposium on Partial evaluation and semantics-based program manipulation},
	Date-Added = {2007-12-22 20:10:38 -0500},
	Date-Modified = {2008-01-14 01:37:22 -0500},
	Doi = {http://doi.acm.org/10.1145/1111542.1111570},
	Isbn = {1-59593-196-1},
	Keywords = {monads, optimization},
	Local-Url = {file://localhost/Users/jeremy/Papers/Swadi/Swadi-Taha-Kiselyov%20-%20A%20monadic%20approach%20for%20avoiding%20code%20duplication%20(2006).pdf},
	Location = {Charleston, South Carolina},
	Pages = {160--169},
	Publisher = {ACM},
	Title = {A monadic approach for avoiding code duplication when staging memoized functions},
	Year = {2006},
	Abstract = {Building program generators that do not duplicate generated code can be challenging. At the same time, code duplication can easily increase both generation time and runtime of generated programs by an exponential factor. We identify an instance of this problem that can arise when memoized functions are staged. Without addressing this problem, it would be impossible to effectively stage dynamic programming algorithms. Intuitively, direct staging undoes the effect of memoization. To solve this problem once and for all, and for any function that uses memoization, we propose a staged monadic combinator library. Experimental results confirm that the library works as expected. Preliminary results also indicate that the library is useful even when memoization is not used.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGQuLi8uLi9QYXBlcnMvU3dhZGkvU3dhZGktVGFoYS1LaXNlbHlvdiAtIEEgbW9uYWRpYyBhcHByb2FjaCBmb3IgYXZvaWRpbmcgY29kZSBkdXBsaWNhdGlvbiAoMjAwNikucGRm0hsPHB1XTlMuZGF0YU8RAkQAAAAAAkQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2Sjh9Td2FkaS1UYWhhLUtpc2VseW92ICMyRDkyOEMucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZKMw5MhP1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAFU3dhZGkAABAACAAAwTR+XQAAABEACAAAw5NnjwAAAAEAEAAtko4ALZE/AANHrAAAa9gAAgA+T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlN3YWRpOlN3YWRpLVRhaGEtS2lzZWx5b3YgIzJEOTI4Qy5wZGYADgCkAFEAUwB3AGEAZABpAC0AVABhAGgAYQAtAEsAaQBzAGUAbAB5AG8AdgAgAC0AIABBACAAbQBvAG4AYQBkAGkAYwAgAGEAcABwAHIAbwBhAGMAaAAgAGYAbwByACAAYQB2AG8AaQBkAGkAbgBnACAAYwBvAGQAZQAgAGQAdQBwAGwAaQBjAGEAdABpAG8AbgAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGtVc2Vycy9qZXJlbXkvUGFwZXJzL1N3YWRpL1N3YWRpLVRhaGEtS2lzZWx5b3YgLSBBIG1vbmFkaWMgYXBwcm9hY2ggZm9yIGF2b2lkaW5nIGNvZGUgZHVwbGljYXRpb24gKDIwMDYpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBEQEWAR4DZgNoA20DdgOBA4UDkwOaA6MDqAOrAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA7g=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1111542.1111570}}

@inproceedings{Hutton:Fold:1998,
	Address = {New York, NY, USA},
	Author = {Graham Hutton},
	Booktitle = {ICFP '98: Proceedings of the third ACM SIGPLAN international conference on Functional programming},
	Date-Added = {2007-12-22 20:08:57 -0500},
	Date-Modified = {2007-12-22 20:11:26 -0500},
	Doi = {http://doi.acm.org/10.1145/289423.289457},
	Isbn = {1-58113-024-4},
	Local-Url = {file://localhost/Users/jeremy/Papers/Hutton/Hutton%20-%20Fold%20and%20unfold%20for%20program%20semantics%20(1998).pdf},
	Location = {Baltimore, Maryland, United States},
	Pages = {280--288},
	Publisher = {ACM},
	Title = {Fold and unfold for program semantics},
	Year = {1998},
	Abstract = {In this paper we explain how recursion operators can be used to structure and reason about program semantics within a functional language. In particular, we show how the recursion operator fold can be used to structure denotational semantics, how the dual recursion operator unfold can be used to structure operational semantics, and how algebraic properties of these operators can be used to reason about program semantics. The techniques are explained with the aid of two main examples, the first concerning arithmetic expressions, and the second concerning Milner's concurrent language CCS. The aim of the paper is to give functional programmers new insights into recursion operators, program semantics, and the relationships between them.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEE0uLi8uLi9QYXBlcnMvSHV0dG9uL0h1dHRvbiAtIEZvbGQgYW5kIHVuZm9sZCBmb3IgcHJvZ3JhbSBzZW1hbnRpY3MgKDE5OTgpLnBkZtIbDxwdV05TLmRhdGFPEQH+AAAAAAH+AAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtkmAfSHV0dG9uIC0gRm9sZCBhbmQgdW4jMkQ5MjVFLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC2SXsOTH+FQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABkh1dHRvbgAQAAgAAME0fl0AAAARAAgAAMOTZjEAAAABABAALZJgAC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpIdXR0b246SHV0dG9uIC0gRm9sZCBhbmQgdW4jMkQ5MjVFLnBkZgAADgB0ADkASAB1AHQAdABvAG4AIAAtACAARgBvAGwAZAAgAGEAbgBkACAAdQBuAGYAbwBsAGQAIABmAG8AcgAgAHAAcgBvAGcAcgBhAG0AIABzAGUAbQBhAG4AdABpAGMAcwAgACgAMQA5ADkAOAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFRVc2Vycy9qZXJlbXkvUGFwZXJzL0h1dHRvbi9IdXR0b24gLSBGb2xkIGFuZCB1bmZvbGQgZm9yIHByb2dyYW0gc2VtYW50aWNzICgxOTk4KS5wZGYAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoA+gD/AQcDCQMLAxADGQMkAygDNgM9A0YDSwNOAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA1s=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/289423.289457}}

@article{Paakki:Attribute:1995,
	Address = {New York, NY, USA},
	Author = {Jukka Paakki},
	Date-Added = {2007-12-22 20:08:48 -0500},
	Date-Modified = {2008-01-14 01:38:24 -0500},
	Doi = {http://doi.acm.org/10.1145/210376.197409},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Keywords = {attribute grammars},
	Local-Url = {file://localhost/Users/jeremy/Papers/Paakki/Paakki%20-%20Attribute%20grammar%20paradigms---a%20high-level%20methodology%20(1995).pdf},
	Number = {2},
	Pages = {196--255},
	Publisher = {ACM},
	Title = {Attribute grammar paradigms---a high-level methodology in language implementation},
	Volume = {27},
	Year = {1995},
	Abstract = {Attribute grammars are a formalism for specifying programming languages. They have been applied to a great number of systems automatically producing language implementations from their specifications. The systems and their specification languages can be evaluated and classified according to their level of application support, linguistic characteristics, and degree of automation.A survey of attribute grammar-based specification languages is given. The modern advanced specification languages extend the core attribute grammar model with concepts and primitives from established programming paradigms. The main ideas behind the developed attribute grammar paradigms are discussed, and representative specification languages are presented with a common example grammar. The presentation is founded on mapping elements of attribute grammars to their counterparts in programming languages. This methodology of integrating two problem-solving disciplines together is explored with a classification of the paradigms into structured, modular, object-oriented, logic, and functional attribute grammars. The taxonomy is complemented by introducing approaches based on an implicit parallel or incremental attribute evaluation paradigm.  },
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEF4uLi8uLi9QYXBlcnMvUGFha2tpL1BhYWtraSAtIEF0dHJpYnV0ZSBncmFtbWFyIHBhcmFkaWdtcy0tLWEgaGlnaC1sZXZlbCBtZXRob2RvbG9neSAoMTk5NSkucGRm0hsPHB1XTlMuZGF0YU8RAjIAAAAAAjIAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2ShR9QYWFra2kgLSBBdHRyaWJ1dGUgZyMyRDkyODIucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZKCw5MhH1BERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGUGFha2tpABAACAAAwTR+XQAAABEACAAAw5NnbwAAAAEAEAAtkoUALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlBhYWtraTpQYWFra2kgLSBBdHRyaWJ1dGUgZyMyRDkyODIucGRmAAAOAJYASgBQAGEAYQBrAGsAaQAgAC0AIABBAHQAdAByAGkAYgB1AHQAZQAgAGcAcgBhAG0AbQBhAHIAIABwAGEAcgBhAGQAaQBnAG0AcwAtAC0ALQBhACAAaABpAGcAaAAtAGwAZQB2AGUAbAAgAG0AZQB0AGgAbwBkAG8AbABvAGcAeQAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGVVc2Vycy9qZXJlbXkvUGFwZXJzL1BhYWtraS9QYWFra2kgLSBBdHRyaWJ1dGUgZ3JhbW1hciBwYXJhZGlnbXMtLS1hIGhpZ2gtbGV2ZWwgbWV0aG9kb2xvZ3kgKDE5OTUpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBCwEQARgDTgNQA1UDXgNpA20DewOCA4sDkAOTAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA6A=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/210376.197409}}

@inproceedings{Gibbons:Design:2006,
	Address = {New York, NY, USA},
	Author = {Jeremy Gibbons},
	Booktitle = {WGP '06: Proceedings of the 2006 ACM SIGPLAN workshop on Generic programming},
	Date-Added = {2007-12-22 20:06:01 -0500},
	Date-Modified = {2007-12-22 20:08:02 -0500},
	Doi = {http://doi.acm.org/10.1145/1159861.1159863},
	Isbn = {1-59593-492-6},
	Local-Url = {file://localhost/Users/jeremy/Papers/Gibbons/Gibbons%20-%20Design%20patterns%20as%20higher-order%20datatype-generic%20programs%20(2006).pdf},
	Location = {Portland, Oregon, USA},
	Pages = {1--12},
	Publisher = {ACM},
	Title = {Design patterns as higher-order datatype-generic programs},
	Year = {2006},
	Abstract = {Design patterns are reusable abstractions in object-oriented software. However, using current mainstream programming languages, these elements can only be expressed extra-linguistically: as prose, pictures, and prototypes. We believe that this is not inherent in the patterns themselves, but evidence of a lack of expressivity in the languages of today. We expect that, in the languages of the future, the code parts of design patterns will be expressible as reusable library components. Indeed, we claim that the languages of tomorrow will suffice; the future is not far away. All that is needed, in addition to commonly-available features, are higher-order and datatype-generic constructs; these features are already or nearly available now. We argue the case by presenting higher-order datatype-generic programs capturing ORIGAMI, a small suite of patterns for recursive data structures.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGMuLi8uLi9QYXBlcnMvR2liYm9ucy9HaWJib25zIC0gRGVzaWduIHBhdHRlcm5zIGFzIGhpZ2hlci1vcmRlciBkYXRhdHlwZS1nZW5lcmljIHByb2dyYW1zICgyMDA2KS5wZGbSGw8cHVdOUy5kYXRhTxECQAAAAAACQAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZI8H0dpYmJvbnMgLSBEZXNpZ24gcGF0IzJEOTIzOS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkjnDkx8XUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdHaWJib25zAAAQAAgAAME0fl0AAAARAAgAAMOTZWcAAAABABAALZI8AC2RPwADR6wAAGvYAAIAQE9kaW46VXNlcnM6amVyZW15OlBhcGVyczpHaWJib25zOkdpYmJvbnMgLSBEZXNpZ24gcGF0IzJEOTIzOS5wZGYADgCeAE4ARwBpAGIAYgBvAG4AcwAgAC0AIABEAGUAcwBpAGcAbgAgAHAAYQB0AHQAZQByAG4AcwAgAGEAcwAgAGgAaQBnAGgAZQByAC0AbwByAGQAZQByACAAZABhAHQAYQB0AHkAcABlAC0AZwBlAG4AZQByAGkAYwAgAHAAcgBvAGcAcgBhAG0AcwAgACgAMgAwADAANgApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGpVc2Vycy9qZXJlbXkvUGFwZXJzL0dpYmJvbnMvR2liYm9ucyAtIERlc2lnbiBwYXR0ZXJucyBhcyBoaWdoZXItb3JkZXIgZGF0YXR5cGUtZ2VuZXJpYyBwcm9ncmFtcyAoMjAwNikucGRmABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqARABFQEdA2EDYwNoA3EDfAOAA44DlQOeA6MDpgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOz},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1159861.1159863}}

@inproceedings{Turbak:Cycle:2001,
	Address = {New York, NY, USA},
	Author = {Franklyn Turbak and J. B. Wells},
	Booktitle = {PPDP '01: Proceedings of the 3rd ACM SIGPLAN international conference on Principles and practice of declarative programming},
	Date-Added = {2007-12-22 20:02:35 -0500},
	Date-Modified = {2007-12-22 20:08:24 -0500},
	Doi = {http://doi.acm.org/10.1145/773184.773200},
	Isbn = {1-58113-388-X},
	Local-Url = {file://localhost/Users/jeremy/Papers/Turbak/Turbak-Wells%20-%20Cycle%20therapy%20a%20prescription%20for%20fold%20and%20unfold%20(2001).pdf},
	Location = {Florence, Italy},
	Pages = {137--149},
	Publisher = {ACM},
	Title = {Cycle therapy: a prescription for fold and unfold on regular trees},
	Year = {2001},
	Abstract = {Cyclic data structures can be tricky to create and manipulate in declarative programming languages. In a declarative setting, a natural way to view cyclic structures is as denoting regular trees, those trees which may be infinite but have only a finite number of distinct subtrees. This paper shows how to implement the unfold (anamorphism) operator in both eager and lazy languages so as to create cyclic structures when the result is a regular tree as opposed to merely infinite lazy structures. The usual fold (catamorphism) operator when used with a strict combining function on any infinite tree yields an undefined result. As an alternative, this paper defines and show how to implement a cycfold operator with more useful semantics when used with a strict function on cyclic structures representing regular trees. This paper also introduces an abstract data type (cycamores) to simplify the use of cyclic structures representing regular trees in both eager and lazy languages. Implementions of cycamores in both SML and Haskell are presented.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEF4uLi8uLi9QYXBlcnMvVHVyYmFrL1R1cmJhay1XZWxscyAtIEN5Y2xlIHRoZXJhcHkgYSBwcmVzY3JpcHRpb24gZm9yIGZvbGQgYW5kIHVuZm9sZCAoMjAwMSkucGRm0hsPHB1XTlMuZGF0YU8RAjIAAAAAAjIAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2SAx9UdXJiYWstV2VsbHMgLSBDeWNsZSMyRDkyMDEucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALZIBw5MeEFBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGVHVyYmFrABAACAAAwTR+XQAAABEACAAAw5NkYAAAAAEAEAAtkgMALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlR1cmJhazpUdXJiYWstV2VsbHMgLSBDeWNsZSMyRDkyMDEucGRmAAAOAJYASgBUAHUAcgBiAGEAawAtAFcAZQBsAGwAcwAgAC0AIABDAHkAYwBsAGUAIAB0AGgAZQByAGEAcAB5ACAAYQAgAHAAcgBlAHMAYwByAGkAcAB0AGkAbwBuACAAZgBvAHIAIABmAG8AbABkACAAYQBuAGQAIAB1AG4AZgBvAGwAZAAgACgAMgAwADAAMQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGVVc2Vycy9qZXJlbXkvUGFwZXJzL1R1cmJhay9UdXJiYWstV2VsbHMgLSBDeWNsZSB0aGVyYXB5IGEgcHJlc2NyaXB0aW9uIGZvciBmb2xkIGFuZCB1bmZvbGQgKDIwMDEpLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBCwEQARgDTgNQA1UDXgNpA20DewOCA4sDkAOTAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA6A=},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/773184.773200}}

@article{Hudak:Conception:1989,
	Address = {New York, NY, USA},
	Author = {Paul Hudak},
	Date-Added = {2007-12-22 19:56:05 -0500},
	Date-Modified = {2008-01-02 18:46:01 -0500},
	Doi = {http://doi.acm.org/10.1145/72551.72554},
	Issn = {0360-0300},
	Journal = {ACM Comput. Surv.},
	Keywords = {history of computing},
	Local-Url = {file://localhost/Users/jeremy/Papers/Hudak/Hudak%20-%20Conception,%20evolution,%20and%20application%20of%20functional%20programming%20(1989).pdf},
	Number = {3},
	Pages = {359--411},
	Publisher = {ACM},
	Rating = {5},
	Read = {Yes},
	Title = {Conception, evolution, and application of functional programming languages},
	Volume = {21},
	Year = {1989},
	Abstract = {The foundations of functional programming languages are examined from both historical and technical perspectives. Their evolution is traced through several critical periods: early work on lambda calculus and combinatory calculus, Lisp, Iswim, FP, ML, and modern functional languages such as Miranda1 and Haskell. The fundamental premises on which the functional programming methodology stands are critically analyzed with respect to philosophical, theoretical, and pragmatic concerns. Particular attention is paid to the main features that characterize modern functional languages: higher-order functions, lazy evaluation, equations and pattern matching, strong static typing and type inference, and data abstraction. In addition, current research areas---such as parallelism, nondeterminism, input/output, and state-oriented computations---are examined with the goal of predicting the future development and application of functional languages.},
	Annote = {Tremendously useful. Quickly moves on from Lisp, and also points out how Lisp isn't really functional so much as a major influence on functional languages. Very valuable for its lucid introduction to lambda calculus basics, including typed lambda calculi. Distinguishes between normal-order reduction and its specific implementation as lazy evaluation. Argues strongly for lazy evaluation being practically useful as well as theoretically. Addresses annotated functional languages (for parallelism or the like) as "parafunctional languages"; also touches briefly on dataflow languages and machines and mentions functional-logic programming in passing as an appealing but at the time not really very viable approach.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGYuLi8uLi9QYXBlcnMvSHVkYWsvSHVkYWsgLSBDb25jZXB0aW9uLCBldm9sdXRpb24sIGFuZCBhcHBsaWNhdGlvbiBvZiBmdW5jdGlvbmFsIHByb2dyYW1taW5nICgxOTg5KS5wZGbSGw8cHVdOUy5kYXRhTxECSgAAAAACSgACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZF5H0h1ZGFrIC0gQ29uY2VwdGlvbiwgIzI5Rjg3Qi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp+HsAAAAAAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVIdWRhawAAEAAIAADBNH5dAAAAEQAIAAAAAAAAAAAAAQAQAC2ReQAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6SHVkYWs6SHVkYWsgLSBDb25jZXB0aW9uLCAjMjlGODdCLnBkZgAOAKgAUwBIAHUAZABhAGsAIAAtACAAQwBvAG4AYwBlAHAAdABpAG8AbgAsACAAZQB2AG8AbAB1AHQAaQBvAG4ALAAgAGEAbgBkACAAYQBwAHAAbABpAGMAYQB0AGkAbwBuACAAbwBmACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMQA5ADgAOQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAG1Vc2Vycy9qZXJlbXkvUGFwZXJzL0h1ZGFrL0h1ZGFrIC0gQ29uY2VwdGlvbiwgZXZvbHV0aW9uLCBhbmQgYXBwbGljYXRpb24gb2YgZnVuY3Rpb25hbCBwcm9ncmFtbWluZyAoMTk4OSkucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgETARgBIANuA3ADdQN+A4kDjQObA6IDqwOwA7MAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADwA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/72551.72554}}

@inproceedings{Wadler:Monads:1995,
	Address = {London, UK},
	Author = {Wadler, Philip},
	Booktitle = {Advanced Functional Programming},
	Date-Added = {2007-12-20 19:50:42 -0500},
	Date-Modified = {2007-12-22 19:54:28 -0500},
	Editor = {Jeuring, Johan and Meijer, Erik},
	Keywords = {monads, input-output},
	Local-Url = {file://localhost/Users/jeremy/Papers/Wadler/Wadler%20-%20Monads%20for%20functional%20programming%20(1995).pdf},
	Month = {May},
	Pages = {24--52},
	Publisher = {Springer-Verlag},
	Rating = {3},
	Read = {Yes},
	Series = {Lecture Notes in Computer Science},
	Title = {Monads for functional programming},
	Url = {http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf},
	Volume = {925},
	Year = {1995},
	Abstract = {The use of monads to structure functional programs is described. Moands provide a convenient framework for simulating efects found in other languages, such as global state, exception handling, output, or non-determinism. Three case studies are looked at in detail: how monads ease the modification of a simple evaluator; how monads act as the basis of a datatype of arrays subject to in-place update; and how monads can be used to build parsers.},
	Annote = {Opens with a very lucid discussion of pure versus impure: pure === lambda calculus (easy to reason about), impure === lambda calculus + effects (sometimes enables more compact expression). Shows how monads enable simulation of effects while retaining purity, and derives the monad laws without reference to category theory.

Also gives a good high-level overview of what a pure functional program is (a set of equations), and so the good and bad of being pure: all data flow is (painfully) explicit. 

Raises an interesting question for compile-time optimization: just because we can perform an optimization, should we? What if a program's feasibility depends on the use of that optimization? Is it then time to migrate that optimization from being the compiler's responsibility to the programmer's/language's? When do we cross the line from optimization and simple improvement to a real, marked change?},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEkuLi8uLi9QYXBlcnMvV2FkbGVyL1dhZGxlciAtIE1vbmFkcyBmb3IgZnVuY3Rpb25hbCBwcm9ncmFtbWluZyAoMTk5NSkucGRm0hsPHB1XTlMuZGF0YU8RAfIAAAAAAfIAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2ReB9XYWRsZXIgLSBNb25hZHMgZm9yICMyOUY4OTUucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKfiVAAAAAAAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAGV2FkbGVyABAACAAAwTR+XQAAABEACAAAAAAAAAAAAAEAEAAtkXgALZE/AANHrAAAa9gAAgA/T2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOldhZGxlcjpXYWRsZXIgLSBNb25hZHMgZm9yICMyOUY4OTUucGRmAAAOAGwANQBXAGEAZABsAGUAcgAgAC0AIABNAG8AbgBhAGQAcwAgAGYAbwByACAAZgB1AG4AYwB0AGkAbwBuAGEAbAAgAHAAcgBvAGcAcgBhAG0AbQBpAG4AZwAgACgAMQA5ADkANQApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAFBVc2Vycy9qZXJlbXkvUGFwZXJzL1dhZGxlci9XYWRsZXIgLSBNb25hZHMgZm9yIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgKDE5OTUpLnBkZgATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgD2APsBAwL5AvsDAAMJAxQDGAMmAy0DNgM7Az4AAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADSw==},
	Bdsk-Url-1 = {http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf}}

@book{Cooper:Engineering:2004,
	Address = {San Francisco},
	Author = {Cooper, Keith D. and Torczon, Linda},
	Date-Added = {2007-12-15 17:09:56 -0500},
	Date-Modified = {2008-02-10 11:14:27 -0500},
	Keywords = {compilation},
	Publisher = {Morgan Kaufmann Publishers},
	Rating = {3},
	Read = {Yes},
	Title = {Engineering a Compiler},
	Year = {2004}}

@book{Scott:Programming:2006,
	Address = {San Francisco},
	Author = {Scott, Michael L.},
	Date-Added = {2007-12-15 17:03:52 -0500},
	Date-Modified = {2007-12-15 17:08:41 -0500},
	Edition = {2nd},
	Publisher = {Morgan Kaufmann Publishers},
	Title = {Programming Language Pragmatics},
	Year = {2006}}

@inproceedings{Hudak:A-history:2007,
	Address = {New York},
	Author = {Paul Hudak and John Hughes and Peyton Jones, Simon and Philip Wadler},
	Booktitle = {HOPL III: Proceedings of the third ACM SIGPLAN conference on History of programming languages},
	Date-Added = {2007-12-13 14:58:46 -0500},
	Date-Modified = {2007-12-22 19:54:28 -0500},
	Doi = {http://doi.acm.org/10.1145/1238844.1238856},
	Isbn = {978-1-59593-766-X},
	Keywords = {history of computing, haskell},
	Local-Url = {file://localhost/Users/jeremy/Papers/Hudak/Hudak-Hughes-Peyton%20Jones%20-%20A%20history%20of%20%7BH%7Daskell%20being%20lazy%20with%20(2007).pdf},
	Location = {San Diego, California},
	Pages = {12-1--12-55},
	Publisher = {ACM},
	Rating = {4},
	Read = {Yes},
	Title = {A history of {H}askell: being lazy with class},
	Year = {2007},
	Abstract = {This paper describes the history of Haskell, including its genesis and principles, technical contributions, implementations and tools, and applications and impact.},
	Annote = {Its discussion of implementations and history is particularly helpful for orienting one to Haskell, since there are a lot of compiler/interpreter hangers-on and a lot of history that I haven't seen anywhere else. The section towards the end on Haskell's influence is also very interesting: functional-logic languages, constraint-based programming, functional reactive programming. Neat stuff.

Also includes a concise introduction to Haskell I/O before and after monads.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGAuLi8uLi9QYXBlcnMvSHVkYWsvSHVkYWstSHVnaGVzLVBleXRvbiBKb25lcyAtIEEgaGlzdG9yeSBvZiB7SH1hc2tlbGwgYmVpbmcgbGF6eSB3aXRoICgyMDA3KS5wZGbSGw8cHVdOUy5kYXRhTxECOAAAAAACOAACAAAET2RpbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwTRGHUgrAAAALZF5H0h1ZGFrLUh1Z2hlcy1QZXl0b24gIzI5Rjg3Qy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp+HwAAAAAAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAVIdWRhawAAEAAIAADBNH5dAAAAEQAIAAAAAAAAAAAAAQAQAC2ReQAtkT8AA0esAABr2AACAD5PZGluOlVzZXJzOmplcmVteTpQYXBlcnM6SHVkYWs6SHVkYWstSHVnaGVzLVBleXRvbiAjMjlGODdDLnBkZgAOAJwATQBIAHUAZABhAGsALQBIAHUAZwBoAGUAcwAtAFAAZQB5AHQAbwBuACAASgBvAG4AZQBzACAALQAgAEEAIABoAGkAcwB0AG8AcgB5ACAAbwBmACAAewBIAH0AYQBzAGsAZQBsAGwAIABiAGUAaQBuAGcAIABsAGEAegB5ACAAdwBpAHQAaAAgACgAMgAwADAANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGdVc2Vycy9qZXJlbXkvUGFwZXJzL0h1ZGFrL0h1ZGFrLUh1Z2hlcy1QZXl0b24gSm9uZXMgLSBBIGhpc3Rvcnkgb2Yge0h9YXNrZWxsIGJlaW5nIGxhenkgd2l0aCAoMjAwNykucGRmAAATAAEvAAAVAAIADf//AACABtIfICEiWCRjbGFzc2VzWiRjbGFzc25hbWWjIiMkXU5TTXV0YWJsZURhdGFWTlNEYXRhWE5TT2JqZWN00h8gJieiJyRcTlNEaWN0aW9uYXJ5AAgAEQAbACQAKQAyAEQASQBMAFEAUwBcAGIAaQB0AHwAgwCGAIgAigCNAI8AkQCTAKAAqgENARIBGgNWA1gDXQNmA3EDdQODA4oDkwOYA5sAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADqA==},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/1238844.1238856}}

@article{Wadler:Fixing:1987,
	Author = {Philip Wadler},
	Date-Added = {2007-12-13 14:15:18 -0500},
	Date-Modified = {2007-12-22 19:54:28 -0500},
	Journal = {Software Practice and Experience},
	Keywords = {space leak, garbage collection, functional languages, lazy evaluation},
	Local-Url = {file://localhost/Users/jeremy/Papers/Wadler/Wadler%20-%20Fixing%20some%20space%20leaks%20with%20(1987).pdf},
	Month = {September},
	Number = {17(9)},
	Pages = {595-608},
	Rating = {3},
	Read = {Yes},
	Title = {Fixing some space leaks with a garbage collector},
	Url = {http://www.research.avayalabs.com/user/wadler/papers/leak/leak.ps},
	Year = {1987},
	Abstract = {Some functional programs may use more space than would be expected. A modification to the garbage collector is suggested which solves this problem in some cases. Related work is discussed.},
	Annote = {Proposes having the garbage collector perform limited evaluation to eliminate a certain class of space leaks involving tuples and pattern-matched where clauses (as allowed in Miranda and Haskell). Contrasts to a more general but more obnoxious solution of forcing programmers to insert parallelism annotations.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEEQuLi8uLi9QYXBlcnMvV2FkbGVyL1dhZGxlciAtIEZpeGluZyBzb21lIHNwYWNlIGxlYWtzIHdpdGggKDE5ODcpLnBkZtIbDxwdV05TLmRhdGFPEQHkAAAAAAHkAAIAAARPZGluAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBNEYdSCsAAAAtkXgfV2FkbGVyIC0gRml4aW5nIHNvbWUjMkM3NzdCLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACx3e8NqGCgAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABldhZGxlcgAQAAgAAME0fl0AAAARAAgAAMNqXngAAAABABAALZF4AC2RPwADR6wAAGvYAAIAP09kaW46VXNlcnM6amVyZW15OlBhcGVyczpXYWRsZXI6V2FkbGVyIC0gRml4aW5nIHNvbWUjMkM3NzdCLnBkZgAADgBiADAAVwBhAGQAbABlAHIAIAAtACAARgBpAHgAaQBuAGcAIABzAG8AbQBlACAAcwBwAGEAYwBlACAAbABlAGEAawBzACAAdwBpAHQAaAAgACgAMQA5ADgANwApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAEtVc2Vycy9qZXJlbXkvUGFwZXJzL1dhZGxlci9XYWRsZXIgLSBGaXhpbmcgc29tZSBzcGFjZSBsZWFrcyB3aXRoICgxOTg3KS5wZGYAABMAAS8AABUAAgAN//8AAIAG0h8gISJYJGNsYXNzZXNaJGNsYXNzbmFtZaMiIyRdTlNNdXRhYmxlRGF0YVZOU0RhdGFYTlNPYmplY3TSHyAmJ6InJFxOU0RpY3Rpb25hcnkACAARABsAJAApADIARABJAEwAUQBTAFwAYgBpAHQAfACDAIYAiACKAI0AjwCRAJMAoACqAPEA9gD+AuYC6ALtAvYDAQMFAxMDGgMjAygDKwAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAM4},
	Bdsk-Url-1 = {http://www.research.avayalabs.com/user/wadler/papers/leak/leak.ps}}

@inproceedings{Peyton-Jones:Tackling:2000,
	Author = {Peyton Jones, Simon L.},
	Booktitle = {2000 Marktoberdorf Summer School},
	Date-Added = {2007-12-12 09:58:16 -0500},
	Date-Modified = {2007-12-22 19:54:28 -0500},
	Keywords = {haskell, monads, input-output, foreign-function interface, lazy evaluation},
	Local-Url = {file://localhost/Users/jeremy/Papers/Peyton%20Jones/Peyton%20Jones%20-%20Tackling%20the%20awkward%20squad%20monadic%20input-output,%20(2000).pdf},
	Rating = {3},
	Read = {Yes},
	Title = {Tackling the awkward squad: monadic input/output, concurrency, exceptions, and foreign-language calls in {H}askell},
	Url = {http://research.microsoft.com/Users/simonpj/papers/marktoberdorf.ps.gz},
	Year = {2000},
	Abstract = {Functional programming may be beautiful, but to write real applications we must grapple with awkward real-world issues: input/output, robustness, concurrency, and interfacing to programs written in other languages.

These lecture notes give an overview of the techniques that have been developed by the Haskell community to address these problems. I introduce various proposed extensions to Haskell along the way, and I offer an operational semantics that explains what these extensions mean.},
	Annote = {Provides a clear introduction to the I/O monad and why it is useful. Introduces briefly the stream model it replaced. Also discusses explicitly parallelizing Haskell via Concurrent Haskell, using IORefs and MVars, exceptions, and the Haskell foreign-function interface and related issues. Valuable as well for its step-by-step development of an operational semantics for these issues.},
	Bdsk-File-1 = {YnBsaXN0MDDUAQIDBAUGBwpZJGFyY2hpdmVyWCR2ZXJzaW9uVCR0b3BYJG9iamVjdHNfEA9OU0tleWVkQXJjaGl2ZXISAAGGoNEICVRyb290gAGoCwwXGBkaHiVVJG51bGzTDQ4PEBMWWk5TLm9iamVjdHNXTlMua2V5c1YkY2xhc3OiERKABIAFohQVgAKAA4AHXHJlbGF0aXZlUGF0aFlhbGlhc0RhdGFfEGQuLi8uLi9QYXBlcnMvUGV5dG9uIEpvbmVzL1BleXRvbiBKb25lcyAtIFRhY2tsaW5nIHRoZSBhd2t3YXJkIHNxdWFkIG1vbmFkaWMgaW5wdXQtb3V0cHV0LCAoMjAwMCkucGRm0hsPHB1XTlMuZGF0YU8RAkQAAAAAAkQAAgAABE9kaW4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAME0Rh1IKwAAAC2Reh9QZXl0b24gSm9uZXMgLSBUYWNrbCMyOUY4OTgucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKfiYAAAAAAAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAMUGV5dG9uIEpvbmVzABAACAAAwTR+XQAAABEACAAAAAAAAAAAAAEAEAAtkXoALZE/AANHrAAAa9gAAgBFT2RpbjpVc2VyczpqZXJlbXk6UGFwZXJzOlBleXRvbiBKb25lczpQZXl0b24gSm9uZXMgLSBUYWNrbCMyOUY4OTgucGRmAAAOAJYASgBQAGUAeQB0AG8AbgAgAEoAbwBuAGUAcwAgAC0AIABUAGEAYwBrAGwAaQBuAGcAIAB0AGgAZQAgAGEAdwBrAHcAYQByAGQAIABzAHEAdQBhAGQAIABtAG8AbgBhAGQAaQBjACAAaQBuAHAAdQB0AC0AbwB1AHQAcAB1AHQALAAgACgAMgAwADAAMAApAC4AcABkAGYADwAKAAQATwBkAGkAbgASAGtVc2Vycy9qZXJlbXkvUGFwZXJzL1BleXRvbiBKb25lcy9QZXl0b24gSm9uZXMgLSBUYWNrbGluZyB0aGUgYXdrd2FyZCBzcXVhZCBtb25hZGljIGlucHV0LW91dHB1dCwgKDIwMDApLnBkZgAAEwABLwAAFQACAA3//wAAgAbSHyAhIlgkY2xhc3Nlc1okY2xhc3NuYW1loyIjJF1OU011dGFibGVEYXRhVk5TRGF0YVhOU09iamVjdNIfICYnoickXE5TRGljdGlvbmFyeQAIABEAGwAkACkAMgBEAEkATABRAFMAXABiAGkAdAB8AIMAhgCIAIoAjQCPAJEAkwCgAKoBEQEWAR4DZgNoA20DdgOBA4UDkwOaA6MDqAOrAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA7g=},
	Bdsk-Url-1 = {http://research.microsoft.com/Users/simonpj/papers/marktoberdorf.ps.gz}}

@comment{BibDesk Static Groups{
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>group name</key>
		<string>NCF Thesis</string>
		<key>keys</key>
		<string>Hopcroft:Introduction:2007,Zima:Supercompilers:1991,Bannerjee:Dependence:1988,Grune:Parsing:2007,Bravenboer:Concrete:2004,Cooper:Engineering:2004,Bannerjee:Loop:1993,Pager:The-lane:1973,Parr:ANTLR:1995,Bravenboer:Declarative:2006,Bravenboer:Preventing:2007,Spector:Efficient:1988,Scott:Programming:2006,Wolfe:High-Performance:1996,Muchnick:Advanced:1997,Kulkarni:Fast:2005,Hines:Using:2005,Bannerjee:Loop:1994,McPeak:Elkhound:2002,Hovemeyer:Finding:2004,Pottier:Menhir:2007,Aho:Compilers:2006,Lattner:LLVM:2002,Wyk:Context-aware:2007</string>
	</dict>
	<dict>
		<key>group name</key>
		<string>Textbooks</string>
		<key>keys</key>
		<string>Cooper:Engineering:2004,Muchnick:Advanced:1997,Scott:Programming:2006,Hopcroft:Introduction:2007</string>
	</dict>
</array>
</plist>
}}

@comment{BibDesk Smart Groups{
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>conditions</key>
		<array>
			<dict>
				<key>comparison</key>
				<integer>4</integer>
				<key>key</key>
				<string>Abstract</string>
				<key>value</key>
				<string></string>
				<key>version</key>
				<string>1</string>
			</dict>
		</array>
		<key>conjunction</key>
		<integer>0</integer>
		<key>group name</key>
		<string>Abstract missing</string>
	</dict>
	<dict>
		<key>conditions</key>
		<array>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Journal</string>
				<key>value</key>
				<string>csur</string>
				<key>version</key>
				<string>1</string>
			</dict>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Journal</string>
				<key>value</key>
				<string>comput. surv.</string>
				<key>version</key>
				<string>1</string>
			</dict>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Journal</string>
				<key>value</key>
				<string>survey</string>
				<key>version</key>
				<string>1</string>
			</dict>
		</array>
		<key>conjunction</key>
		<integer>1</integer>
		<key>group name</key>
		<string>CSUR</string>
	</dict>
	<dict>
		<key>conditions</key>
		<array>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Url</string>
				<key>value</key>
				<string>~</string>
				<key>version</key>
				<string>1</string>
			</dict>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Url</string>
				<key>value</key>
				<string>$</string>
				<key>version</key>
				<string>1</string>
			</dict>
			<dict>
				<key>comparison</key>
				<integer>2</integer>
				<key>key</key>
				<string>Url</string>
				<key>value</key>
				<string>#</string>
				<key>version</key>
				<string>1</string>
			</dict>
		</array>
		<key>conjunction</key>
		<integer>1</integer>
		<key>group name</key>
		<string>Problem URLs</string>
	</dict>
	<dict>
		<key>conditions</key>
		<array>
			<dict>
				<key>comparison</key>
				<integer>4</integer>
				<key>key</key>
				<string>Read</string>
				<key>value</key>
				<string>No</string>
				<key>version</key>
				<string>1</string>
			</dict>
		</array>
		<key>conjunction</key>
		<integer>0</integer>
		<key>group name</key>
		<string>Unread</string>
	</dict>
</array>
</plist>
}}
