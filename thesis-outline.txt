Compiling Functional Languages
Jeremy W. Sherman
New College of Florida
Sarasota, Florida
Spring 2008

I. Background
  A. Introduction
    1. Topic
    2. Why topic interesting
    3. Structure of our examination of the topic
    4. Target audience

  B. Fundamental Theoretical Background
    1. Computer Science
      (a) Entscheidungsproblem
      (b) Turing
      (c) Church
    2. Computer Architecture
         Overview: touch on pipelining, memory hierarchy
    3. Compilation
      (a) Three-part model
            (i) Front-end; theory of grammars, lexing, parsing, etc.
           (ii) Middle
          (iii) Back-end
      (b) Intermediate representations 
            (and their importance for optimizations)
      (c) Bootstrapping

II. Compiling Imperative Languages (20-30 pp.)
  A. What Is an Imperative Language (be brief)
    1. Quick History
    2. Examples
    3. Concepts
    4. Problems
  D. Optimizing (main body of chapter)
       Optimizations with examples

III. Compiling Functional Languages
  A. Theory Fundamental to Functional Programming
    1. Lambda calculus
      (a) Untyped
      (b) Typed
    2. Type theory
  B. What Is a Functional Language
    1. History
    2. Examples
    3. Concepts
    4. Problems
  C. Case Studies
    1. OCAML
    2. GHC

IV. Comparing Imperative and Functional Language Compilation
  A. Comparing Functional and Imperative Languages
  B. Comparing Compilation Issues
  C. Conclusion

Bibliography
Index
